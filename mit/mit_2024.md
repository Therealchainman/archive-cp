# Mit Contest 2024

## Sample Contest

## Transition Game

### Solution 1: functional graph, cycle detection, length of cycles in functional graph

```py
n = int(input())
edges = list(map(lambda x: int(x) - 1, input().split()))
ans = 0
vis = [0] * n
def search(u):
    cycle_len = 0
    parent = {u: None}
    is_cycle = False
    while True:
        vis[u] = 1
        v = edges[u]
        if v in parent: 
            is_cycle = True
            break
        if vis[v]: break
        parent[v] = u
        u = v
    if is_cycle:
        crit_point = parent[edges[u]]
        while u != crit_point:
            cycle_len += 1
            u = parent[u]
    return cycle_len
for i in range(n):
    if vis[i]: continue
    ans += search(i)
print(ans)
```

## Social distance on a graph

### Solution 1:  binary search, bipartite graph, directed weighted graph, 2-Colorable

```py
MAX = 10**10
UNVISITED = -1
RED = 0
BLUE = 1

def main():
    N, M = map(int, input().split())
    adj = [[] for _ in range(N)]
    edges = [None] * M
    for i in range(M):
        u, v, w = map(int, input().split())
        u -= 1; v -= 1
        edges[i] = (u, v, w)
    edges.sort(key = lambda x: x[-1])
    for u, v, w in edges:
        adj[u].append((v, w))
        adj[v].append((u, w))
    def possible(target):
        colors = [UNVISITED] * N
        for i in range(N):
            if colors[i] != UNVISITED: continue
            colors[i] = RED
            stack = [i]
            while stack:
                u = stack.pop()
                for v, w in adj[u]:
                    if w >= target: break
                    if colors[v] != UNVISITED: 
                        if colors[u] == colors[v]: return False
                        continue
                    colors[v] = colors[u] ^ 1
                    stack.append(v)
                edge_count = edge_sum = 0
                while edge_count < 2:
                    if edge_count == len(adj[u]): break
                    edge_sum += adj[u][edge_count][-1]
                    edge_count += 1
                if edge_count == 2 and edge_sum < target: return False
        return True
    left, right = 0, MAX
    while left < right:
        mid = (left + right + 1) >> 1
        if possible(mid):
            left = mid
        else:
            right = mid - 1
    print(left)

if __name__ == '__main__':
    main()
```

## Zigzag Tree

### Solution 1:  

```py

```

## Guessing Permutation for as Long as Possible

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

## 

### Solution 1:  

```py

```

