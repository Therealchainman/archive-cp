# 1000. Minimum Cost to Merge Stones

## Solution: 

```c++
const int INF = 1e9;
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n = stones.size();
        vector<int> psum(n+1,0);
        for (int i = 0;i<n;i++) {
            psum[i+1]=psum[i]+stones[i];
        }
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(k+1,-1)));
        function<int(int,int,int)> dfs = [&](int L, int R, int piles) {
            if (piles==R-L+1) return 0;
            if (piles>R-L+1) return INF;
            if (dp[L][R][piles]!=-1) return dp[L][R][piles];
            if (piles==1) {
                return dfs(L,R,k) + psum[R+1]-psum[L];
            }
            int cost = INF;
            for (int i = L;i<R;i++) {
                cost = min(cost, dfs(L,i,1)+dfs(i+1,R,piles-1));
            }
            return dp[L][R][piles]=cost;
        };
        int res = dfs(0,n-1,1);
        return res<INF ? res : -1;
    }
};
```

[3,2,4,1]
2
[3,5,1,2,6]
2
[1,2,3,4,5,6,7,8,9,10]
2
[34,65,100,45,34,100,2,3,4,6]
2