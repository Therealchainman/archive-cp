# 1463. Cherry Pickup II

### Solution: Recursive DP with moving robots synchronized (r=r1=r2)
O(RC^2) time and O(RC^2) space

```c++
int R, C;
bool inBounds(int r, int c) {
    return r>=0 && r<R && c>=0 && c<C;
}
int dfs(int r, int c1, int c2, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp) {
    if (!inBounds(r,c1) || !inBounds(r,c2)) {return 0;}
    if (dp[r][c1][c2]!=-1) {return dp[r][c1][c2];}
    int ans = 0;
    for (int i = -1;i<=1;i++) {
        for (int j=-1;j<=1;j++) {
            ans = max(ans, dfs(r+1,c1+i,c2+j,grid,dp));
        }
    }
    ans += grid[r][c1];
    if (c1!=c2) {
        ans+=grid[r][c2];
    }
    return dp[r][c1][c2] = ans;
    
}
int cherryPickup(vector<vector<int>>& grid) {
    R = grid.size(), C = grid[0].size();
    vector<vector<vector<int>>> dp(R, vector<vector<int>>(C, vector<int>(C,-1)));
    return dfs(0,0,C-1,grid,dp);
}
```