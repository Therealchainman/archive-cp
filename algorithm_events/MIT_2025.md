# MIT 2025

# M(IT)^2 2025 Winter Contest Advanced Round One

## Number Reduction

### Solution 1:  memoization, dfs, number theory, recursion

1. The key observation is that the number must be divisible the the prime integers 2, 3, 5, and 7.  Because if it is divisible by 11, that can't work cause 11 is not a digit, it ust be a digit so less than 10.

```cpp
const int INF = 1e18;
int N, ans;
const vector<int> PRIMES = {2, 3, 5, 7}, THRESHOLDS = {500000000000000000LL, 333333333333333333LL, 200000000000000000LL, 142857142857142857LL};
map<int, bool> memo;

vector<bool> digitsInNumber(int num) {
    vector<bool> digits(10, false);
    while (num > 0) {
        int digit = num % 10;
        digits[digit] = true;
        num /= 10;
    }
    return digits;
}

bool isValid(int x) {
    if (memo.count(x)) return memo[x];
    if (x == 1) return true;
    vector<bool> digits = digitsInNumber(x);
    for (int i = 2; i < 10; i++) {
        if (!digits[i] || x % i) continue;
        if (isValid(x / i)) return memo[x] = true;
    }
    return memo[x] = false;
}

void dfs(int p, int prod) {
    if (prod > N) return;
    if (p == 4) {
        if (prod <= N && isValid(prod)) ans++;
        return;
    }
    for (int i = 0; i < 64; i++) {
        int cur = prod;
        bool isGood = true;
        for (int j = 0; j < i; j++) {
            if (cur > THRESHOLDS[p]) {
                isGood = false;
                break;
            }
            cur *= PRIMES[p];
        }
        if (!isGood) break;
        dfs(p + 1, cur);
    }
}

void solve() {
    cin >> N;
    ans = 0;
    dfs(0, 1);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Monster Fighting

### Solution 1:  multiset, greedy, backwards, binary search

```cpp
const int INF = 1e18;
int T, N;
multiset<int> powers[2];
vector<pair<int, int>> enemies;

int ceil(int x, int y) {
    return (x + y - 1) / y;
}

void solve() {
    cin >> N;
    powers[0].clear();
    powers[1].clear();
    for (int i = 0; i < N; i++) {
        int p, s;
        cin >> p >> s;
        powers[s].insert(p);
    }
    enemies.clear();
    for (int i = 0; i < N; i++) {
        int q, s;
        cin >> q >> s;
        enemies.emplace_back(q, s);
    }
    sort(enemies.rbegin(), enemies.rend());
    for (const auto &[q, t] : enemies) {
        auto itDiff = powers[t ^ 1].lower_bound(q);
        auto itSame = powers[t].lower_bound(ceil(q, 2));
        vector<int> cands(2, INF);
        if (itDiff != powers[t ^ 1].end()) {
            cands[t ^ 1] = *itDiff;
        }
        if (itSame != powers[t].end()) {
            cands[t] = *itSame;
        }
        if (cands[t] == INF && cands[t ^ 1] == INF) {
            cout << "NO" << endl;
            return;
        }
        if (cands[t] <= cands[t ^ 1]) {
            powers[t].erase(itSame);
        } else {
            powers[t ^ 1].erase(itDiff);
        }
    }
    cout << "YES" << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Drawing Lines

### Solution 1:  2SAT, SCC, Tarjan's algorithm

1. Draw out the 4 spatial relationships between LR and UD points, and consider the disjunction that is necessary, you require that they don't intersect which is only if specific combo of both have same boolean value
1. Can then derive the implication graph and set it up for 2SAT problem.

```cpp
struct Point {
    int x, y;
    string tp;
    Point() {}
    Point(int x, int y, string tp) : x(x), y(y), tp(tp) {}
};

int N, M, timer, scc_count;
vector<vector<int>> adj;
vector<int> disc, low, comp;
vector<Point> points;
stack<int> stk;
vector<bool> on_stack;

void dfs(int u) {
    disc[u] = low[u] = ++timer;
    stk.push(u);
    on_stack[u] = true;
    for (int v : adj[u]) {
        if (!disc[v]) dfs(v);
        if (on_stack[v]) low[u] = min(low[u], low[v]);
    }
    if (disc[u] == low[u]) { // found scc
        scc_count++;
        while (!stk.empty()) {
            int v = stk.top();
            stk.pop();
            on_stack[v] = false;
            low[v] = low[u];
            comp[v] = scc_count;
            if (v == u) break;
        }
    }
}

void solve() {
    cin >> N;
    points.clear();
    for (int i = 0; i < N; i++) {
        int x, y;
        string dir;
        cin >> x >> y >> dir;
        points.emplace_back(x, y, dir);
    }
    sort(points.begin(), points.end(), [](const Point &a, const Point &b) {
        return a.tp < b.tp;
    });
    adj.assign(2 * N, vector<int>());
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            if (points[i].tp == points[j].tp) continue;
            if (points[i].x > points[j].x && points[i].y > points[j].y) {
                adj[i + N].emplace_back(j + N);
                adj[j].emplace_back(i);
            } else if (points[i].x > points[j].x && points[i].y < points[j].y) {
                adj[i + N].emplace_back(j);
                adj[j + N].emplace_back(i);
            } else if (points[i].x < points[j].x && points[i].y > points[j].y) {
                adj[i].emplace_back(j + N);
                adj[j].emplace_back(i + N);
            } else if (points[i].x < points[j].x && points[i].y < points[j].y) {
                adj[i].emplace_back(j);
                adj[j + N].emplace_back(i + N);
            }
        }
    }
    disc.assign(2 * N, 0);
    low.assign(2 * N, 0);
    comp.assign(2 * N, -1);
    on_stack.assign(2 * N, false);
    scc_count = -1;
    timer = 0;
    for (int i = 0; i < 2 * N; i++) {
        if (!disc[i]) dfs(i);
    }
    for (int i = 0; i < N; i++) {
        if (comp[i] == comp[i + N]) {
            cout << "NO" << endl;
            cout << 0 << endl;
            return;
        }
    }
    cout << "YES" << endl;
    cout << 1 << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# M(IT)^2 2025 Winter Contest Advanced Round Two

## Toy Marbles

### Solution 1:  functional graph, dfs, cycle detection, transpose graph

```cpp
struct Operation {
    int tp, u, v;
    Operation() {}
    Operation(int tp, int u, int v) : tp(tp), u(u), v(v) {}
};

int N;
vector<int> out, sources, colors;
vector<Operation> ans;
vector<bool> vis, inCycle;
vector<vector<int>> tadj;

void search(int u) {
    map<int, int> par;
    par[u] = -1;
    bool isCycle = false;
    while (!vis[u]) {
        vis[u] = true;
        int v = out[u];
        if (par.count(v)) {
            isCycle = true;
            break;
        }
        if (vis[v]) break;
        par[v] = u;
        u = v;
    }
    if (isCycle) {
        int critPoint = par[out[u]];
        vector<int> cycle;
        while (u != critPoint) {
            cycle.emplace_back(u);
            inCycle[u] = true;
            sources.emplace_back(u);
            u = par[u];
        }
        for (int i = 1; i < cycle.size(); i++) {
            swap(colors[cycle[i - 1]], colors[cycle[i]]);
            ans.emplace_back(1, cycle[i - 1], cycle[i]);
        }
    }
}

void dfs(int u, int p = -1) {
    if (!inCycle[u]) ans.emplace_back(2, out[u], u);
    for (int v : tadj[u]) {
        if (v == p) continue;
        if (inCycle[v]) continue;
        dfs(v, u);
    }
}

void solve() {
    cin >> N;
    colors.assign(N, 0);
    out.assign(N, 0);
    tadj.assign(N, vector<int>());
    for (int i = 0; i < N; i++) {
        cin >> colors[i];
        colors[i]--;
        out[i] = colors[i];
        tadj[colors[i]].emplace_back(i);
    }
    vis.assign(N, false);
    inCycle.assign(N, false);
    for (int i = 0; i < N; i++) {
        if (vis[i]) continue;
        search(i);
    }
    for (int u : sources) {
        dfs(u);
    }
    cout << ans.size() << endl;
    for (Operation op : ans) {
        cout << op.tp << " " << op.u + 1 << " " << op.v + 1 << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Snakes on a Grid

### Solution 1:  

```cpp
int R, C, Q;
int R1, C1, R2, C2;
vector<vector<int>> grid;
vector<vector<bool>> vis;

bool in_bounds(int i, int j) {
    return i >= R1 && i <= R2 && j >= C1 && j <= C2;
}

bool dfs(int i, int j, int k, string path) {
    char c = path[k];
    bool res = true;
    if (c == 'R') {
        if (in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) res &= false;; // left
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) res &= false; // down
        if (in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) {
            res &= dfs(i, j + 1, k ^ 1, path);
        }
    } else if (c == 'L') {
        if (in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) res &= false; // right
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) res &= false; // down
        if (in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) {
            res &= dfs(i, j - 1, k ^ 1, path);
        }
    } else if (c == 'D') {
        if (in_bounds(i - 1, j) && grid[i][j] == grid[i - 1][j]) res &= false; // up
        if (path[0] == 'R' && in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) res &= false; // right
        if (path[0] == 'L' && in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) res &= false; // left
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) {
            res &= dfs(i + 1, j, k ^ 1, path);
        }
    }
    return res;
}

void floodFill(int i, int j) {
    if (i < R1 || i > R2 || j < C1 || j > C2) return;
    if (vis[i][j]) return;
    vis[i][j] = true;
    if (i - 1 >= R1 && grid[i][j] == grid[i - 1][j]) floodFill(i - 1, j);
    if (i + 1 <= R2 && grid[i][j] == grid[i + 1][j]) floodFill(i + 1, j);
    if (j - 1 >= C1 && grid[i][j] == grid[i][j - 1]) floodFill(i, j - 1);
    if (j + 1 <= C2 && grid[i][j] == grid[i][j + 1]) floodFill(i, j + 1);
}

void solve() {
    cin >> R >> C;
    grid.assign(R, vector<int>(C, 0));
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            cin >> grid[i][j];
        }
    }
    vis.assign(R, vector<bool>(C, false));
    cin >> Q;
    while (Q--) {
        int r1, c1, r2, c2;
        cin >> r1 >> c1 >> r2 >> c2;
        R1 = r1, C1 = c1, R2 = r2, C2 = c2;
        int ans = 0;
        bool isGood = true;
        for (int i = r1; i <= r2; i++) {
            for (int j = c1; j <= c2; j++) {
                if (vis[i][j]) continue;
                if (j + 1 <= c2 && grid[i][j] == grid[i][j + 1]) continue;
                if (!dfs(i, j, 0, "RD") && !dfs(i, j, 1, "RD") && !dfs(i, j, 0, "LD") && !dfs(i, j, 1, "LD")) {
                    isGood = false;
                }
                floodFill(i, j);
            }
        }
        for (int i = r1; i <= r2; i++) {
            for (int j = c1; j <= c2; j++) {
                vis[i][j] = false;
            }
        }
        if (isGood) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}

```

## MIT Tour

### Solution 1:  

```cpp

```

# M(IT)^2 2025 Spring Invitationals Qualification Round 1

## Kites

### Solution 1: sorting, prefix min

```cpp
const int INF = 1e9;
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    sort(A.begin(), A.end());
    int delta1 = INF, delta2 = INF, ans = INF;
    for (int i = 1; i < N; i++) {
        int delta = A[i] - A[i - 1];
        ans = min(ans, delta + delta1);
        delta1 = min(delta1, delta2);
        delta2 = delta;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Feeding Beavers

### Solution 1: greedy, deque

1. Greedily take smallest pair that satisfies the condition of even or odd. 

```cpp
const int INF = 1e9;
int N;
string S;

void solve() {
    cin >> N >> S;
    deque<int> dq;
    for (int i = 1; i <= 2 * N; i++) {
        dq.emplace_back(i);
    }
    vector<pair<int, int>> ans;
    for (char ch : S) {
        bool found = false;
        if (ch == 'O') {
            vector<int> tmp;
            int x = dq.front();
            dq.pop_front();
            while (!dq.empty()) {
                int y = dq.front();
                dq.pop_front();
                if ((x + y) & 1) {
                    ans.emplace_back(x, y);
                    found = true;
                    break;
                }
                tmp.emplace_back(y);
            }
            for (int y : tmp) {
                dq.emplace_front(y);
            }
        } else {
            vector<int> tmp;
            int x = dq.front();
            dq.pop_front();
            while (!dq.empty()) {
                int y = dq.front();
                dq.pop_front();
                if ((x + y) % 2 == 0) {
                    ans.emplace_back(x, y);
                    found = true;
                    break;
                }
                tmp.emplace_back(y);
            }
            for (int y : tmp) {
                dq.emplace_front(y);
            }
        }
        if (!found) {
            cout << "NO" << endl;
            return;
        }
    }
    cout << "YES" << endl;
    for (auto [x, y] : ans) {
        cout << x << " " << y << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Beaverland

### Solution 1: greedy, bfs

1. since it is strictly increasing order, just make the first one be distance = 1, 2, 3, 4 and so on if the first node is not 1, if it is 1 just 0, 1, 2, 3 instead

```cpp
int N, M, K;
vector<int> A;
vector<vector<int>> adj;

vector<int> bfs() {
    vector<int> dist(N, -1);
    deque<int> dq;
    dq.emplace_back(0);
    dist[0] = 0;
    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                dq.emplace_back(v);
            }
        }
    }
    return dist;
}

void solve() {
    cin >> N >> M >> K;
    A.assign(K, 0);
    adj.assign(N, vector<int>());
    for (int i = 0; i < K; i++) {
        cin >> A[i];
        A[i]--;
    }
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    vector<pair<int, int>> ans;
    if (A[0] != 0) {
        ans.emplace_back(0, A[0]);
        adj[0].emplace_back(A[0]);
        adj[A[0]].emplace_back(0);
    }
    for (int i = 1; i < K; i++) {
        ans.emplace_back(A[i - 1], A[i]);
        adj[A[i - 1]].emplace_back(A[i]);
        adj[A[i]].emplace_back(A[i - 1]);
    }
    vector<int> dist = bfs();
    for (int i = 1; i < K; i++) {
        if (dist[A[i]] <= dist[A[i - 1]]) {
            cout << -1 << endl;
            return;
        }
    }
    cout << ans.size() << endl;
    for (auto [x, y] : ans) {
        cout << x + 1 << " " << y + 1 << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# M(IT)^2 2025 Winter

##

### Solution 1: 

```cpp

```