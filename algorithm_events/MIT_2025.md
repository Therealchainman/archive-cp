# MIT 2025

# M(IT)^2 2025 Winter Contest Advanced Round One

## Number Reduction

### Solution 1:  memoization, dfs, number theory, recursion

1. The key observation is that the number must be divisible the the prime integers 2, 3, 5, and 7.  Because if it is divisible by 11, that can't work cause 11 is not a digit, it ust be a digit so less than 10.

```cpp
const int INF = 1e18;
int N, ans;
const vector<int> PRIMES = {2, 3, 5, 7}, THRESHOLDS = {500000000000000000LL, 333333333333333333LL, 200000000000000000LL, 142857142857142857LL};
map<int, bool> memo;

vector<bool> digitsInNumber(int num) {
    vector<bool> digits(10, false);
    while (num > 0) {
        int digit = num % 10;
        digits[digit] = true;
        num /= 10;
    }
    return digits;
}

bool isValid(int x) {
    if (memo.count(x)) return memo[x];
    if (x == 1) return true;
    vector<bool> digits = digitsInNumber(x);
    for (int i = 2; i < 10; i++) {
        if (!digits[i] || x % i) continue;
        if (isValid(x / i)) return memo[x] = true;
    }
    return memo[x] = false;
}

void dfs(int p, int prod) {
    if (prod > N) return;
    if (p == 4) {
        if (prod <= N && isValid(prod)) ans++;
        return;
    }
    for (int i = 0; i < 64; i++) {
        int cur = prod;
        bool isGood = true;
        for (int j = 0; j < i; j++) {
            if (cur > THRESHOLDS[p]) {
                isGood = false;
                break;
            }
            cur *= PRIMES[p];
        }
        if (!isGood) break;
        dfs(p + 1, cur);
    }
}

void solve() {
    cin >> N;
    ans = 0;
    dfs(0, 1);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Monster Fighting

### Solution 1:  multiset, greedy, backwards, binary search

```cpp
const int INF = 1e18;
int T, N;
multiset<int> powers[2];
vector<pair<int, int>> enemies;

int ceil(int x, int y) {
    return (x + y - 1) / y;
}

void solve() {
    cin >> N;
    powers[0].clear();
    powers[1].clear();
    for (int i = 0; i < N; i++) {
        int p, s;
        cin >> p >> s;
        powers[s].insert(p);
    }
    enemies.clear();
    for (int i = 0; i < N; i++) {
        int q, s;
        cin >> q >> s;
        enemies.emplace_back(q, s);
    }
    sort(enemies.rbegin(), enemies.rend());
    for (const auto &[q, t] : enemies) {
        auto itDiff = powers[t ^ 1].lower_bound(q);
        auto itSame = powers[t].lower_bound(ceil(q, 2));
        vector<int> cands(2, INF);
        if (itDiff != powers[t ^ 1].end()) {
            cands[t ^ 1] = *itDiff;
        }
        if (itSame != powers[t].end()) {
            cands[t] = *itSame;
        }
        if (cands[t] == INF && cands[t ^ 1] == INF) {
            cout << "NO" << endl;
            return;
        }
        if (cands[t] <= cands[t ^ 1]) {
            powers[t].erase(itSame);
        } else {
            powers[t ^ 1].erase(itDiff);
        }
    }
    cout << "YES" << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Drawing Lines

### Solution 1:  2SAT, SCC, Tarjan's algorithm

1. Draw out the 4 spatial relationships between LR and UD points, and consider the disjunction that is necessary, you require that they don't intersect which is only if specific combo of both have same boolean value
1. Can then derive the implication graph and set it up for 2SAT problem.

```cpp
struct Point {
    int x, y;
    string tp;
    Point() {}
    Point(int x, int y, string tp) : x(x), y(y), tp(tp) {}
};

int N, M, timer, scc_count;
vector<vector<int>> adj;
vector<int> disc, low, comp;
vector<Point> points;
stack<int> stk;
vector<bool> on_stack;

void dfs(int u) {
    disc[u] = low[u] = ++timer;
    stk.push(u);
    on_stack[u] = true;
    for (int v : adj[u]) {
        if (!disc[v]) dfs(v);
        if (on_stack[v]) low[u] = min(low[u], low[v]);
    }
    if (disc[u] == low[u]) { // found scc
        scc_count++;
        while (!stk.empty()) {
            int v = stk.top();
            stk.pop();
            on_stack[v] = false;
            low[v] = low[u];
            comp[v] = scc_count;
            if (v == u) break;
        }
    }
}

void solve() {
    cin >> N;
    points.clear();
    for (int i = 0; i < N; i++) {
        int x, y;
        string dir;
        cin >> x >> y >> dir;
        points.emplace_back(x, y, dir);
    }
    sort(points.begin(), points.end(), [](const Point &a, const Point &b) {
        return a.tp < b.tp;
    });
    adj.assign(2 * N, vector<int>());
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            if (points[i].tp == points[j].tp) continue;
            if (points[i].x > points[j].x && points[i].y > points[j].y) {
                adj[i + N].emplace_back(j + N);
                adj[j].emplace_back(i);
            } else if (points[i].x > points[j].x && points[i].y < points[j].y) {
                adj[i + N].emplace_back(j);
                adj[j + N].emplace_back(i);
            } else if (points[i].x < points[j].x && points[i].y > points[j].y) {
                adj[i].emplace_back(j + N);
                adj[j].emplace_back(i + N);
            } else if (points[i].x < points[j].x && points[i].y < points[j].y) {
                adj[i].emplace_back(j);
                adj[j + N].emplace_back(i + N);
            }
        }
    }
    disc.assign(2 * N, 0);
    low.assign(2 * N, 0);
    comp.assign(2 * N, -1);
    on_stack.assign(2 * N, false);
    scc_count = -1;
    timer = 0;
    for (int i = 0; i < 2 * N; i++) {
        if (!disc[i]) dfs(i);
    }
    for (int i = 0; i < N; i++) {
        if (comp[i] == comp[i + N]) {
            cout << "NO" << endl;
            cout << 0 << endl;
            return;
        }
    }
    cout << "YES" << endl;
    cout << 1 << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# M(IT)^2 2025 Winter Contest Advanced Round Two

## Toy Marbles

### Solution 1:  functional graph, dfs, cycle detection, transpose graph

```cpp
struct Operation {
    int tp, u, v;
    Operation() {}
    Operation(int tp, int u, int v) : tp(tp), u(u), v(v) {}
};

int N;
vector<int> out, sources, colors;
vector<Operation> ans;
vector<bool> vis, inCycle;
vector<vector<int>> tadj;

void search(int u) {
    map<int, int> par;
    par[u] = -1;
    bool isCycle = false;
    while (!vis[u]) {
        vis[u] = true;
        int v = out[u];
        if (par.count(v)) {
            isCycle = true;
            break;
        }
        if (vis[v]) break;
        par[v] = u;
        u = v;
    }
    if (isCycle) {
        int critPoint = par[out[u]];
        vector<int> cycle;
        while (u != critPoint) {
            cycle.emplace_back(u);
            inCycle[u] = true;
            sources.emplace_back(u);
            u = par[u];
        }
        for (int i = 1; i < cycle.size(); i++) {
            swap(colors[cycle[i - 1]], colors[cycle[i]]);
            ans.emplace_back(1, cycle[i - 1], cycle[i]);
        }
    }
}

void dfs(int u, int p = -1) {
    if (!inCycle[u]) ans.emplace_back(2, out[u], u);
    for (int v : tadj[u]) {
        if (v == p) continue;
        if (inCycle[v]) continue;
        dfs(v, u);
    }
}

void solve() {
    cin >> N;
    colors.assign(N, 0);
    out.assign(N, 0);
    tadj.assign(N, vector<int>());
    for (int i = 0; i < N; i++) {
        cin >> colors[i];
        colors[i]--;
        out[i] = colors[i];
        tadj[colors[i]].emplace_back(i);
    }
    vis.assign(N, false);
    inCycle.assign(N, false);
    for (int i = 0; i < N; i++) {
        if (vis[i]) continue;
        search(i);
    }
    for (int u : sources) {
        dfs(u);
    }
    cout << ans.size() << endl;
    for (Operation op : ans) {
        cout << op.tp << " " << op.u + 1 << " " << op.v + 1 << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Snakes on a Grid

### Solution 1:  

```cpp
int R, C, Q;
int R1, C1, R2, C2;
vector<vector<int>> grid;
vector<vector<bool>> vis;

bool in_bounds(int i, int j) {
    return i >= R1 && i <= R2 && j >= C1 && j <= C2;
}

bool dfs(int i, int j, int k, string path) {
    char c = path[k];
    bool res = true;
    if (c == 'R') {
        if (in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) res &= false;; // left
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) res &= false; // down
        if (in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) {
            res &= dfs(i, j + 1, k ^ 1, path);
        }
    } else if (c == 'L') {
        if (in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) res &= false; // right
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) res &= false; // down
        if (in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) {
            res &= dfs(i, j - 1, k ^ 1, path);
        }
    } else if (c == 'D') {
        if (in_bounds(i - 1, j) && grid[i][j] == grid[i - 1][j]) res &= false; // up
        if (path[0] == 'R' && in_bounds(i, j + 1) && grid[i][j] == grid[i][j + 1]) res &= false; // right
        if (path[0] == 'L' && in_bounds(i, j - 1) && grid[i][j] == grid[i][j - 1]) res &= false; // left
        if (in_bounds(i + 1, j) && grid[i][j] == grid[i + 1][j]) {
            res &= dfs(i + 1, j, k ^ 1, path);
        }
    }
    return res;
}

void floodFill(int i, int j) {
    if (i < R1 || i > R2 || j < C1 || j > C2) return;
    if (vis[i][j]) return;
    vis[i][j] = true;
    if (i - 1 >= R1 && grid[i][j] == grid[i - 1][j]) floodFill(i - 1, j);
    if (i + 1 <= R2 && grid[i][j] == grid[i + 1][j]) floodFill(i + 1, j);
    if (j - 1 >= C1 && grid[i][j] == grid[i][j - 1]) floodFill(i, j - 1);
    if (j + 1 <= C2 && grid[i][j] == grid[i][j + 1]) floodFill(i, j + 1);
}

void solve() {
    cin >> R >> C;
    grid.assign(R, vector<int>(C, 0));
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            cin >> grid[i][j];
        }
    }
    vis.assign(R, vector<bool>(C, false));
    cin >> Q;
    while (Q--) {
        int r1, c1, r2, c2;
        cin >> r1 >> c1 >> r2 >> c2;
        R1 = r1, C1 = c1, R2 = r2, C2 = c2;
        int ans = 0;
        bool isGood = true;
        for (int i = r1; i <= r2; i++) {
            for (int j = c1; j <= c2; j++) {
                if (vis[i][j]) continue;
                if (j + 1 <= c2 && grid[i][j] == grid[i][j + 1]) continue;
                if (!dfs(i, j, 0, "RD") && !dfs(i, j, 1, "RD") && !dfs(i, j, 0, "LD") && !dfs(i, j, 1, "LD")) {
                    isGood = false;
                }
                floodFill(i, j);
            }
        }
        for (int i = r1; i <= r2; i++) {
            for (int j = c1; j <= c2; j++) {
                vis[i][j] = false;
            }
        }
        if (isGood) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}

```

## MIT Tour

### Solution 1:  

```cpp

```

# M(IT)^2 2025 Spring Invitationals Qualification Round 1

## Kites

### Solution 1: sorting, prefix min

```cpp
const int INF = 1e9;
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    sort(A.begin(), A.end());
    int delta1 = INF, delta2 = INF, ans = INF;
    for (int i = 1; i < N; i++) {
        int delta = A[i] - A[i - 1];
        ans = min(ans, delta + delta1);
        delta1 = min(delta1, delta2);
        delta2 = delta;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Feeding Beavers

### Solution 1: greedy, deque

1. Greedily take smallest pair that satisfies the condition of even or odd. 

```cpp
const int INF = 1e9;
int N;
string S;

void solve() {
    cin >> N >> S;
    deque<int> dq;
    for (int i = 1; i <= 2 * N; i++) {
        dq.emplace_back(i);
    }
    vector<pair<int, int>> ans;
    for (char ch : S) {
        bool found = false;
        if (ch == 'O') {
            vector<int> tmp;
            int x = dq.front();
            dq.pop_front();
            while (!dq.empty()) {
                int y = dq.front();
                dq.pop_front();
                if ((x + y) & 1) {
                    ans.emplace_back(x, y);
                    found = true;
                    break;
                }
                tmp.emplace_back(y);
            }
            for (int y : tmp) {
                dq.emplace_front(y);
            }
        } else {
            vector<int> tmp;
            int x = dq.front();
            dq.pop_front();
            while (!dq.empty()) {
                int y = dq.front();
                dq.pop_front();
                if ((x + y) % 2 == 0) {
                    ans.emplace_back(x, y);
                    found = true;
                    break;
                }
                tmp.emplace_back(y);
            }
            for (int y : tmp) {
                dq.emplace_front(y);
            }
        }
        if (!found) {
            cout << "NO" << endl;
            return;
        }
    }
    cout << "YES" << endl;
    for (auto [x, y] : ans) {
        cout << x << " " << y << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Beaverland

### Solution 1: greedy, bfs

1. since it is strictly increasing order, just make the first one be distance = 1, 2, 3, 4 and so on if the first node is not 1, if it is 1 just 0, 1, 2, 3 instead

```cpp
int N, M, K;
vector<int> A;
vector<vector<int>> adj;

vector<int> bfs() {
    vector<int> dist(N, -1);
    deque<int> dq;
    dq.emplace_back(0);
    dist[0] = 0;
    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                dq.emplace_back(v);
            }
        }
    }
    return dist;
}

void solve() {
    cin >> N >> M >> K;
    A.assign(K, 0);
    adj.assign(N, vector<int>());
    for (int i = 0; i < K; i++) {
        cin >> A[i];
        A[i]--;
    }
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    vector<pair<int, int>> ans;
    if (A[0] != 0) {
        ans.emplace_back(0, A[0]);
        adj[0].emplace_back(A[0]);
        adj[A[0]].emplace_back(0);
    }
    for (int i = 1; i < K; i++) {
        ans.emplace_back(A[i - 1], A[i]);
        adj[A[i - 1]].emplace_back(A[i]);
        adj[A[i]].emplace_back(A[i - 1]);
    }
    vector<int> dist = bfs();
    for (int i = 1; i < K; i++) {
        if (dist[A[i]] <= dist[A[i - 1]]) {
            cout << -1 << endl;
            return;
        }
    }
    cout << ans.size() << endl;
    for (auto [x, y] : ans) {
        cout << x + 1 << " " << y + 1 << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# M(IT)^2 Winter 25-26 Advanced Individual Round (Open Division)

## Snakey Beaver

### Solution 1: 

1. 

```cpp

```

## Quantum Beaver

### Solution 1: 

```cpp

```

## Ditto Piano

### Solution 1: lazy segment tree, maximum range queries, assign range updates

1. solves M = 0

```cpp
const int64 INF = numeric_limits<int64>::max();
const int NOOP = -1;

struct LazySegmentTree {
    vector<int64> arr;
    vector<int64> lazyTag;
    int size;

    struct Configuration {
        const int64 neutral; // identity element for merge
        const int noop; // identity element for lazy
        function<int64(int64, int64)> merge; // combine two children
        function<int64(int64, int64, int)> apply; // apply lazy tag to node value over length
        function<int64(int64, int64)> compose; // merge two lazy tags
    } config;

    LazySegmentTree(int n, Configuration config) : config(config) { init(n); }

    void init(int n) {
        size = 1;
        while (size < n) size *= 2;
        arr.assign(2 * size, config.neutral);
        lazyTag.assign(2 * size, config.noop);
    }

    void build(const vector<int64>& inputArr) {
        copy(inputArr.begin(), inputArr.end(), arr.begin() + (size - 1));
        for (int i = size - 2; i >= 0; --i) {
            arr[i] = config.merge(arr[2 * i + 1], arr[2 * i + 2]);
        }
    }

    bool is_leaf(int segment_right_bound, int segment_left_bound) {
        return segment_right_bound - segment_left_bound == 1;
    }

    void push(int segment_idx, int segment_left_bound, int segment_right_bound) {
        bool pendingUpdate = lazyTag[segment_idx] != config.noop;
        if (is_leaf(segment_right_bound, segment_left_bound) || !pendingUpdate) return;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        int children_segment_len = (segment_right_bound - segment_left_bound) >> 1;
        lazyTag[left_segment_idx] = config.compose(lazyTag[left_segment_idx], lazyTag[segment_idx]);
        lazyTag[right_segment_idx] = config.compose(lazyTag[right_segment_idx], lazyTag[segment_idx]);
        arr[left_segment_idx] = config.apply(arr[left_segment_idx], lazyTag[segment_idx], children_segment_len);
        arr[right_segment_idx] = config.apply(arr[right_segment_idx], lazyTag[segment_idx], children_segment_len);
        lazyTag[segment_idx] = config.noop;
    }

    void update(int left, int right, int64 val) {
        update(0, 0, size, left, right, val);
    }

    void update(int segment_idx, int segment_left_bound, int segment_right_bound, int left, int right, int64 val) {
        // NO OVERLAP
        if (right <= segment_left_bound || segment_right_bound <= left) return;
        // COMPLETE OVERLAP
        if (left <= segment_left_bound && segment_right_bound <= right) {
            lazyTag[segment_idx] = config.compose(lazyTag[segment_idx], val);
            int segment_len = segment_right_bound - segment_left_bound;
            arr[segment_idx] = config.apply(arr[segment_idx], val, segment_len);
            return;
        }
        // PARTIAL OVERLAP;
        push(segment_idx, segment_left_bound, segment_right_bound);
        int mid_point = (segment_left_bound + segment_right_bound) >> 1;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        update(left_segment_idx, segment_left_bound, mid_point, left, right, val);
        update(right_segment_idx, mid_point, segment_right_bound, left, right, val);
        // pull
        arr[segment_idx] = config.merge(arr[left_segment_idx], arr[right_segment_idx]);
    }

    int64 range_query(int left, int right) {
        return range_query(0, 0, size, left, right);
    }

    int64 range_query(int segment_idx, int segment_left_bound, int segment_right_bound, int left, int right) {
        // NO OVERLAP
        if (right <= segment_left_bound || segment_right_bound <= left) return config.neutral;
        // COMPLETE OVERLAP
        if (left <= segment_left_bound && segment_right_bound <= right) {
            return arr[segment_idx];
        }
        // PARTIAL OVERLAP
        push(segment_idx, segment_left_bound, segment_right_bound);
        int mid_point = (segment_left_bound + segment_right_bound) >> 1;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        int64 left_res = range_query(left_segment_idx, segment_left_bound, mid_point, left, right);
        int64 right_res = range_query(right_segment_idx, mid_point, segment_right_bound, left, right);
        return config.merge(left_res, right_res);
    }

    int64 point_query(int i) { 
        return point_query(0, 0, size, i); 
    }

    int64 point_query(int segment_idx, int l, int r, int i) {
        if (r - l == 1) return arr[segment_idx];
        push(segment_idx, l, r);// make children up to date
        int m = (l + r) >> 1;
        if (i < m) {
            return point_query(2 * segment_idx + 1, l, m, i);
        }
        return point_query(2 * segment_idx + 2, m, r, i);
    }

    // maxRight: largest r in [l, limit) such that pred(range_query(l, r)) is true.
    // If limit < 0 it defaults to the whole array size.
    // Precondition: pred(neutral) == true.
    template<class Pred>
    int maxRight(int l, Pred pred, int limit = -1) {
        if (limit < 0 || limit > size) limit = size;
        l = max(0, min(l, limit));
        // must hold on identity
        if (!pred(config.neutral)) return l; // or throw logic_error("pred(neutral) must be true");
        int64 acc = config.neutral;
        return maxRightDfs(0, 0, size, l, limit, acc, pred);
    }
    template<class Pred>
    int maxRightDfs(int node, int nl, int nr, int ql, int limit, int64& acc, const Pred& pred) {
        // Node entirely left of ql, or entirely beyond the search limit
        if (nr <= ql || limit <= nl) return ql;

        // If we can take this whole node, do it greedily
        if (ql <= nl && nr <= limit) {
            int64 combined = config.merge(acc, arr[node]);
            if (pred(combined)) { // ok to take all of it
                acc = combined;
                return nr;
            }
        }


        // If we cannot take it whole and it is a leaf, we stop here
        if (nr - nl == 1) return nl;

        // Otherwise we must split
        push(node, nl, nr);
        int mid = (nl + nr) >> 1;
        int left_segment_idx = 2 * node + 1, right_segment_idx = 2 * node + 2;

        // Try to take as much as possible from the left child
        int res = maxRightDfs(left_segment_idx, nl, mid, ql, limit, acc, pred);

        if (res < min(mid, limit)) return res; // boundary found inside left child
        // Then continue into the right child
        return maxRightDfs(right_segment_idx, mid, nr, res, limit, acc, pred);
    }

    void point_set(int i, int64 newVal) {
        point_set(0, 0, size, i, newVal);
    }
    void point_set(int node, int nl, int nr, int i, int64 newVal) {
        if (nr - nl == 1) {
            arr[node] = newVal;
            lazyTag[node] = config.noop; // leaf carries no pending work
            return;
        }
        push(node, nl, nr);
        int m = (nl + nr) >> 1;
        if (i < m) point_set(2*node + 1, nl, m, i, newVal);
        else       point_set(2*node + 2, m, nr, i, newVal);
        arr[node] = config.merge(arr[2*node + 1], arr[2*node + 2]); // pull
    }
};

LazySegmentTree::Configuration assignMaxConfiguration{
    0, 
    NOOP,
    [](int64 x, int64 y) {
        return max(x, y);
    },
    [](int64 nodeVal, int64 assignVal, int len) {
        if (assignVal == NOOP) return nodeVal;
        return max(nodeVal, assignVal);
    },
    [](int64 oldTag, int64 newTag) {
        if (newTag == NOOP) return oldTag;
        if (oldTag == NOOP) return newTag;
        return max(oldTag, newTag);
    }
};

int N, M;
vector<tuple<int, int, int>> notes;

void solve() {
    cin >> N >> M;
    notes.clear();
    vector<int> coords;
    for (int i = 0; i < N; ++i) {
        int k, l, r;
        cin >> k >> l >> r;
        notes.emplace_back(k, l, r);
        coords.emplace_back(l);
        coords.emplace_back(r);
    }
    sort(notes.begin(), notes.end());
    sort(coords.begin(), coords.end());
    coords.erase(unique(coords.begin(), coords.end()), coords.end());
    LazySegmentTree seg(coords.size(), assignMaxConfiguration);
    for (const auto& [k, l, r] : notes) {
        int left = lower_bound(coords.begin(), coords.end(), l) - coords.begin();
        int right = lower_bound(coords.begin(), coords.end(), r) - coords.begin();
        int64 curMax = seg.range_query(left, right);
        seg.update(left, right, curMax + 1);
    }
    int64 ans = seg.range_query(0, coords.size());
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

### Solution 2: dynamic programming, DAG longest path

1. What about when M = 1, longest path after deleting one vertex
1. The problem with forming the DAG is that you can have O(N^2) edges. 
1. If you reduce the DAG though to only the notes that precede the current note, then you think about it for each note, it can only have 
1. 

```cpp

```

## Busy Beaver's Water Network

### Solution 1: dynamic programming, combinatorics, graph theory, number of connected labeled graphs, spanning trees, connected components. 

1. A connected graph G satisfies the condition iff there exists a vertex v that removing v leaves at least K connected components.

Algorithm:
1. Choosing the center vertex v
1. Partitioning the remaining 10 nodes into k components, where k∈{7,8,9,10}, if N = 11 and K = 7.
1. For each partition, calculating the number of ways to form the components and connect them to v

1. The minimum possible degree of a vertex v in a spanning tree is the number of connected components in the graph after deleting v.
1. The total number of labeled graphs with N vertices is $2^{\binom{N}{2}}$.  Have either an edge or not between each pair of vertices.

Given a connected component C of size i and a pivot node u (which is not included in the C):
1. Calculate the number of labeled connected graphs of size i, and call that $c_i$. 
1. The number of ways to connect u to at least one node in C is $2^i - 1$ (all possible subsets of nodes in C except the empty set).
1. The total number of ways to form the component C and connect it to u is then $f_i = c_i * (2^i - 1)$.

iterate over the number of connected components
then iterate over the size of connected component
dp[n][k] = number of ways to partition n nodes into k connected components such that each component is connected to the pivot node.
so when you take a size dp[n][k] = dp[n-i][k-1]


Let's understand the dynamic programming approach to this problem:
given dp(n, k) = number of graphs on these n non-pivot nodes plus the pivot u  after removing u and its insuch that G - u (the graphcident edges) has exactly k connected components.
1. You look at n nodes and partition them into k connected components.
1. For each component of size s, you also count all the ways it can be connected to u by a non-empty subset of its nodes.
1. All that is wrapped into dp(n, k)
There is a trick for labeled structures, where you pick the smallest label. 
And you say tha smallest label belongs to exactly one of the connected ompnents of G - u, call that C and its size is s.
then: 
1. C contains vertex 1, plus s - 1 other vertices from from the remaining n - 1 vertices. 
1. Inside C, the induced subgraph on those s vertices must be connected.
1. Edges from C to the pivot u must form a non-empty subset of possible dges.
1. The remaining n - s vertices must be partitioned into k - 1 connected components.

Start with n = 1, and increase this so consider when you have n non-pivote nodes.
Then you loop over taking 1 to n nodes to form a connected component C containing the smallest labeled vertex.
Then you loop over if this is the kth connected component and add it to the previous answer. 
The transitions is dp[n][k] += dp[n - s][k - 1] * f_s * C(n - 1, s - 1)
Then find answer for anything above K connected components with N - 1 non-pivote nodes
Then multiple by N to consider for each pivot node. 

What does is the combinatorial calculation f_s
Given a component of size s, there are c_s connected graphs on s labeled vertices.
Then there are 2^s - 1 ways to connect the pivot node u to at least one vertex in this component.

Let's go over how to calculate c_s though. 
1. g[n] = total number of graphs on n labeled vertices = 2^(n choose 2)
1. The key to solve is to redefine g[n] in another way, classify each graph byt he size k of the connected component that contains vertex 1. 
1. class for graphs where the component of 1 has size k = 1
1. class for graphs where the component of 1 has size k = 2
...
1. class for graphs where the component of 1 has size k = n 

Every graph falls into exactly on such class. 
for a fixed k:
1. how many vertices join vertex 1 in its component. $\binom{n - 1}{k - 1}$ ways to choose the other k - 1 vertices.
1. Then the induced subgraph on these k vertices must be connected, so there are c_k ways to do that.
1. Then the remaining n - k vertices can form any graph, so there are g[n - k] ways to do that.
1. multiple these three factors $\binom{n - 1}{k - 1} * c_k * g[n - k]$
1. Then summing over k from 1 to n gives: $g[n] = \sum_{k=1}^{n} \binom{n - 1}{k - 1} * c_k * g[n - k]$
1. This is a new way to compute g[n] in terms of smaller values of g and the unknowns c_k.
1. Then if you realize that when k = n, you get c_n * g[0] = c_n * 1 = c_n, you can rearrange to solve for c_n:

```cpp
const int MOD = 998244353, MAXN = 5005;
int N, K;

int64 inv(int i, int64 m) {
  return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

vector<int64> fact, inv_fact;

void factorials(int n, int64 m) {
    fact.assign(n + 1, 1);
    inv_fact.assign(n + 1, 0);
    for (int i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % m;
    }
    inv_fact.end()[-1] = inv(fact.end()[-1], m);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
    }
}

int64 choose(int n, int r, int64 m) {
    if (n < r) return 0;
    return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
}

void solve() {
    cin >> N >> K;
    int M = N - 1;
    // calculate c[s] = number of connected labeled graphs with s nodes
    vector<int64> pow2(M + 1, 1);
    for (int i = 1; i <= M; ++i) {
        pow2[i] = 2LL * pow2[i - 1] % MOD;
    }
    vector<int64> c(M + 1, 0), g(M + 1, 0);
    g[0] = 1;
    for (int s = 1; s <= M; ++s) {
        g[s] = g[s - 1] * pow2[s - 1] % MOD;
    }
    c[1] = 1; // 1 vertex, one way to be connected
    for (int s = 2; s <= M; ++s) {
        int64 total = g[s];
        // subtracting from the total
        for (int k = 1; k < s; ++k) {
            int64 term1 = choose(s - 1, k - 1, MOD) * c[k] % MOD;
            int64 term2 = term1 * g[s - k] % MOD;
            total -= term2;
            if (total < 0) total += MOD;
        }
        c[s] = total;
    }
    vector<int64> f(M + 1, 0);
    for (int s = 1; s <= M; ++s) {
        int64 term = pow2[s] - 1;
        if (term < 0) term += MOD;
        f[s] = c[s] * term % MOD;
    }
    vector<vector<int64>> dp(M + 1, vector<int64>(M + 1, 0));
    dp[0][0] = 1;
    for (int n = 1; n <= M; ++n) {
        for (int s = 1; s <= n; ++s) {
            int64 coef = choose(n - 1, s - 1, MOD) * f[s] % MOD;
            int maxK = n - s + 1;
            for (int k = 1; k <= maxK; ++k) {
                int64 term = dp[n - s][k - 1] * coef % MOD;
                dp[n][k] = (dp[n][k] + term) % MOD;
            }
        }
    }
    int64 ans = 0;
    for (int k = K; k <= M; ++k) {
        ans = (ans + dp[M][k]) % MOD;
    }
    ans = N * ans % MOD;
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    factorials(MAXN, MOD);
    solve();
    return 0;
}
```

### Solution 2: exponential generating functions, combinatorics, convolution

1. Define this exponential generating function (EGF): $E(x) = \sum_{n=0}^N f_n \frac{x^n}{n!}$. The coefficient $\frac{x^n}{n!}$ gives the number of structures on a labeled set of size n.
1. So I think you want to calculate the following $$N \cdot (N - 1)! \cdot [x^{N-1}] \sum_{k \geq K}^{N - 1} \cdot \frac{E(x)^k}{k!}$$
1. I can calculate this fast by using fast convolution algorithms to compute the powers of E(x) and summing the (N - 1)th coefficient.

1. remember how important big[0][0] = 1, which represents the identity sequence for convolution so the first sequence multiplied by it is equal to itself. 
1. Paterson-Stockeymer doesn't change how a single multiplication works; it's about how many times you need to multiply when evaluating a whole polynomial H(F).
1. $$S(x) = \sum_{k=K}^{N-1} \frac{E(x)^k}{k!}$$
1. $H(z) = \sum_{k=0}^{N - 1} \frac{z^k}{k!} = \sum_{k=0}^{N-1} h_k z^k$ and say S(x) = H(F(x))
1. $$H(z) = \sum_{q = 0}^{Q - 1} \sum_{r = 0}^{B - 1} h_{qB + r} z^{qB + r} = \sum_{q = 0}^{Q - 1} z^{qB} \left( \sum_{r = 0}^{B - 1} h_{qB + r} \cdot z^r \right)$$
1. $$H(z) = \sum_{q = 0}^{Q - 1} z^{qB} Q_q(z)$$
1. $$S(x) = \sum_{q = 0}^{Q - 1} E(x)^{qB} Q_q(E(x))$$
1. small and big, small powers $E^r$ encode all $0 \leq r \le B$ for inner polynomials $Q_q(E)$
1. And the exponent is $k = qB + r$ can be represented as small[r] * big[q] and $E^k = E^{qB + r} = E^r * E^{qB}$

```cpp
const int MOD = 998244353, MAXN = 5005;
int N, K;

int ceil(int x, int y) {
    return (x + y - 1) / y;
}

int64 inv(int i, int64 m) {
  return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

vector<int64> fact, inv_fact;

void factorials(int n, int64 m) {
    fact.assign(n + 1, 1);
    inv_fact.assign(n + 1, 0);
    for (int i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % m;
    }
    inv_fact.end()[-1] = inv(fact.end()[-1], m);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
    }
}

int64 choose(int n, int r, int64 m) {
    if (n < r) return 0;
    return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
}

namespace NTT{
    const int P = 998244353, R = 3, IR = (P + 1) / 3;

    int L, N, IN;
    vector<int64> rev;

    int qpow(int b, int k) {
        int ret = 1;
        while(k > 0) {
            if(k & 1) ret = static_cast<int64>(ret) * b % P;
            b = static_cast<int64>(b) * b % P;
            k >>= 1;
        }
        return ret;
    }

    void initNTT(int l) {
        L = 0;
        while((1 << L) < l) L ++;
        N = 1 << L;
        IN = qpow(N, P - 2);
        
        rev = vector<int64>(N);

        for(int i = 0; i < N; i ++)
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (L - 1));
    }

    void NTT(vector<int64> &a, bool type) {
        a.resize(N);
        for(int i = 0; i < N; i ++)
            if(i < rev[i])
                swap(a[i], a[rev[i]]);
        
        for(int i = 1; i < N; i *= 2) {
            int64 g = qpow(type ? R : IR, (P - 1) / (i * 2));
            for(int j = 0; j < N; j += i * 2) {
                int64 gn = 1;
                for(int k = 0; k < i; k ++, gn = gn * g % P) {
                    int x = a[j + k], y = a[i + j + k] * gn % P;
                    a[j + k] = (x + y) % P;
                    a[i + j + k] = (x - y + P) % P;
                }
            }
        }
    }

    vector<int64> convolution(vector<int64> a, vector<int64> b) {
        int len = (int)a.size() + (int)b.size() - 1;
        NTT(a, 1);
        NTT(b, 1);
        for(int i = 0; i < N; i ++)
            a[i] = a[i] * static_cast<int64>(b[i]) % P;
        NTT(a, 0);
        a.resize(len);
        for(auto &x : a)
            x = static_cast<int64>(x) * IN % P;
        return a;
    }
}

vector<int64> polynomialMultiplication(const vector<int64>& a, const vector<int64>& b) {
    int N = a.size();
    NTT::initNTT(a.size() + b.size() - 1);
    vector<int64> res = NTT::convolution(a, b);
    res.resize(N);
    return res;
}

void solve() {
    cin >> N >> K;
    int M = N - 1;
    // calculate c[s] = number of connected labeled graphs with s nodes
    vector<int64> pow2(M + 1, 1);
    for (int i = 1; i <= M; ++i) {
        pow2[i] = 2LL * pow2[i - 1] % MOD;
    }
    vector<int64> c(M + 1, 0), g(M + 1, 0);
    g[0] = 1;
    for (int s = 1; s <= M; ++s) {
        g[s] = g[s - 1] * pow2[s - 1] % MOD;
    }
    c[1] = 1; // 1 vertex, one way to be connected
    for (int s = 2; s <= M; ++s) {
        int64 total = g[s];
        // subtracting from the total
        for (int k = 1; k < s; ++k) {
            int64 term1 = choose(s - 1, k - 1, MOD) * c[k] % MOD;
            int64 term2 = term1 * g[s - k] % MOD;
            total -= term2;
            if (total < 0) total += MOD;
        }
        c[s] = total;
    }
    vector<int64> f(M + 1, 0);
    for (int s = 1; s <= M; ++s) {
        int64 term = pow2[s] - 1;
        if (term < 0) term += MOD;
        f[s] = c[s] * term % MOD;
        f[s] = f[s] * inv_fact[s] % MOD;
    }
    vector<int64> h(M + 1, 0);
    for (int i = K; i <= M; ++i) {
        h[i] = inv_fact[i];
    }

    // Polynomial composition S(x) = H(F(x)) via Paterson–Stockmeyer.
    // degree is M
    int B = sqrt(M + 1) + 1; // block size
    int Q = ceil(M + 1, B); // number of blocks

    // small powers: F^0, F^1, ..., F^{B-1}
    vector<vector<int64>> small(B, vector<int64>(M + 1, 0));
    small[0][0] = 1; // F^0 = 1
    if (B > 1) small[1] = f;
    for (int i = 2; i < B; ++i) {
        small[i] = polynomialMultiplication(small[i - 1], f);
    }

    // big powers: G^q = (F^B)^q = F^{qB}
    vector<vector<int64>> big(Q, vector<int64>(M + 1, 0));
    big[0][0] = 1; // F^0
    // compute F^B
    vector<int64> FB = small[B - 1];
    FB = polynomialMultiplication(FB, f);
    if (Q > 1) big[1] = FB;
    for (int q = 2; q < Q; ++q) {
        big[q] = polynomialMultiplication(big[q - 1], FB);
    }

    // result S(x)
    vector<int64> S(M + 1, 0);
    for (int q = 0; q < Q; ++q) {
        // temp(x) = sum_{r=0}^{B-1} h[qB + r] * F(x)^r
        vector<int64> temp(M + 1, 0);
        bool nonzero = false;
        for (int r = 0; r < B; ++r) {
            int idx = q * B + r;
            if (idx > M) break;
            if (idx < K) continue; // h[idx] = 0
            int64 coeff = h[idx];  // 1 / idx!
            if (coeff == 0) continue;
            nonzero = true;
            for (int i = 0; i <= M; ++i) {
                temp[i] = (temp[i] + coeff * small[r][i]) % MOD;
            }
        }
        if (!nonzero) continue;
        // add big[q](x) * temp(x)
        auto prod = polynomialMultiplication(big[q], temp);
        for (int i = 0; i <= M; ++i) {
            S[i] = (S[i] + prod[i]) % MOD;
        }
    }

    // S(x) is ordinary series of sum_{k>=K} F^k/k!.
    // EGF coefficient a_{M} = (M)! * [x^M] S(x)
    int64 ans = S[M] * fact[M] % MOD;
    ans = ans * N % MOD; // any vertex can be pivot u
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    auto t0 = std::chrono::steady_clock::now();
    factorials(MAXN, MOD);
    solve();
    auto t1 = std::chrono::steady_clock::now();
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(t1 - t0).count();
    debug("Elapsed: ", ms, " ms", "\n");
    return 0;
}
```

## Exam Room

### Solution 1: combinations, permutation function, euclidean distance

1. Solve by brute force checking all subsets of size up to 5

```cpp
const int INF = numeric_limits<int64>::max();
int N;
vector<pair<int, int>> points;

int64 distance(int64 x1, int64 y1, int64 x2, int64 y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

bool possible(const vector<pair<int, int>> &pts) {
    for (auto [x1, y1] : pts) {
        for (auto [x2, y2] : pts) {
            if (x1 == x2 && y1 == y2) continue;
            if (distance(x1, y1, x2, y2) <= distance(x1, y1, 0, 0)) return false;
        }
    }
    return true;
}

void solve() {
    cin >> N;
    points.resize(N);
    for (int i = 0; i < N; ++i) {
        int x, y;
        cin >> x >> y;
        points[i] = {x, y};
    }
    int64 ans = 0;
    for (int i = 1; i <= min(5, N); ++i) {
        vector<int> mask(N, 0);
        fill(mask.begin(), mask.begin() + i, 1);
        do {
            vector<pair<int, int>> selected;
            for (int j = 0; j < N; ++j) {
                if (mask[j]) selected.emplace_back(points[j]);
            }
            if (possible(selected)) ans++;
        } while (prev_permutation(mask.begin(), mask.end()));
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

### Solution 2: 

```cpp

```