# UTPC 2026

# UTPC Contest 1-28-2026

## B. Supply Chain

### Solution 1: max element in array, sum

Observe that the difference between all the snowballs creation time is fixed between each one and that it is going to be equal to the slowest processing time. 

The slowest processing time means that is the bottleneck and everything will be now x time split. 

Given it is fixed you just need to find the first time at which a snowball is created, and then go from there. 

```cpp
int N, T;
vector<int> A;

void solve() {
    cin >> N >> T;
    A.resize(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }
    int delta = *max_element(A.begin(), A.end());
    int64 start = accumulate(A.begin(), A.end(), 0LL);
    if (start > T) {
        cout << 0 << endl;
        return;
    }
    int ans = (T - start) / delta + 1;
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}

```

## C. Frosted Highway

### Solution 1: prefix sum, gcd

Need a prefix sum for fast range queries to determine the number of elements with gcd = 1.

```cpp
int N, Q;
vector<int> psum;

void solve() {
    cin >> N >> Q;
    psum.assign(N + 1, 0);
    for (int i = 0; i < N; ++i) {
        int x;
        cin >> x;
        psum[i + 1] += psum[i];
        if (gcd(i + 1, x) == 1) psum[i + 1]++;
    }
    while (Q--) {
        int l, r;
        cin >> l >> r;
        int ans = psum[r] - psum[l - 1];
        cout << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## D. Snowball

### Solution 1: prefix sum, sorting, suffix sum

Key realization is that the best answer is going to have to be at one of the times when skeletons spawn.

And you can loop through those spawn events in order, increasing, and along the way keep track of the prefix sum and suffix sum.  

prefix sum tracks the amount of damage all the skeletons spawned prior do, and suffix sum the damage all skeletons afterwards will do

```cpp
const int64 INF = numeric_limits<int64>::max();
int N, K;
vector<int> A, coords;
map<int, int> freq;

void solve() {
    cin >> N >> K;
    A.resize(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
        coords.emplace_back(A[i]);
        freq[A[i]]++;
    }
    sort(coords.begin(), coords.end());
    coords.erase(unique(coords.begin(), coords.end()), coords.end());
    int M = coords.size();
    vector<int> F;
    for (const auto &[k, v]: freq) {
        F.emplace_back(v);
    }
    vector<int64> ssum(M + 1, 0);
    for (int i = M - 1; i >= 0; --i) {
        ssum[i] += ssum[i + 1] + 1LL * (K - coords[i]) * F[i];
    }
    int leftCnt = 0, prv = 0;
    int64 ans = INF, psum = 0;
    for (int i = 0; i < M; ++i) {
        int delta = coords[i] - prv;
        psum += 1LL * leftCnt * delta;
        int64 cand = psum + ssum[i + 1];
        ans = min(ans, cand);
        leftCnt += F[i];
        prv = coords[i];
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## F. Frosted Highway Hard

### Solution 1: harmonic loop, binary search

The key is you can use a harmonic loop which has about O(NlogN) time complexity for figuring out for each k what indexes match the gcd. 

By storing the indexes in a lookup table, then can query the lower and upper bound to find the number of index where that gcd was divisible by k.

```cpp
const int MAXK = 1e3;
int N, Q;
vector<int> A;
vector<vector<int>> lookup;

void solve() {
    cin >> N >> Q;
    A.resize(N + 1);
    for (int i = 1; i <= N; ++i) {
        cin >> A[i];
    }
    lookup.resize(MAXK + 1);
    for (int k = 1; k <= MAXK; ++k) {
        for (int i = k; i <= N; i += k) {
            if (gcd(i, A[i]) % k == 0) lookup[k].emplace_back(i);
        }
    }
    while (Q--) {
        int l, r, k;
        cin >> l >> r >> k;
        vector<int> &arr = lookup[k];
        int i = lower_bound(arr.begin(), arr.end(), l) - arr.begin();
        int j = upper_bound(arr.begin(), arr.end(), r) - arr.begin();
        int ans = j - i;
        cout << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## G. 

### Solution 1: 

Since there are only k obstacles, you only need to iterate over k rows technically.  Basically keep an array of ranges starting with [1, M] and for each row with obstacle, merge all the rows that have expanded out to overlap, maintain the current ranges.  And then break the ranges into a new array of ranges with the obstacles as splitting points.  Since there are only k obstacles, you will need at most around k merges, splits, so works out. 

```cpp

```

## H. 

### Solution 1: 

I'm very curious about the solution to this one, the best I got was toying with a two pointer approach, and trying all 27 permutations, but because of symmetry I had a vague since of I really only had to try a few permutations. I decided to not implement that garbage and try to think about a better solution.  But I'm not sure yet. 

```cpp

```