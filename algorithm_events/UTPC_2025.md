# UTPC Contest 1-29-25 Div. 1 (Advanced)

## Lion Dancers

### Solution 1:  combinatorics, counting, independent events, factorials

```cpp
const int64 MOD = 1e9 + 7, MAXN = 1e5 + 5;
int N, M;

int64 inv(int i, int64 m) {
  return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

vector<int64> fact, inv_fact;

void factorials(int n, int64 m) {
    fact.assign(n + 1, 1);
    inv_fact.assign(n + 1, 0);
    for (int i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % m;
    }
    inv_fact.end()[-1] = inv(fact.end()[-1], m);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
    }
}

int64 choose(int n, int r, int64 m) {
    if (n < r) return 0;
    return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
}

void solve() {
    cin >> N >> M;
    int ans = 1;
    for (int i = 0; i < M; i++) {
        int k;
        cin >> k;
        ans = (ans * choose(k, N, MOD)) % MOD;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    factorials(MAXN, MOD);
    solve();
    return 0;
}
```

## Lunar Phases

### Solution 1:  geometry, math, dot product, vectors

1. The key idea is if you take the vector and the perpendicular vector to it, you can determine which quadrant the point that represents the moon is in by using the dot product of the two vectors.

```cpp
int64 dotProduct(int64 x1, int64 y1, int64 x2, int64 y2) {
    return x1 * x2 + y1 * y2;
}

void solve() {
    int64 sx, sy, mx, my;
    cin >> sx >> sy >> mx >> my;
    int64 px = -sy, py = sx;
    int64 dot1 = dotProduct(sx, sy, mx, my);
    int64 dot2 = dotProduct(px, py, mx, my);
    if (dot1 > 0 && dot2 > 0) {
        cout << "Third quarter" << endl;
    } else if (dot1 > 0 && dot2 < 0) {
        cout << "Full moon" << endl;
    } else if (dot1 < 0 && dot2 > 0) {
        cout << "New moon" << endl;
    } else {
        cout << "First quarter" << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

## Lantern Hopping

### Solution 1:  max heap, greedy

1. The observation is you just need the maximum height over the entire segment, and the required energy to hop everywhere is the how much lower you are from the max height in the entire segment.

```cpp
int N, Q;
vector<int> A;

void solve() {
    cin >> N >> Q;
    A.resize(N);
    priority_queue<pair<int, int>> maxheap;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        maxheap.emplace(A[i], i);
    }
    while (Q--) {
        int t, i;
        cin >> t >> i;
        --i;
        while (maxheap.top().first != A[maxheap.top().second]) maxheap.pop();
        if (t == 1) {
            int maxHeight = maxheap.top().first;
            int ans = maxHeight - A[i];
            cout << ans << endl;
        } else {
            int h;
            cin >> h;
            A[i] = h;
            maxheap.emplace(h, i);
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Dragon Scales

### Solution 1:  line sweep, math

1. LIne sweep from left to right works well if you figure out how to update when starting a new segment, and when ending a segment (everything it contributes must be undone)

```cpp
int N, M;
vector<vector<int>> starts, ends_;
vector<int64> P, L;

void solve() {
    cin >> N >> M;
    starts.assign(M + 1, vector<int>());
    ends_.assign(M + 2, vector<int>());
    P.resize(N);
    L.resize(N);
    for (int i = 0; i < N; i++) {
        int l, r, p;
        cin >> l >> r >> p;
        P[i] = p;
        L[i] = r - l + 1;
        starts[l].emplace_back(i);
        ends_[r + 1].emplace_back(i);
    }
    int64 ans = 0, baseSum = 0;
    for (int i = 1; i <= M; i++) {
        for (int j : starts[i]) baseSum += P[j];
        for (int j : ends_[i]) {
            baseSum -= P[j];
            ans -= L[j] * P[j];
        }
        ans += baseSum;
        cout << ans << " ";
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Sally's Stroll (Easy Version)

### Solution 1: grid, undirected graph, connected components, bfs, combinatorics

1. precomputation to help with construction of undirected graph is hard to figure out and implement, but you need to mark passagble horizontal and vertical segments in two directions.  This needs to be precomputed, so you know which pair of two movements works to add connect two vertices with an edge.

```cpp
int R, C, KH, KV, sz, Q;
vector<vector<char>> grid;
vector<vector<int>> adj;
vector<bool> vis;

int map2Dto1D(int r, int c) {
    return r * C + c;
}

int64 countPairs(int64 n) {
    return n * (n - 1);
}

void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    sz++;
    for (int v : adj[u]) {
        dfs(v);
    }
}

void solve() {
    cin >> R >> C >> KV >> KH;
    grid.assign(R, vector<char>(C));
    adj.assign(R * C, vector<int>());
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            cin >> grid[i][j];
        }
    }
    cin >> Q;
    vector<vector<vector<bool>>> segments(R, vector<vector<bool>>(C, vector<bool>(4, false)));
    // horizontal segments
    for (int i = 0; i < R; i++) {
        int dist = 0;
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == '*') dist++;
            else dist = 0;
            if (dist >= KH + 1) {
                segments[i][j][2] = true;
                segments[i][j - KH][0] = true;
            }
        }
    }
    // vertical segments
    for (int j = 0; j < C; j++) {
        int dist = 0;
        for (int i = 0; i < R; i++) {
            if (grid[i][j] == '*') dist++;
            else dist = 0;
            if (dist >= KV + 1) {
                segments[i][j][3] = true;
                segments[i - KV][j][1] = true;
            }
        }
    }
    // build graph
    vector<int> dr = {0, 1, 0, -1}, dc = {1, 0, -1, 0};
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            for (int d1 = 0; d1 < 4; d1++) {
                if (!segments[i][j][d1]) continue;
                int r = i + dr[d1] * KV, c = j + dc[d1] * KH;
                for (int d2 = 0; d2 < 4; d2++) {
                    if (!segments[r][c][d2]) continue;
                    int r1 = r + dr[d2] * KV, c1 = c + dc[d2] * KH;
                    int u = map2Dto1D(i, j), v = map2Dto1D(r1, c1);
                    adj[u].emplace_back(v);
                    adj[v].emplace_back(u);
                }
            }
        }
    }
    // explore connected components
    int64 ans = 0;
    vis.assign(R * C, false);
    for (int i = 0; i < R * C; i++) {
        if (vis[i]) continue;
        sz = 0;
        dfs(i);
        ans += countPairs(sz);
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Red Envelope

### Solution 1:  reduction to nim game, xor sum, parity

1. You have to realize that if you have an even number of coins in a an envelope that is worthless, and basically it cancels out so the second player wins.  So reduce those to 0
1. If you have odd number of coins, now it gives a nim advantage because if there is just one than first player can pick it and win now. 
1. But the thing is you have frequency of these odd number of coins, and you can reduce it to be that the odd number represents a pile and the frequency is the size of the pile.  And now it is a standard nim gam, and can solve with xor sum, it must be non-zero for first player to win. 

```cpp
int N;
map<int, int> freq;

void solve() {
    cin >> N;
    for (int i = 0, x; i < N; i++) {
        cin >> x;
        freq[x]++;
    }
    int xorSum = 0;
    for (auto [x, f] : freq) {
        if (x & 1) xorSum ^= f;
    }
    if (xorSum > 0) {
        cout << "Ai" << endl;
    } else {
        cout << "Bo" << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# UTPC Contest 2-12-25 Div. 1 (Advanced)	

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# UTPC Contest 2-26-25 Div. 1 (Advanced)

## Crumby Conundrum

### Solution 1: grid, multisource bfs, queue, multisource shortest path, prefix sum, probability, counting

```cpp
int N, Q;
vector<vector<char>> grid;
vector<int> psum;

bool inBounds(int r, int c) {
    return r >= 0 && r < N && c >= 0 && c < N;
}

vector<pair<int, int>> neighborhood(int r, int c) {
    return {{r - 1, c}, {r + 1, c}, {r, c - 1}, {r, c + 1}};
}

void solve() {
    cin >> N >> Q;
    queue<pair<int, int>> q;
    grid.resize(N, vector<char>(N));
    int total = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> grid[i][j];
            if (grid[i][j] == 'E') {
                q.emplace(i, j);
            } else if (grid[i][j] == '.') {
                total++;
            }
        }
    }
    psum.assign(N * N, 0);
    int dist = 0;
    while (!q.empty()) {
        int sz = q.size();
        while (sz--) {
            auto [r, c] = q.front();
            q.pop();
            psum[dist]++;
            for (auto [nr, nc] : neighborhood(r, c)) {
                if (inBounds(nr, nc) && grid[nr][nc] == '.') {
                    grid[nr][nc] = 'E';
                    q.emplace(nr, nc);
                }
            }
        }
        dist++;
    }
    psum[0] = 0;
    for (int i = 1; i < N * N; i++) {
        psum[i] += psum[i - 1];
    }
    while (Q--) {
        int q;
        cin >> q;
        if (!psum[q - 1]) {
            cout << 0 << endl;
            continue;
        }
        long double ans = static_cast<long double>(psum[q - 1]) / total;
        cout << fixed << setprecision(15) << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Far Far Away

### Solution 1: tree, dfs

1. just want to use dfs to determine which nodes are on path from root to destination.
1. Then just need to find which nodes contain the item, and if the subtree does, then you need to increment 2, but only if it is not on the path. That is why you track which ones are on the path.

```cpp
int N, ans;
string S;
vector<vector<int>> adj;
vector<bool> onPath;

bool dfs(int u, int p = -1) {
    if (u == N - 1) {
        onPath[u] = true;
        return true;
    }
    for (int v : adj[u]) {
        if (v == p) continue;
        if (dfs(v, u)) {
            onPath[u] = true;
            return true;
        }
    }
    return false;
}

bool dfs1(int u, int p = -1) {
    if (onPath[u]) {
        ans++;
    }
    bool res = false;
    for (int v : adj[u]) {
        if (v == p) continue;
        res |= dfs1(v, u);
    }
    res |= S[u] == '1';
    if (res && !onPath[u]) {
        ans += 2;
    }
    return res;
}

void solve() {
    cin >> N >> S;
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    onPath.assign(N, false);
    ans = 0;
    dfs(0);
    dfs1(0);
    ans--;
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Time is Moinkney

### Solution 1: greedy, two pointers

1. This doesn't pass all test cases, but I believe it is on the path to correct solution. 

```cpp
int64 T, C, N, M, B;
vector<int64> sticks, bricks;

void solve() {
    cin >> T >> C >> N;
    sticks.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> sticks[i];
    }
    cin >> B >> M;
    bricks.resize(M);
    for (int i = 0; i < M; i++) {
        cin >> bricks[i];
    }
    int64 ans = 0, curVal = 0, curCost = 0, cntBricks = 0;
    vector<int64> costs;
    int idx = 0;
    while (curCost < T) {
        if (B < 3LL * C && curCost + B <= T) {
            costs.emplace_back(B);
            curCost += B;
            curVal += 3;
            cntBricks++;
            B += bricks[idx++];
            idx %= M;
        } else if (curCost + C <= T) {
            costs.emplace_back(C);
            curCost += C;
            curVal++;
        } else {
            break;
        }
    }
    ans = curVal;
    idx = 0;
    while (!costs.empty()) {
        curCost -= costs.back();
        costs.pop_back();
        curVal--;
        if (costs.size() < cntBricks) {
            costs.emplace_back(C);
            costs.emplace_back(C);
            curCost += 2LL * C;
            cntBricks--;
        }
        while (curCost + sticks[idx] <= T) {
            curCost += sticks[idx++];
            curVal += 2LL;
            idx %= N;
        }
        debug(curCost, curVal, costs, "\n");
        ans = max(ans, curVal);
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Humpty Dumpty

### Solution 1: line sweep algorithm, sorting, grid, leftmost, rightmost

1. The difficult part is you need to track leftmost and right most, that is where he can roll.  And also note where he can't. 
1. If you determine where he will roll until, and then fall, I store values in where you can fall. 

```cpp
enum EventType {
    PLATFORM, QUERY
};

struct Event {
    int x, y, i;
    EventType type;
    Event() {};
    Event(int x, int y, int i, EventType type) : x(x), y(y), i(i), type(type) {};
    bool operator<(const Event& other) const {
        if (y == other.y) return type < other.type;
        return y < other.y;
    }
};

const int MAXN = 1e5 + 5, INF = 1e9;
int N, Q;
vector<int> minDp, maxDp, lastPlatform, leftmost, rightmost;
set<pair<int, int>> platforms;
vector<vector<pair<int, int>>> pointsY;
vector<Event> events;

void process(vector<pair<int, int>> &arr, vector<pair<int, int>> &above) {
    if (arr.empty()) return;
    sort(arr.begin(), arr.end());
    sort(above.begin(), above.end());
    bool blocked = false;
    int last = arr[0].first;
    for (int i = 0, j = 0; i < arr.size(); i++) {
        auto [x, idx] = arr[i];
        if (i > 0 && arr[i - 1].first + 1 != x) { // finds gap
            blocked = false;
            last = x;
        }
        while (j < above.size() && above[j].first < x) j++;
        if (j < above.size() && above[j].first == x) {
            blocked = true;
        }
        if (blocked) {
            leftmost[idx] = -1;
        } else {
            leftmost[idx] = last - 1;
        }
    }
    blocked = false;
    sort(arr.rbegin(), arr.rend());
    sort(above.rbegin(), above.rend());
    last = arr[0].first;
    for (int i = 0, j = 0; i < arr.size(); i++) {
        auto [x, idx] = arr[i];
        if (i > 0 && arr[i - 1].first != x + 1) { // finds gap
            blocked = false;
            last = x;
        }
        while (j < above.size() && above[j].first > x) j++;
        if (j < above.size() && above[j].first == x) {
            blocked = true;
        }
        if (blocked) {
            rightmost[idx] = -1;
        } else {
            rightmost[idx] = last + 1;
        }
    }
}

void solve() {
    minDp.assign(MAXN, -INF);
    maxDp.assign(MAXN, -INF);
    lastPlatform.assign(MAXN, 1);
    pointsY.assign(MAXN, vector<pair<int, int>>());
    cin >> N;
    for (int i = 0; i < N; i++) {
        int x, y;
        cin >> x >> y;
        events.emplace_back(x, y + 1, i, PLATFORM);
        platforms.emplace(x, y);
        pointsY[y + 1].emplace_back(x, i);
    }
    leftmost.assign(MAXN, INF);
    rightmost.assign(MAXN, -INF);
    for (int y = 1; y < MAXN; y++) {
        process(pointsY[y], pointsY[y + 1]);
    }
    cin >> Q;
    for (int i = 0; i < Q; i++) {
        int x, y;
        cin >> x >> y;
        events.emplace_back(x, y, i, QUERY);
    }
    vector<pair<int, int>> ans(Q);
    sort(events.begin(), events.end());
    for (const auto &[x, y, i, type] : events) {
        if (type == PLATFORM) {
            int l = leftmost[i], r = rightmost[i];
            int minLeft = INF, maxLeft = -INF;
            if (l != -1 && !platforms.count({l, y})) {
                int distLeft = y - lastPlatform[l];
                minLeft = max(minDp[l], distLeft);
                maxLeft = max(maxDp[l], distLeft);
            }
            int minRight = INF, maxRight = -INF;
            if (r != -1 && !platforms.count({r, y})) {
                int distRight = y - lastPlatform[r];
                minRight = max(minDp[r], distRight);
                maxRight = max(maxDp[r], distRight);
            }
            minDp[x] = minLeft == INF && minRight == INF ? -INF : min(minLeft, minRight);
            maxDp[x] = max(maxLeft, maxRight);
            lastPlatform[x] = y;
        } else {
            int dist = y - lastPlatform[x];
            int minDist = max(minDp[x], dist);
            int maxDist = max(maxDp[x], dist);
            ans[i] = {maxDist, minDist};
        }
    }
    for (const auto &[x, y] : ans) {
        cout << x << " " << y << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## The Tale of the Fisherman and the Fish

### Solution 1:  treap, randomized self-balancing binary search tree, lazy propagation

1. The lazy propagation is needed because you are pushing the fact if you need to negate the values to the sums.
1. You can use the split and merge to move elements around with segments.  Write these down to track them. 

```cpp
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

struct Item {
    int64 val, prior, size, sum;
    bool neg;
    Item *l, *r;
    Item() {};
    Item(int64 val) : val(val), prior(rng()), size(1), sum(val), neg(false), l(NULL), r(NULL) {};
    Item(int64 val, int64 prior) : val(val), prior(prior), size(1), sum(val), neg(false), l(NULL), r(NULL) {};
};
typedef Item* pitem;

void push(pitem t) {
    if (t && t -> neg) {
        t -> val = -t -> val;
        t -> sum = -t -> sum;
        t -> neg = false;
        if (t -> l) t -> l -> neg ^= 1;
        if (t -> r) t -> r -> neg ^= 1;
    }
}

// prints the in-order traversal of a tree
void output(Item *t) {
    if (!t) return;
    push(t);
    output(t -> l);
    cout << t -> val << " ";
    output(t -> r);
}

void flip(pitem t) {
    if (t) {
        t -> neg ^= 1;
        push(t);
    }
}

int size(const pitem &item) { return item ? item -> size : 0; }
int sum(const pitem &t) { return t ? t -> sum : 0; }

void pull(pitem t) {
    if(t) {
        push(t -> l); push(t -> r);
        t->size = 1 + (t->l ? t->l->size : 0) + (t->r ? t->r->size : 0);
        t->sum = t->val + (t->l ? t->l->sum : 0) + (t->r ? t->r->sum : 0);
    }
}

void split(pitem t, pitem &l, pitem &r, int cnt) {
    push(t);
    if (!t) {
        l = r = nullptr;
        return;
    }
    if ( (t->l ? t->l->size : 0) < cnt ) {
        split(t->r, t->r, r, cnt - (t->l ? t->l->size : 0) - 1);
        l = t;
    }
    else {
        split(t->l, l, t->l, cnt);
        r = t;
    }
    pull(t);
}

void merge(pitem &t, pitem l, pitem r) {
    push(l); push(r);
    if (!l || !r) {
        t = l ? l : r;
        return;
    }
    if (l->prior > r->prior) {
        merge(l->r, l->r, r);
        t = l;
    }
    else {
        merge(r->l, l, r->l);
        t = r;
    }
    pull(t);
}

int N, Q;
vector<int64> A;

void solve() {
    cin >> N >> Q;
    A.resize(N);
    int64 curSum = 0;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    pitem root = NULL;
    for (int i = 0; i < N; i++) {
        if (i % 2 == 0) {
            curSum += A[i];
            merge(root, root, new Item(A[i]));
        } else {
            curSum -= A[i];
            merge(root, root, new Item(-A[i]));
        }
    }
    while (Q--) {
        int l, r;
        cin >> l >> r;
        l--, r--;
        pitem left = nullptr, mid = nullptr, right = nullptr;
        split(root, left, mid, l);
        pitem midSegment = nullptr;
        split(mid, midSegment, right, r - l + 1);
        int64 midSegSum = midSegment ? midSegment->sum : 0;
        curSum -= midSegSum;
        pitem shiftSegment = nullptr, isoSegment = nullptr;
        split(midSegment, isoSegment, shiftSegment, 1);
        flip(shiftSegment);
        if (l % 2 != r % 2) {
            flip(isoSegment);
        }
        pitem midSegment2 = nullptr;
        merge(midSegment2, shiftSegment, isoSegment);
        midSegSum = midSegment2 ? midSegment2->sum : 0;
        curSum += midSegSum;
        merge(mid, midSegment2, right);
        merge(root, left, mid);
        if (curSum > 0) {
            cout << "FISH" << endl;
        } else if (curSum < 0) {
            cout << "MAN" << endl;
        } else {
            cout << "TIE" << endl;
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# UTPC x WiCS Contest 3-12-25 

## 


### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## Walrus Wallflowers

### Solution 1: union find, undirected graph, grid, merge neighbors, connected components

```cpp
vector<bool> vis;
vector<vector<int>> adj;
int N, D, M;
long double ans;

struct UnionFind {
    vector<int> parents, size, F, C;
    vector<long double> tot;
    UnionFind(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
        F.assign(n, 0);
        C.assign(n, 0);
        tot.assign(n, 0.0);
    }

    void incrementC(int i) {
        i = find(i);
        if (tot[i] >= 0) ans -= tot[i];
        C[i]++;
        tot[i] = F[i] - sqrt(C[i]);
        if (tot[i] >= 0) ans += tot[i];
    }

    void incrementF(int i) {
        i = find(i);
        if (tot[i] >= 0) ans -= tot[i];
        F[i]++;
        tot[i] = F[i] - (C[i] ? sqrt(C[i]) : 0);
        if (tot[i] >= 0) ans += tot[i];
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    void merge(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            if (tot[i] >= 0) ans -= tot[i];
            if (tot[j] >= 0) ans -= tot[j];
            size[i]+=size[j];
            F[i] += F[j];
            C[i] += C[j];
            tot[i] = F[i] - (C[i] ? sqrt(C[i]) : 0);
            if (tot[i] >= 0) ans += tot[i];
            parents[j]=i;
        }
    }

    void add(int i) {
        if (i % N != N - 1 && vis[i + 1]) {
            merge(i, i + 1);
        }
        if (i % N != 0 && vis[i - 1]) {
            merge(i, i - 1);
        }
        if (i + N < M && vis[i + N]) {
            merge(i, i + N);
        }
        if (i - N >= 0 && vis[i - N]) {
            merge(i, i - N);
        }
    }
};

int map2Dto1D(int i, int j) {
    return i * N + j;
}

void solve() {
    cin >> N >> D;
    M = N * N;
    UnionFind dsu(M);
    vis.assign(M, false);
    adj.assign(M, vector<int>());
    for (int r = 0; r < N; r++) {
        string row;
        cin >> row;
        for (int c = 0; c < N; c++) {
            if (row[c] == '0') continue;
            int i = map2Dto1D(r, c);
            vis[i] = true;
            dsu.incrementF(i);
            dsu.add(i);
        }
    }
    for (int d = 0; d < D; d++) {
        int t;
        cin >> t;
        if (t == 1) {
            int r, c;
            cin >> r >> c;
            int i = map2Dto1D(r, c);
            if (!vis[i]) {
                vis[i] = true;
                dsu.incrementF(i);
                dsu.add(i);
                for (int v : adj[i]) {
                    dsu.merge(i, v);
                }
            }
        } else {
            int r1, c1, r2, c2;
            cin >> r1 >> c1 >> r2 >> c2;
            int u = map2Dto1D(r1, c1);
            int v = map2Dto1D(r2, c2);
            if (vis[u] && vis[v]) {
                dsu.incrementC(u);
                dsu.merge(u, v);
            } else if (vis[u]) {
                dsu.incrementC(u);
            } else {
                dsu.incrementC(v);
            }
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
        cout << fixed << setprecision(10) << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## 

### Solution 1: 

```cpp

```

# UT Open 2025

## Card Counting

### Solution 1: fenwick tree, segment tree, range queries

```cpp
template <typename T>
struct FenwickTree {
    vector<T> nodes;
    T neutral;
 
    FenwickTree() : neutral(T(0)) {}
 
    void init(int n, T neutral_val = T(0)) {
        neutral = neutral_val;
        nodes.assign(n + 1, neutral);
    }
 
    void update(int idx, T val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }
 
    T query(int idx) {
        T result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }
 
    T query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : T(0);
    }
};
 
struct SegmentTree {
    int size;
    int neutral = 0;
    vector<int64> nodes;
 
    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, 0);
    }
 
    int64 func(int64 x, int64 y) {
        return x + y;
    }
 
    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }
    // this is for assign, for addition change to += val
    void update(int segment_idx, int64 val) {
        segment_idx += size;
        nodes[segment_idx] = val; // += val if want addition, to track frequency
        segment_idx >>= 1;
        ascend(segment_idx);
    }
 
    int64 query(int left, int right) {
        left += size, right += size;
        int64 res = neutral;
        while (left <= right) {
            if (left & 1) {
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                res = func(res, nodes[right]);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};
 
int N;
vector<int> C;
 
void solve() {
    cin >> N;
    C.resize(N);
    for (int i = 0; i < N; ++i) {
        cin >> C[i];
    }
    FenwickTree<int64> ft;
    ft.init(N + 1);
    SegmentTree seg;
    seg.init(N + 1);
    int64 ans = 0;
    for (int i = 0; i < N; i++) {
        int64 m = ft.query(C[i], N);
        ans += m * C[i];
        ans += seg.query(C[i], N);
        ft.update(C[i], 1);
        seg.update(C[i], C[i]);
    }
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## City Renewal

### Solution 1: dynamic programming, two pointers

```cpp
int N, D;
vector<pair<int, int>> proposals;
vector<int64> X, P;
 
void solve() {
    cin >> N >> D;
    X.resize(N);
    P.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> X[i] >> P[i];
        proposals.emplace_back(X[i], P[i]);
    }
    sort(proposals.begin(), proposals.end());
    for (int i = 0; i < N; i++) {
        X[i] = proposals[i].first;
        P[i] = proposals[i].second;
    }
    vector<int64> dp(N, 0);
    for (int i = 0, j = 0; i < N; i++) {
        while (j + 1 < N && X[i] - X[j + 1] >= D) j++;
        if (i == 0) dp[i] = P[i];
        else dp[i] = max(dp[i - 1], P[i]);
        if (X[i] - X[j] >= D) dp[i] = max(dp[i], dp[j] + P[i]);
    }
    cout << dp.back() << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Lineism

### Solution 1: greedy, set

```cpp
set<pair<int, int>> verts;
int R, C;
vector<vector<char>> grid;
vector<vector<int>> rowToCol;
vector<set<int>> colToRow;
 
void solve() {
    cin >> R >> C;
    vector<int> counts(C, 0);
    rowToCol.assign(R, vector<int>());
    colToRow.assign(C, set<int>());
    for (int r = 0; r < R; r++) {
        string S;
        cin >> S;
        for (int c = 0; c < C; c++) {
            if (S[c] == 'X') {
                rowToCol[r].emplace_back(c);
                counts[c]++;
                colToRow[c].emplace(r);
            }
        }
    }
    for (int c = 0; c < C; c++) {
        if (!counts[c]) continue;
        verts.emplace(counts[c], c);
    }
    int ans = verts.size();
    int cur = ans; // just vertical strokes
    while (!verts.empty()) {
        auto [cnt, c] = *verts.begin();
        if (!cnt) {
            cur--; // don't need vertical stroke anymore
            ans = min(ans, cur);
            verts.erase(verts.begin());
            continue;
        }
        cur++;
        ans = min(ans, cur);
        int r = *colToRow[c].begin();
        for (int c2 : rowToCol[r]) {
            auto it = verts.find({counts[c2], c2});
            verts.erase(it);
            counts[c2]--;
            verts.emplace(counts[c2], c2);
            colToRow[c2].erase(r);
        }
    }
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Security Breach

### Solution 1: dijkstra, weighted directed graph, transpose graph, minimax path

1. Dijkstra variant where you are taking the minimax at each level so the new cost is max(dist[u], w), and you want to minimize the maximum cost from any path to this node u.
1. minimum maximum edge weight from node 0 to every other node 

```cpp
const int INF = (1 << 31) - 1;
int N, M;
vector<int> cost, costR;
vector<vector<pair<int, int>>> adj, tadj;
 
void dijkstra(vector<int> &dist, const vector<vector<pair<int, int>>> &adj) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minheap;
    minheap.emplace(0, 0);
    dist[0] = 0;
    while (!minheap.empty()) {
        auto [d, u] = minheap.top();
        minheap.pop();
        if (dist[u] < d) continue;
        for (auto [v, w] : adj[u]) {
            int ncost = max(dist[u], w);
            if (ncost < dist[v]) {
                dist[v] = ncost;
                minheap.emplace(dist[v], v);
            }
        }
    }
}
 
void solve() {
    cin >> N >> M;
    adj.assign(N, vector<pair<int, int>>());
    tadj.assign(N, vector<pair<int, int>>());
    for (int i = 0; i < M; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        adj[u].emplace_back(v, w);
        tadj[v].emplace_back(u, w);
    }
    cost.assign(N, INF);
    costR.assign(N, INF);
    dijkstra(cost, adj);
    dijkstra(costR, tadj);
    debug(cost, costR, "\n");
    for (int i = 0; i < N; i++) {
        if (costR[i] > cost[i]) {
            cout << "NO" << endl;
            return;
        }
    }
    cout << "YES" << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Tea Party

### Solution 1: knapsack dynamic programming, square root time complexity, counting dp

```cpp
const int64 MOD = 1e9 + 7;
int N;
vector<int64> A;
 
void solve() {
    cin >> N;
    A.resize(N + 1);
    int64 sumW = 0;
    for (int i = 1; i <= N; i++) {
        cin >> A[i];
        sumW += A[i];
    }
    vector<int64> dp(sumW + 1, 0);
    dp[0] = 1;
    bool found = false;
    for (int64 t = 1; t <= N; t++) {
        if (t * t <= sumW) {
            for (int i = t * t; i >= 0; i--) {
                if (i - A[t] >= 0) dp[i] = (dp[i] + dp[i - A[t]]) % MOD;
            }
        } else {
            if (!found) {
                for (int i = 0; i < sumW; i++) {
                    dp.back() = (dp.back() + dp[i]) % MOD;
                    dp[i] = 0;
                }
                found = true;
            }
            dp.back() = (dp.back() + dp.back()) % MOD;
        }
        debug(t, A[t], dp, "\n");
    }
    int64 ans = 0;
    for (int64 x : dp) {
        ans = (ans + x) % MOD;
    }
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Philadelphia Museum of Art

### Solution 1: tree, game theory, dp on tree, backward induction, general sum game, perfect information

Perfect information & no chance moves

Both Kuroni and Tfg know the entire tree layout and each other’s marked rooms.

There’s no randomness—every choice deterministically sends them into one child subtree.

Alternating moves

They start at the root, Kuroni chooses which adjacent room to visit, then Tfg chooses from there, then Kuroni, and so on, until they reach a leaf.

Payoffs are additive scores, not zero‑sum

Each player’s payoff is “how many of their marked rooms they visit.”

Unlike classic zero‑sum minimax (where one’s gain is exactly the other’s loss), here both players could score points in the same branch. It’s a general‑sum game, but each still assumes the other will play to maximize their own score.

Subgame‑perfect equilibrium via backward induction

Because the tree is finite and acyclic, every node defines a subgame. By starting at the leaves and working upward, you can compute for each node “—if it’s Kuroni’s turn here, what final (Kuroni_score, Tfg_score) pair will result?—” and likewise if it’s Tfg’s turn.

At each node, the player to move will pick the child that gives them the highest own score; ties are broken (as per the problem statement) by picking the branch that gives the other player the highest score.

This tie‑breaking isn’t standard minimax (which usually breaks ties arbitrarily or assumes adversarial tie‑breaks), but it’s just a lexicographic preference:

Maximize your own score

Subject to that, maximize your opponent’s score

```cpp
int N;
vector<vector<int>> adj, pref;
vector<vector<pair<int, int>>> dp; // 0: kuroni turn -> (kuroni score, tfg score), 1: tfg turn -> (kuroni score, tfg score)

void dfs(int u, int p = -1) {
    pair<int, int> bestKuroni = {0, 0}, bestTfg = {0, 0}; // kuroni turn, tfg turn, (kuroni score, tfg score)
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
        if (dp[v][1][0] > bestKuroni.first || (dp[v][1].first == bestKuroni.first && dp[v][1].second > bestKuroni.second)) {
            bestKuroni = dp[v][1];
        }
        if (dp[v][0].second > bestTfg.second || (dp[v][0].second == bestTfg.second && dp[v][0].first > bestTfg.first)) {
            bestTfg = dp[v][0];
        }
    }
    dp[u][0] = bestKuroni;
    dp[u][1] = bestTfg;
    for (int i = 0; i < 2; i++) {
        dp[u][i].first += pref[u][0];
        dp[u][i].second += pref[u][1];
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    pref.assign(N, vector<int>(2, 0));
    dp.assign(N, vector<pair<int, int>>(2, {0, 0}));
    for (int i = 0, x; i < N; i++) {
        cin >> x;
        pref[i][0] = x;
    }
    for (int i = 0, x; i < N; i++) {
        cin >> x;
        pref[i][1] = x;
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    dfs(0);
    cout << dp[0][0].first << " " << dp[0][0].second << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# UTPC Contest 9-17-25 Div. 1 (Advanced)

## Mars

### Solution 1: finite state machine, greedy, sorting

```cpp
int N, pos[2], nxt[2];

void solve() {
    cin >> N;
    fill(pos, pos + 2, 1);
    memset(nxt, 0, sizeof(nxt));
    vector<tuple<int, int, int>> events(N);
    for (int i = 0; i < N; i++) {
        int l, r, t;
        cin >> l >> r >> t;
        events[i] = {r, l, t};
    }
    sort(events.begin(), events.end());
    int ans = 0;
    for (const auto &[r, l, t] : events) {
        vector<pair<int, int>> cands;
        for (int i = 0; i < 2; ++i) {
            if (pos[i] == t ^ 1) {
                cands.emplace_back(nxt[i], i);
            }
        }
        sort(cands.rbegin(), cands.rend());
        if (cands.empty()) continue;
        for (const auto& [a, i] : cands) {
            if (a <= l) {
                pos[i] = t;
                nxt[i] = r;
                ans += t;
                break;
            }
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}

```

## Jupiter

### Solution 1: 

```cpp

```

## Saturn

### Solution 1: 

```cpp

```

## Uranus

### Solution 1: line sweep, sorting, min segment tree, range queries

```cpp
const int INF = numeric_limits<int>::max();
int N, Q;
vector<int> X, Y, C;

struct SegmentTree {
    int size;
    int neutral = INF;
    vector<int64> nodes;

    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, neutral);
    }

    int64 func(int64 x, int64 y) {
        return min(x, y);
    }

    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }
    // this is for assign, for addition change to += val
    void update(int segment_idx, int64 val) {
        segment_idx += size;
        nodes[segment_idx] = val; // += val if want addition, to track frequency
        segment_idx >>= 1;
        ascend(segment_idx);
    }

    int64 query(int left, int right) {
        left += size, right += size;
        int64 res = neutral;
        while (left <= right) {
           if (left & 1) {
                // res on left
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                // res on right
                res = func(nodes[right], res);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};

void solve() {
    cin >> N >> Q;
    X.resize(N);
    Y.resize(N);
    C.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> X[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> Y[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> C[i];
    }
    vector<tuple<int, int, int>> events;
    for (int i = 0; i < N; i++) {
        events.emplace_back(Y[i], X[i], C[i]);
    }
    sort(events.begin(), events.end());
    SegmentTree seg;
    seg.init(N);
    for (int i = 0; i < N; i++) {
        auto [y, x, c] = events[i];
        seg.update(i, c);
    }
    vector<pair<int, int>> Xs;
    for (int i = 0; i < N; i++) {
        Xs.emplace_back(get<1>(events[i]), i);
    }
    sort(Xs.begin(), Xs.end());
    vector<tuple<int, int, int>> queries;
    for (int i = 0; i < Q; ++i) {
        int t, w;
        cin >> t >> w;
        queries.emplace_back(t, w, i);
    }
    sort(Y.begin(), Y.end());
    sort(queries.begin(), queries.end());
    vector<int> ans(Q, -1);
    int i = 0;
    for (const auto &[t, w, idx] : queries) {
        while (i < N && Xs[i].first < t) {
            int pos = Xs[i].second;
            seg.update(pos, INF); // remove this point
            i++;
        }
        int l = lower_bound(Y.begin(), Y.end(), w) - Y.begin();
        int res = seg.query(l, N - 1);
        if (res != INF) ans[idx] = res;
    }
    for (int x : ans) {
        cout << x << endl;
    }
}


signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# UTPC Contest 10-1-25 Div. 1 (Advanced)

## To Leap or Not to Leap

### Solution 1: number theory, extended euclidean algorithm, linear diophantine equations, algebra

1. The trick for this one is you get the solutions, and then you can do algebra to enforce the constraint on x and y being non-negative but also getting the smallest of each. 

```cpp
int128 extendedEuclidean(int128 a, int128 b, int128 &x, int128 &y) {
    if (b == 0) {
        x = (a >= 0 ? 1 : -1);
        y = 0;
        return a;
    }
    int128 x1, y1;
    int128 g = extendedEuclidean(b, a % b, x1, y1);
    x = y1;
    y = x1 - y1 * (a / b);
    return g;
}
 
// Solve a*x + b*y = c
// Returns true if a solution exists and writes one solution into x, y.
// General solution: x = x0 + t*(b/g), y = y0 - t*(a/g), for any integer t.
bool linearDiophantine(int128 a, int128 b, int128 c, int128 &x, int128 &y, int128 &g) {
    int128 x0, y0;
    g = extendedEuclidean(a, b, x0, y0);
    if (c % g != 0) return false;
    int128 k = c / g;
    x = x0 * k;
    y = y0 * k;
    return true;
}
 
int64 A, B, C;
 
int128 ceil(int64 x, int64 y) {
    return (x + y - 1) / y;
}
 
static inline int128 floor_div(int128 a, int128 b) {
    // b must not be zero
    int128 q = a / b;
    int128 r = a % b;
    if (r != 0 && ((r > 0) != (b > 0))) --q;
    return q;
}
 
// ceil division that matches mathematical ceil for integers
static inline int128 ceil_div(int128 a, int128 b) {
    // b must not be zero
    return -floor_div(-a, b);
}
 
// A > 0 and B > 0 and C > 0
void solve() {
    cin >> A >> B >> C;
    // I want to solve for x, y: A*x + B*y = C
    // but I want to find the solution with the smallest non-negative x
    // and also find another solution with the smallest non-negative y.
    int128 x0, y0, g;
    if (!linearDiophantine(A, B, C, x0, y0, g)) {
        cout << -1 << endl;
        return;
    }
    int128 dx = B / g;
    int128 dy = A / g;
    // x = x0 + t*dx
    // y = y0 - t*dy
    int128 tmin = ceil_div(-x0, dx);
    int128 tmax = floor_div(y0, dy);
    if (tmin > tmax) {
        cout << -1 << endl;
        return;
    }
    int128 x1 = x0 + tmin * dx, y1 = y0 - tmin * dy;
    int128 x2 = x0 + tmax * dx, y2 = y0 - tmax * dy;
    int64 ans = min(x1 + 3LL * y1, x2 + 3LL * y2);
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Bandit and Bridges

### Solution 1: fully connected layers, dynamic programming, DAG, minimize cost

```cpp
const int64 INF = numeric_limits<int64>::max();
int N, K, M;
vector<vector<pair<int, int64>>> layers; // (x, d)
vector<int64> Y, dp, ndp;
 
void solve() {
    cin >> N >> K >> M;
    Y.resize(N + 2);
    Y[0] = 0;
    Y[N + 1] = M + 1;
    layers.resize(N + 2);
    for (int i = 1; i <= N; ++i) {
        cin >> Y[i];
    }
    layers[0].emplace_back(0, 1);
    for (int i = 0; i < K; ++i) {
        int x, y, d;
        cin >> x >> y >> d;
        layers[y].emplace_back(x, d);
    }
    layers[N + 1].emplace_back(0, 0);
    dp.assign(1, 0);
    for (int i = 1; i <= N + 1; ++i) {
        int nlayers = layers[i].size();
        ndp.assign(nlayers, INF);
        int64 dy = abs(Y[i] - Y[i - 1]);
        for (int j = 0; j < nlayers; ++j) {
            auto [x2, _] = layers[i][j];
            for (int k = 0; k < dp.size(); ++k) {
                auto [x1, d] = layers[i - 1][k];
                int64 dx = abs(x2 - x1);
                int64 cost = dp[k] + dx * dy * d;
                ndp[j] = min(ndp[j], cost);
            }
        }
        swap(dp, ndp);
    }
    int64 ans = !dp.empty() ? dp[0] : -1;
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Pancakes

### Solution 1: step function, plateaus, greedy, math

```cpp
const int64 INF = 1e18;
int64 a1, h1, a2, h2;
 
int64 ceil(int64 x, int64 y) {
    return (x + y - 1) / y;
}
 
int64 traversePlateaus() {
    int64 ans = INF;
    int64 curAttack = a1;
    while (true) {
        int64 rounds = ceil(h2, curAttack); // step functon is here
        ans = min(ans, max(0LL, curAttack - a1) + max(0LL, rounds * a2 - h1 + 1));
        if (rounds == 1) break; // we can't do better than this
        curAttack = ceil(h2, rounds - 1);
    }
    return ans;
}
 
void solve() {
    cin >> a1 >> h1 >> a2 >> h2;
    int64 ans = traversePlateaus();
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Rocket Cycle

### Solution 1:  binary search

1. You binary search first, then you can binary search the remaining segments. 

```cpp
int N;
 
char query(int x) {
    cout << x << endl;
    cout.flush();
    char res; 
    cin >> res;
    return res;
}
 
void answer(int x, int y) {
    cout << "! " << x << " " << y << endl;
    cout.flush();
 
}
 
int search(int lo, int hi) {
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        char res = query(mid);
        if (res == '>') {
            lo = mid + 1;
        } else if (res == '<') {
            hi = mid;
        } else {
            return mid;
        }
    }
    if (query(lo) == '=') return lo;
    return -1;
}
 
void solve() {
    cin >> N;
    int first = search(1, N);
    int second = -1;
    // search left
    if (first > 1) {
        second = search(1, first - 1);
    }
    if (second == -1) { // search right
        second = search(first + 1, N);
    }
    if (first > second) {
        swap(first, second);
    }
    answer(first, second);
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# UTPC Contest 10-15-25 Div. 1 (Advanced)

## Symbiogenesis

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# UTPC Contest 10-29-25

## Cookie's Candy

### Solution 1: 

1. just perform all O(N^2) swaps and the recalculation of the total distance requires at most 4 critical points to be updated. 

```cpp

```

## Hallway of Horrors

### Solution 1: 

1. I believe the trick is you will never wait more than 10^3, so just calculate that for each timestep 

```cpp

```

## Tung Tung Tung

### Solution 1: line intersection, undirected graph, dfs, cycle detection

1. intersection of lines to create undirected graph, and find if there all connected components have a cycle, where it can echo infinitely. 

```cpp
struct Line {
    int x1, y1, x2, y2;
    Line(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}
};

int N;
vector<vector<int>> adj;
vector<bool> vis;

bool dfs(int u, int p = -1) {
    vis[u] = true;
    for (int v : adj[u]) {
        if (v == p) continue;
        if (vis[v]) return true;
        if (dfs(v, u)) return true;
    }
    return false;
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    vector<Line> lines;
    for (int i = 0; i < N; i++) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if (x1 > x2) swap(x1, x2);
        if (y1 > y2) swap(y1, y2);
        Line line(x1, y1, x2, y2);
        for (int j = 0; j < i; ++j) {
            const Line& other = lines[j];
            // check intersection
            // if intersect, add edge
            if (x1 == x2 && other.y1 == other.y2 && other.x1 <= x1 && x1 <= other.x2) { // vertical line
                adj[i].emplace_back(j);
                adj[j].emplace_back(i);
            } else if (y1 == y2 && other.x1 == other.x2 && other.y1 <= y1 && y1 <= other.y2) { // horizontal line
                adj[i].emplace_back(j);
                adj[j].emplace_back(i);
            }
        }
        lines.emplace_back(x1, y1, x2, y2);
    }
    vis.assign(N, 0);
    bool found = true;
    for (int i = 0; i < N; ++i) {
        if (vis[i]) continue;
        found &= dfs(i);
    }
    cout << (found ? "YES" : "NO") << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## M & Nim

### Solution 1: recursive dp, sum

1. recursive dp with maximize? would that work? 
recursive where I have dp[i][j], where i is the number of candies left, and j is whose turn it is, and each turn I return a tuple (myscore, opponentscore)?

```cpp
const int INF = numeric_limits<int>::max();
int N;
vector<int> A, B;
vector<pair<int, int>> dp[2];
 
pair<int, int> dfs(int idx, int turn) {
    if (idx < 0) {
        return {0, 0};
    }
    if (dp[turn][idx].first != -1) {
        return dp[turn][idx];
    }
    pair<int, int> best = {-INF, -INF};
    int ssum = 0;
    for (int i = idx, j = 0; i >= 0 && j < 4; --i, ++j) {
        pair<int, int> res = dfs(i - 1, turn ^ 1);
        if (turn == 0) {
            ssum += A[i];
            res.first += ssum;
            if (res.first > best.first || (res.first == best.first && res.second < best.second)) {
                best = res;
            }
        } else {
            ssum += B[i];
            res.second += ssum;
            if (res.second > best.second || (res.second == best.second && res.first < best.first)) {
                best = res;
            }
        }
    }
    return dp[turn][idx] = best;
}
 
void solve() {
    cin >> N;
    A.resize(N);
    B.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> B[i];
    }
    dp[0].assign(N, {-1, -1});
    dp[1].assign(N, {-1, -1});
    pair<int, int> ans = dfs(N - 1, 0);
    cout << ans.first << " " << ans.second << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Candyholic

### Solution 1: dynamic programming, sparse table, gcd, two pointers, prefix sum optimization

1. calculate the gcd of each interval via sparse table for fast query
1. loop over the array and find the greatest index to the left such that the gcd = 1 for subarrays ending at that index.
1. Can do this fast with binary search and sparse table for gcd queries.
1. This works because the gcd is 1,1,1,2,5,24... as you expand the subarray to the right for any ending index i, so just need to find the last 1. 
1. Then need a prefix sum of the dp values up to each index.
1. Now can update the current state dp[n][k] = sum of dp[j][k-1] for all valid j., where gcd(A[j:i]) = 1.


```cpp
const int64 MOD = 1e9 + 3773 * 263;
int N, K;
vector<int> A;

const int LOG = 21;
struct SparseGCD {
    int N;
    vector<vector<int64>> st;
    SparseGCD(const vector<int> &arr) : N(arr.size()), st(LOG, vector<int64>(N, 0)) {
        for (int i = 0; i < N; i++) {
            st[0][i] = arr[i];
        }
        for (int i = 1; i < LOG; i++) {
            for (int j = 0; j + (1LL << i) <= N; j++) {
                st[i][j] = gcd(st[i - 1][j], st[i - 1][j + (1LL << (i - 1))]);
            }
        }
    }
    int64 query(int l, int r) const {
        int k = log2(r - l + 1);
        return gcd(st[k][l], st[k][r - (1LL << k) + 1]);
    }
};

void solve() {
    cin >> N >> K;
    A.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    vector<vector<int64>> dp(N + 1, vector<int64>(K + 1, 0));
    vector<int64> psum(K + 1, 0);
    SparseGCD st(A);
    dp[0][0] = 1;
    for (int i = 0, j = 0; i < N; ++i) {
        while (j < i && st.query(j, i) == 1) {
            for (int k = 0; k <= K; ++k) {
                psum[k] = (psum[k] + dp[j][k]) % MOD;
            }
            ++j;
        }
        for (int k = 1; k <= K; ++k) {
            dp[i + 1][k] = psum[k - 1] + dp[i][k - 1];
            dp[i + 1][k] %= MOD;
        }
    }
    cout << dp[N][K] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# 

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```