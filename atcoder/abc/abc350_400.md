# Atcoder Beginner Contest 352

## E - Clique Connect 

### Solution 1:  greedy, minimum spanning tree, union find

```py
from collections import defaultdict
def main():
    n, m = map(int, input().split())
    dsu = UnionFind(n)
    queries = [None] * m
    sets = [None] * m
    for i in range(m):
        k, w = map(int, input().split())
        nodes = list(map(lambda x: int(x) - 1, input().split()))
        queries[i] = (w, i)
        sets[i] = nodes
    queries.sort()
    cost = 0
    for w, i in queries:
        unions = defaultdict(list)
        du = u = None
        for node in sets[i]:
            du = dsu.find(node)
            u = node
            unions[du].append(node)
        for s, vals in unions.items():
            if s == du: continue 
            dsu.union(u, vals[0])
            cost += w
    if all(dsu.find(i) == dsu.find(0) for i in range(n)):
        print(cost)
    else:
        print(-1)

if __name__ == '__main__':
    main()
```

## F - Estimate Order 

### Solution 1: 

```py

```

## G - Socks 3 

### Solution 1:  combinatorics, probability, expectation value, FFT convolution, product of polynomial

```py

```
# Atcoder Beginner Contest 354

## E - Remove Pairs 

### Solution 1:  dynamic programming, bitmasks, turn based game, minimax algorithm

```cpp
int N, end_mask;
vector<int> F, B;
vector<vector<int>> dp;

bool recurse(int mask, int idx) {
    if (mask == end_mask) return false;
    if (dp[mask][idx] != -1) return dp[mask][idx];
    int win = false;
    for (int i = 0; i < N; i++) {
        if ((mask >> i) & 1) continue;
        for (int j = 0; j < N; j++) {
            if (i == j) continue;
            if ((mask >> j) & 1) continue;
            if (F[i] == F[j] || B[i] == B[j]) win |= recurse(mask | (1 << i) | (1 << j), idx + 1) ^ 1;
        }
    }
    return dp[mask][idx] = win;
}

signed main() {
    cin >> N;
    F.resize(N);
    B.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> F[i] >> B[i];
    }
    dp.assign(1 << N, vector<int>(N, -1));
    end_mask = (1 << N) - 1;
    bool ans = recurse(0, 0);
    cout << (ans ? "Takahashi" : "Aoki") << endl;
    return 0;
}
```

## F - Useless for LIS 

### Solution 1: 

```py

```

## G - Select Strings 

### Solution 1: 

```py

```
# Atcoder Beginner Contest 355

## E - Guess the Sum 

### Solution 1:  shortest path, bfs, undirected graph, parent array for backtracking

```cpp
const int MOD = 100, MAX = (1 << 18);
int N, L, R, T, ans;

int upper(int target, int i) {
    int lo = 0, hi = MAX;
    while (lo < hi) {
        int mid = (lo + hi) >> 1;
        if (mid * (1 << i) < target) lo = mid + 1;
        else hi = mid;
    }
    return lo;
}

int lower(int target, int i) {
    int lo = 0, hi = MAX;
    while (lo < hi) {
        int mid = (lo + hi + 1) >> 1;
        if (mid * (1 << i) - 1 <= target) lo = mid;
        else hi = mid - 1;
    }
    return lo;
}

void solve() {
    cin >> N >> L >> R;
    ans = 0;
    vector<pair<int, int>> ranges, nranges;
    ranges.emplace_back(L, R);
    for (int i = 18; i >= 0; i--) {
        nranges.clear();
        for (auto [l, r] : ranges) {
            cout << l << " " << r << endl;
            int s = upper(l, i), e = lower(r, i);
            if (s >= e) {
                nranges.emplace_back(l, r);
                continue;
            }
            // cout << i << " " << s << " " << e << endl;
            cout.flush();
            for (int j = s; j < e; j++) {
                cout << "? " << i << " " << j << endl;
                cout.flush();
                cin >> T;
                ans = (ans + T) % MOD;
            }
            int l1 = (1 << i) * s, r1 = (1 << i) * e - 1;
            if (l1 > l) {
                nranges.emplace_back(l, l1 - 1);
            }
            if (r1 < r) {
                nranges.emplace_back(r1 + 1, r);
            }
        }
        swap(ranges, nranges);
    }
    cout << "! " << ans << endl;
    cout.flush();
}

signed main() {
    solve();
    return 0;
}
```

## F - MST Query 

### Solution 1:  union find, union find for different edge weight graphs

```cpp
int N, Q;

struct UnionFind {
    vector<int> parents, size;
    void init(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};

void solve() {
    cin >> N >> Q;
    int ans = 10 * (N - 1);
    vector<UnionFind> dsus(10);
    for (auto &dsu : dsus) {
        dsu.init(N);
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        for (int j = w; j < 10; j++) {
            if (!dsus[j].same(u, v)) {
                ans--;
            }
        }
    }
    while (Q--) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        for (int j = w; j < 10; j++) {
            if (!dsus[j].same(u, v)) {
                ans--;
            }
        }
        cout << ans << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

## G - Baseball 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 356

## 

### Solution 1: 

```cpp
void solve() {
    int N;
    cin >> N;
    vector<int> A(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    vector<int> lmax(N), rmax(N);
    stack<int> stk;
    for (int i = 0; i < N; i++) {
        while (!stk.empty() && A[i] >= A[stk.top()]) {
            stk.pop();
        }
        lmax[i] = i - (stk.empty() ? -1 : stk.top());
        stk.push(i);
    }
    while (!stk.empty()) {
        stk.pop();
    }
    for (int i = N - 1; i >= 0; i--) {
        while (!stk.empty() && A[i] > A[stk.top()]) {
            stk.pop();
        }
        rmax[i] = (stk.empty() ? N : stk.top()) - i;
        stk.push(i);
    }
    vector<int> lmin(N), rmin(N);
    while (!stk.empty()) {
        stk.pop();
    }
    for (int i = 0; i < N; i++) {
        while (!stk.empty() && A[i] <= A[stk.top()]) stk.pop();
        lmin[i] = i - (stk.empty() ? -1 : stk.top());
        stk.push(i);
    }
    while (!stk.empty()) {
        stk.pop();
    }
    for (int i = N - 1; i >= 0; i--) {
        while (!stk.empty() && A[i] < A[stk.top()]) stk.pop();
        rmin[i] = (stk.empty() ? N : stk.top()) - i;
        stk.push(i);
    }
    int ans = 0;
    for (int i = 0; i < N; i++) {
        int lcount = min(lmax[i], lmin[i]), rcount = min(rmax[i], rmin[i]);
        ans += A[i] * lcount * rcount;
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 357

## E - Reachability in Functional Graph 

### Solution 1:  union find, topological order, cycle detection, functional graph, dynamic programming

```py
class UnionFind:
    def __init__(self, n: int):
        self.size = [1]*n
        self.parent = list(range(n))
    
    def find(self,i: int) -> int:
        while i != self.parent[i]:
            self.parent[i] = self.parent[self.parent[i]]
            i = self.parent[i]
        return i

    def same(self,i: int,j: int) -> bool:
        i, j = self.find(i), self.find(j)
        if i!=j:
            if self.size[i] < self.size[j]:
                i,j=j,i
            self.parent[j] = i
            self.size[i] += self.size[j]
            return False
        return True

from collections import deque

def main():
    n = int(input())
    indegrees = [0] * n
    edges = list(map(lambda x: int(x) - 1, input().split()))
    dsu = UnionFind(n)
    for i, x in enumerate(edges):
        dsu.same(i, x)
        indegrees[x] += 1
    cycle, vis, comp = [0] * n, [0] * n, [[] for _ in range(n)]
    comp_cycle = [0] * n
    dp = [0] * n
    ans = 0
    def search(u):
        parent = {u: None}
        is_cycle = False
        while True:
            vis[u] = 1
            v = edges[u]
            if v in parent: 
                is_cycle = True
                break
            if vis[v]: break
            parent[v] = u
            u = v
        if is_cycle:
            crit_point = parent[edges[u]]
            cnt = 0
            while u != crit_point:
                cycle[u] = 1
                cnt += 1
                u = parent[u]
            return cnt
        return 0
    def travel(nodes):
        nonlocal ans
        res = 0
        q = deque()
        for i in nodes:
            if indegrees[i] == 0: q.append(i)
        while q:
            u = q.popleft()
            vis[u] = 1
            if cycle[u]:
                res += dp[u]
                continue
            dp[u] += 1
            ans += dp[u]
            v = edges[u]
            if cycle[v]:
                res += dp[u]
                continue
            dp[v] += dp[u]
            indegrees[v] -= 1
            if indegrees[v] == 0:
                q.append(v)
        return res
    for i in range(n):
        if vis[i]: continue
        cycle_len = search(i)
        if cycle_len > 0: comp_cycle[dsu.find(i)] = cycle_len
        comp[dsu.find(i)].append(i)
        ans += cycle_len * cycle_len
    vis = [0] * n
    for i in range(n):
        if vis[i] or cycle[i]: continue
        length = travel(comp[dsu.find(i)])
        ans += length * comp_cycle[dsu.find(i)]
    print(ans)
    
if __name__ == '__main__':
    main()
```

## 

### Solution 1: 

```cpp

```

## G - Stair-like Grid 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 358

## E - Alphabet Tiles  

### Solution 1:  bounded knapsack, combinatorics, factorials

```py
MOD = 998244353
N = 26

def mod_inverse(x):
    return pow(x, MOD - 2, MOD)

def factorials(n):
    fact, inv_fact = [1] * (n + 1), [0] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = (fact[i - 1] * i) % MOD
    inv_fact[-1] = mod_inverse(fact[-1])
    for i in reversed(range(n)):
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
    return fact, inv_fact

def main():
    K = int(input())
    counts = list(map(int, input().split()))
    fact, inv_fact = factorials(K)
    def choose(n, r):
        return (fact[n] * inv_fact[r] * inv_fact[n - r]) % MOD if n >= r else 0
    dp = [0] * (K + 1)
    dp[0] = 1
    for i in range(N):
        ndp = dp[:]
        for j in range(1, counts[i] + 1):
            for cap in range(j, K + 1):
                ndp[cap] = (ndp[cap] + dp[cap - j] * choose(cap, j)) % MOD
        dp = ndp
    ans = sum(dp[1:]) % MOD
    print(ans)

if __name__ == '__main__':
    main()
```

## 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 359

## F - Tree Degree Optimization 

### Solution 1:  min heap, tree

```cpp
int N;
vector<int> A, deg;

struct TreeData {
    int deg, val, idx;
};

class TreeDataComparator {
    public:
        int operator () (const TreeData& d1, const TreeData& d2) {
            int delta1 = d1.deg * d1.deg * d1.val - (d1.deg - 1) * (d1.deg - 1) * d1.val;
            int delta2 = d2.deg * d2.deg * d2.val - (d2.deg - 1) * (d2.deg - 1) * d2.val;
            return delta1 > delta2;
        }
};

void solve() {
    cin >> N;
    A.resize(N);
    deg.assign(N, 1);
    priority_queue<TreeData, vector<TreeData>, TreeDataComparator> minheap;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        minheap.push({2, A[i], i}); // {next degree, value, index}
    }
    int total_deg = N;
    for (int i = 0; i < N - 2; i++) {
        TreeData d = minheap.top();
        deg[d.idx] = d.deg;
        minheap.pop();
        minheap.push({d.deg + 1, d.val, d.idx});
    }
    int ans = 0;
    for (int i = 0; i < N; i++) {
        ans += deg[i] * deg[i] * A[i];
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## G - Sum of Tree Distance

### Solution 1:  small to large merging, pairing, depth_sum, counts

```cpp
int N, ans;
vector<int> A, depth;
vector<vector<int>> adj;
vector<map<int, int>> depth_sum, cnt;

void dfs(int u, int p) {
    cnt[u][A[u]] = 1;
    depth_sum[u][A[u]] = depth[u];
    for (int v : adj[u]) {
        if (v == p) continue;
        depth[v] = depth[u] + 1;
        dfs(v, u);
        if (cnt[u].size() < cnt[v].size()) {
            swap(cnt[u], cnt[v]);
            swap(depth_sum[u], depth_sum[v]);
        }
        for (auto [color, freq] : cnt[v]) {
            if (cnt[u].find(color) == cnt[u].end()) {
                cnt[u][color] = freq;
                depth_sum[u][color] = depth_sum[v][color];
            } else {
                ans += freq * (depth_sum[u][color] - depth[u] * cnt[u][color]);
                ans += cnt[u][color] * (depth_sum[v][color] - depth[u] * freq);
                cnt[u][color] += freq;
                depth_sum[u][color] += depth_sum[v][color];
            }
        }
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    A.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    depth_sum.assign(N, map<int, int>());
    cnt.assign(N, map<int, int>());
    depth.assign(N, 0);
    ans = 0;
    dfs(0, -1);
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```
# Atcoder Beginner Contest 361

## E - Tree and Hamilton Path 2 

### Solution 1:  tree diameter, weighted undirected tree, twice DFS algorithm

```cpp
int N, diam, start_node, best;
vector<vector<pair<int, int>>> adj;
vector<int> dist;

// returns the farthest away node from u (random node)
void dfs1(int u, int p) {
    if (dist[u] > best) {
        best = dist[u];
        start_node = u;
    }
    for (auto [v, w]: adj[u]) {
        if (v == p) continue;
        dist[v] = dist[u] + w;
        dfs1(v, u);
    }
}

// Calculates the distance from the leaf node to every other node
void dfs2(int u, int p) {
    diam = max(diam, dist[u]);
    for (auto [v, w]: adj[u]) {
        if (v == p) continue;
        dist[v] = dist[u] + w;
        dfs2(v, u);
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<pair<int, int>>());
    int total = 0;
    for (int i = 0; i < N - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
        total += 2 * w;
    }
    dist.assign(N, 0);
    best = 0;
    dfs1(0, -1);
    dist.assign(N, 0);
    dfs2(start_node, -1);
    cout << total - diam << endl;
}

signed main() {
    solve();
    return 0;
}
```

### Solution 2:  tree reroot dp to compute tree diameter

```cpp
int N, diam;
vector<vector<pair<int, int>>> adj;
vector<int> mx1, mx2, node1, node2, par;

// mx1[u] = maximum distance from u to any other node and mx2 (second max)
void dfs1(int u, int p) {
    for (auto [v, w]: adj[u]) {
        if (v == p) continue;
        dfs1(v, u);
        if (mx1[v] + w > mx1[u]) {
            mx2[u] = mx1[u];
            mx1[u] = mx1[v] + w;
            node2[u] = node1[u];
            node1[u] = v;
        } else if (mx1[v] + w > mx2[u]) {
            mx2[u] = mx1[v] + w;
            node2[u] = v;
        }
    }
}

// Calculates the diameter
void dfs2(int u, int p) {
    diam = max(diam, mx1[u] + par[u]);
    for (auto [v, w]: adj[u]) {
        if (v == p) continue;
        par[v] = par[u] + w;
        if (v != node1[u]) par[v] = max(par[v], mx1[u] + w);
        else par[v] = max(par[v], mx2[u] + w);
        dfs2(v, u);
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<pair<int, int>>());
    int total = 0;
    for (int i = 0; i < N - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
        total += 2 * w;
    }
    mx1.assign(N, 0);
    mx2.assign(N, 0);
    node1.assign(N, -1);
    node2.assign(N, -1);
    par.assign(N, 0);
    dfs1(0, -1);
    dfs2(0, -1);
    cout << total - diam << endl;
}

signed main() {
    solve();
    return 0;
}
```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 362

## E - Count Arithmetic Subsequences 

### Solution 1:  dynamic programming, counting, arithmetic sequences, coordinate compression

```cpp
const int MOD = 998244353;
int N;
vector<int> arr;
vector<vector<vector<int>>> dp; // (i, k, d)

void solve() {
    cin >> N;
    arr.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }
    vector<int> diff;
    for (int i = 1; i < N; i++) {
        for (int j = 0; j < i; j++) {
            diff.push_back(arr[i] - arr[j]);
        }
    }
    // coordinate compression
    sort(diff.begin(), diff.end());
    diff.erase(unique(diff.begin(), diff.end()), diff.end());
    map<int, int> index;
    for (int i = 0; i < diff.size(); i++) {
        index[diff[i]] = i;
    }
    dp.assign(N, vector<vector<int>>(N, vector<int>(diff.size(), 0)));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < diff.size(); j++) {
            dp[i][0][j] = 1;
        }
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < i; j++) {
            for (int k = 1; k < N; k++) {
                int d = arr[i] - arr[j]; // j < i
                int idx = index[d];
                dp[i][k][idx] = (dp[i][k][idx] + dp[j][k - 1][idx]) % MOD;
            }
        }
    }
    cout << N << " ";
    for (int k = 1; k < N; k++) {
        int ans = 0;
        for (int i = 0; i < N; i++) {
            for (int d = 0; d < diff.size(); d++) {
                ans = (ans + dp[i][k][d]) % MOD;
            }
        }
        cout << ans << " ";
    }
    cout << endl;
}

signed main() {
    solve();
    return 0;
}
```

## F - Perfect Matching on a Tree 

### Solution 1: 

```cpp

```

## G - Count Substring Query 

### Solution 1:  suffix array with radix sort, binary search, memoize solution speedup, offline queries

```cpp
int Q;
string S, T;
vector<int> bucket_size, bucket_pos, leaderboard, update_leaderboard, equivalence_class, update_equivalence_class;

void radix_sort() {
    int n = leaderboard.size();
    bucket_size.assign(n, 0);
    for (int eq_class : equivalence_class) {
        bucket_size[eq_class]++;
    }
    bucket_pos.assign(n, 0);
    for (int i = 1; i < n; i++) {
        bucket_pos[i] = bucket_pos[i - 1] + bucket_size[i - 1];
    }
    update_leaderboard.assign(n, 0);
    for (int i = 0; i < n; i++) {
        int eq_class = equivalence_class[leaderboard[i]];
        int pos = bucket_pos[eq_class];
        update_leaderboard[pos] = leaderboard[i];
        bucket_pos[eq_class]++;
    }
}

vector<int> suffix_array(string& s) {
    int n = s.size();
    vector<pair<char, int>> arr(n);
    for (int i = 0; i < n; i++) {
        arr[i] = {s[i], i};
    }
    sort(arr.begin(), arr.end());
    leaderboard.assign(n, 0);
    equivalence_class.assign(n, 0);
    for (int i = 0; i < n; i++) {
        leaderboard[i] = arr[i].second;
    }
    equivalence_class[leaderboard[0]] = 0;
    for (int i = 1; i < n; i++) {
        int left_segment = arr[i - 1].first;
        int right_segment = arr[i].first;
        equivalence_class[leaderboard[i]] = equivalence_class[leaderboard[i - 1]] + (left_segment != right_segment);
    }
    bool is_finished = false;
    int k = 1;
    while (k < n && !is_finished) {
        for (int i = 0; i < n; i++) {
            leaderboard[i] = (leaderboard[i] - k + n) % n; // create left segment, keeps sort of the right segment
        }
        radix_sort(); // radix sort for the left segment
        swap(leaderboard, update_leaderboard);
        update_equivalence_class.assign(n, 0);
        update_equivalence_class[leaderboard[0]] = 0;
        for (int i = 1; i < n; i++) {
            pair<int, int> left_segment = {equivalence_class[leaderboard[i - 1]], equivalence_class[(leaderboard[i - 1] + k) % n]};
            pair<int, int> right_segment = {equivalence_class[leaderboard[i]], equivalence_class[(leaderboard[i] + k) % n]};
            update_equivalence_class[leaderboard[i]] = update_equivalence_class[leaderboard[i - 1]] + (left_segment != right_segment);
            is_finished &= (update_equivalence_class[leaderboard[i]] != update_equivalence_class[leaderboard[i - 1]]);
        }
        k <<= 1;
        swap(equivalence_class, update_equivalence_class);
    }
    return leaderboard;
}

int binary_search(string target) {
    int lo = 0, hi = S.size();
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (S.substr(leaderboard[mid], target.size()) < target) lo = mid + 1;
        else hi = mid;
    }   
    return lo;
}

map<string, vector<int>> queries;
vector<int> ans;


void solve() {
    cin >> S;
    cin >> Q;
    S += "$";
    suffix_array(S);
    ans.resize(Q);
    for (int i = 0; i < Q; i++) {
        cin >> T;
        if (queries.find(T) == queries.end()) queries[T] = vector<int>();
        queries[T].push_back(i);
    }
    for (auto [T, indices] : queries) {
        int l = binary_search(T), r = binary_search(T + '~');
        for (int i : indices) {
            ans[i] = r - l;
        }
    }
    for (int x : ans) {
        cout << x << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```
# Atcoder Beginner Contest 363

## 

### Solution 1: 

```cpp

```

## F - Palindromic Expression 

### Solution 1:  recursion, memoization, palindrome

```cpp
int N;
map<int, string> memo;

int rev(int x) {
    int res = 0;
    while (x) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return res;
}

bool is_palindrome(int x) {
    return x == rev(x);
}

bool contains_zero(int x) {
    while (x > 0) {
        if (x % 10 == 0) return true;
        x /= 10;
    }
    return false;
}

string calc(int n) {
    if (memo.find(n) != memo.end()) return memo[n];
    if (!contains_zero(n) && is_palindrome(n)) {
        return memo[n] = to_string(n);
    }
    int x = 2;
    while (x * x <= n) {
        if (!contains_zero(x) && n % x == 0) {
            int y = rev(x);
            if ((n / x) % y== 0) {
                string res = calc(n / x / y);
                if (res != "-1") return memo[n] = to_string(x) + '*' + res + '*' + to_string(y);
            }
        }
        x++;
    }
    return memo[n] = "-1";
}

void solve() {
    cin >> N;
    string ans = calc(N);
    if (ans == "-1") {
        cout << -1 << endl;
    } else {
        cout << ans << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

## G - Dynamic Scheduling 

### Solution 1: 

```cpp

```
# Atcoder Beginner Contest 363

## 

### Solution 1: 

```cpp

```

## F - Range Connect MST 

### Solution 1:  union find, merge sets, sort, functional graph, next array

```cpp
struct Item {
    int c, l, r;
    Item(int c, int l, int r) : c(c), l(l), r(r) {}
    bool operator<(const Item &other) const {
        return c < other.c;
    }
};

struct UnionFind {
    vector<int> parents, size;
    void init(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};

int N, Q;
vector<Item> arr;

void solve() {
    cin >> N >> Q;
    for (int i = 0; i < Q; i++) {
        int c, l, r;
        cin >> l >> r >> c;
        l--; r--;
        arr.emplace_back(c, l, r);
    }
    sort(arr.begin(), arr.end());
    UnionFind dsu;
    dsu.init(N);
    vector<int> nxt(N);
    iota(nxt.begin(), nxt.end(), 0);
    int ans = 0;
    for (auto &[c, l, r] : arr) {
        int u = l;
        ans += c;
        while (u < r) {
            // find the last node in the current set
            u = nxt[dsu.find(u)];
            // merge with start of next set. 
            if (u + 1 <= r) {
                ans += c;
                int v = nxt[dsu.find(u + 1)]; // determine last of next set
                dsu.same(u, u + 1);
                nxt[dsu.find(u)] = v; // set last of current merged set to the last of the next set.
            }
            u++;
        }
    }
    if (dsu.size[dsu.find(0)] == N) {
        cout << ans << endl;
    } else {
        cout << -1 << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

## G - Last Major City 

### Solution 1:  minimum steiner tree problem, bitmask dp, min heap, dijkstra, enumerate submasks

```cpp
const int INF = 1e16;
int N, M, K;
vector<vector<pair<int, int>>> adj;
vector<vector<int>> dp;

void solve() {
    cin >> N >> M >> K;
    K--;
    dp.assign(1 << K, vector<int>(N, INF));
    for (int i = 0; i < K; i++) {
        dp[1 << i][i] = 0; // fixed terminal nodes for steiner tree
    }
    adj.assign(N, vector<pair<int, int>>());
    // construct weighted graph
    for (int i = 0; i < M; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }
    for (int mask = 1; mask < (1 << K); mask++) {
        for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {
            for (int i = 0; i < N; i++) {
                dp[mask][i] = min(dp[mask][i], dp[submask][i] + dp[mask - submask][i]); // mask - submask works because it is a submask, this gets the set difference
            }
        }
        // dijkstra part to find shortest path given this bitmask or set of elements in a steiner tree
        // And calculate the shortest path to be able to reach vertex v.
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minheap;
        for (int i = 0; i < N; i++) {
            minheap.emplace(dp[mask][i], i);
        }
        // shortest distance from any node in the mask or set of nodes (steiner tree) to any other node outside of the current steiner tree. 
        while (!minheap.empty()) {
            auto [dist, u] = minheap.top();
            minheap.pop();
            if (dist > dp[mask][u]) continue;
            for (auto [v, w] : adj[u]) {
                if (dp[mask][u] + w < dp[mask][v]) {
                    dp[mask][v] = dp[mask][u] + w;
                    minheap.emplace(dp[mask][v], v);
                }
            }
        }
    }
    for (int i = K; i < N; i++) {
        cout << dp.end()[-1][i] << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 367

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 368

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 369

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 370

## D - Cross Explosion

### Solution 1:  map and set, binary search, remove the nearest in each direction

To determine if it you can use prev(it) you just check that it is not at the beginning, than you can get the previous iterator.


```cpp
int R, C, Q;
map<int, set<int>> rows, cols;

void solve() {
    cin >> R >> C >> Q;
    for (int r = 0; r < R; r++) {
        for (int c = 0; c < C; c++) {
            rows[r].insert(c);
            cols[c].insert(r);
        }
    }
    int ans = R * C;
    while (Q--) {
        int r, c;
        cin >> r >> c;
        r--, c--;
        if (rows[r].count(c)) {
            rows[r].erase(c);
            cols[c].erase(r);
            ans--;
        } else {
            auto it = rows[r].upper_bound(c);
            if (it != rows[r].begin()) {
                int j = *prev(it);
                rows[r].erase(j);
                cols[j].erase(r);
                ans--;
            }
            if (it != rows[r].end()) {
                int j = *it;
                rows[r].erase(j);
                cols[j].erase(r);
                ans--;
            }
            it = cols[c].upper_bound(r);
            if (it != cols[c].begin()) {
                int i = *prev(it);
                rows[i].erase(c);
                cols[c].erase(i);
                ans--;
            }
            if (it != cols[c].end()) {
                int i = *it;
                rows[i].erase(c);
                cols[c].erase(i);
                ans--;
            }

        }
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## E - Avoid K partition

### Solution 1:  dynamic programming, cumulative sums, prefix sums optimizations, binary decision tree

count number of valid partitions for placing a partition after index i element. so arr[0...i]
Count the number of valid partitioning of array using dynammic programming.

```cpp
const int M = 998244353;
int N, K;
vector<int> arr, dp;
map<int, int> lookup;

void solve() {
    cin >> N >> K;
    arr.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }
    dp.resize(N + 1);
    dp[0] = 1;
    int psum = 0, csum = 1;
    lookup[psum] = 1;
    for (int i = 0; i < N; i++) {
        psum += arr[i];
        int cur = (csum - lookup[psum - K] + M) % M;
        dp[i + 1] = cur;
        csum = (csum + cur) % M;
        lookup[psum] = (lookup[psum] + cur) % M;
    }
    cout << dp[N] << endl;
}

signed main() {
    solve();
    return 0;
}

```

## F - Cake Division

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 371

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 372

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 373

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 374

## D - Laser Marking 

### Solution 1:  permutations, bitmask, euclidean distance, 2d coordinates, kinematics

```cpp
struct Point {
    int x, y;
    Point() {}
    Point(int x, int y) : x(x), y(y) {}
};

const long double INF = 1e9;
int N, S, T;
vector<pair<Point, Point>> lines;

long double euclidean_distance(int x1, int y1, int x2, int y2) {
    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

long double calc(int mask, const vector<int> &arr) {
    long double ans = 0;
    int x = 0, y = 0;
    for (int i : arr) {
        Point p1 = lines[i].first;
        Point p2 = lines[i].second;
        if ((mask >> i) & 1) {
            swap(p1, p2);
        }
        long double d1 = euclidean_distance(x, y, p1.x, p1.y);
        long double d2 = euclidean_distance(p1.x, p1.y, p2.x, p2.y);
        ans += d1 / S + d2 / T;
        x = p2.x; y = p2.y;
    }
    return ans;
}

void solve() {
    cin >> N >> S >> T;
    lines.resize(N);
    for (int i = 0; i < N; i++) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        lines[i] = make_pair(Point(x1, y1), Point(x2, y2));
    }
    vector<int> indices(N);
    iota(indices.begin(), indices.end(), 0LL);
    long double ans = INF;
    do {
        for (int mask = 0; mask < (1 << N); mask++) {
            ans = min(ans, calc(mask, indices));
        }
    } while (next_permutation(indices.begin(), indices.end()));
    cout << fixed << setprecision(15) << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## E - Sensor Optimization Dilemma 2 

### Solution 1:  greedy binary search, bound optimization, efficiency analysis

```cpp
const int INF = 1e9;
int N, Y, A, P, B, Q;
vector<int> product1, product2, cost1, cost2;
int ceil(int x, int y) {
    return (x + y - 1) / y;
}
// logic here is wrong
int calc(int A, int B, int P, int Q, int target) {
    // take of A to satisfy target production
    int ans = INF;
    for (int i = 0; i < 1000; i++) {
        if (B * i >= target) break;
        int take_a = ceil(target - B * i, A);
        ans = min(ans, take_a * P + i * Q);
    }
    return ans;
}

bool possible(int target) {
    int cost = 0;
    for (int i = 0; i < N; i++) {
        // do this
        int cand1 = calc(product1[i], product2[i], cost1[i], cost2[i], target);
        int cand2 = calc(product2[i], product1[i], cost2[i], cost1[i], target);
        cost += min(cand1, cand2);
    }
    return cost <= Y;
}

void solve() {
    cin >> N >> Y;
    product1.resize(N);
    product2.resize(N);
    cost1.resize(N);
    cost2.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> product1[i] >> cost1[i] >> product2[i] >> cost2[i];
    }
    int lo = 0, hi = INF;
    while (lo < hi) {
        int mid = lo + (hi - lo + 1) / 2;
        if (possible(mid)) lo = mid;
        else hi = mid - 1;
    }
    cout << lo << endl;
}

signed main() {
    solve();
    return 0;
}
```

## F - Shipping 

### Solution 1:  dynamic programming, line sweep, sorting, push dp

```cpp
const int INF = 1e18;
int N, K, X;
vector<int> pos, events;

void solve() {
    cin >> N >> K >> X;
    pos.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> pos[i];
        for (int j = 0; j < N; j++) {
            events.emplace_back(pos[i] + j * X);
        }
    }
    sort(events.begin(), events.end());
    events.erase(unique(events.begin(), events.end()), events.end());
    int M = events.size();
    vector<vector<int>> dp(M + 1, vector<int>(N + 1, INF));
    dp[0][0] = 0;
    int nxt = 0, ans = INF;
    for (int i = 0; i < M; i++) {
        while (nxt < M && events[nxt] < events[i] + X) nxt++;
        for (int j = 0; j < N; j++) {
            if (dp[i][j] == INF) continue;
            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
            int dis = 0;
            for (int n = j; n < min(j + K, N); n++) {
                if (pos[n] > events[i]) break;
                dis += events[i] - pos[n];
                if (n + 1 == N) ans = min(ans, dp[i][j] + dis);
                else dp[nxt][n + 1] = min(dp[nxt][n + 1], dp[i][j] + dis);
            }
        }
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 375

## C - Spiral Rotation

### Solution 1:  2d grid, coordinate transformation

1. If you think about it each frame is rotated 90 degrees, and the next one 90 degrees more and so on.
1. So it is rotated n * 90 degrees based on if the frame is n from the outter frame.
1. Since it can happen at most 4 times, you can just solve for the 4 rotations and use modulo 4 to solve the transformations.

```cpp
int N;
vector<vector<char>> grid;

pair<int, int> rotate(int rank, int i, int j) {
    if (rank % 4 == 0) {
        return {N - 1 - j, i};
    } else if (rank % 4 == 1) {
        return {N - 1 - i, N - 1 - j};
    } else if (rank % 4 == 2) {
        return {j, N - 1 - i};
    }
    return {i, j};
}

void solve() {
    cin >> N;
    grid.resize(N, vector<char>(N));
    for (int i = 0; i < N; i++) {
        string row;
        cin >> row;
        for (int j = 0; j < N; j++) {
            grid[i][j] = row[j];
        }
    }
    vector<vector<char>> ans(N, vector<char>(N));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            auto [x, y] = rotate(min({i, j, N - i - 1, N - j - 1}), i, j);
            ans[i][j] = grid[x][y];
        }
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cout << ans[i][j];
        }
        cout << endl;
    }
    cout << endl;
}

signed main() {
    solve();
    return 0;
}
```

## D - ABA

### Solution 1:  counting, prefix and suffix counts

```cpp
string S;
int pre[26], suf[26];

int unicode(const char& ch) {
    return ch - 'A';
}

void solve() {
    cin >> S;
    int N = S.size();
    memset(pre, 0, sizeof(pre));
    memset(suf, 0, sizeof(suf));
    for (int i = 0; i < N; i++) {
        suf[unicode(S[i])]++;
    }
    int ans = 0;
    for (int i = 0; i < N; i++) {
        suf[unicode(S[i])]--;
        for (int j = 0; j < 26; j++) {
            ans += pre[j] * suf[j];
        }
        pre[unicode(S[i])]++;
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## E - 3 Team Division

### Solution 1:  recursive dynamaic programming, memoization

```cpp
const int INF = 1e9;
int N, target;
vector<int> A, B;
vector<vector<vector<int>>> dp;

int dfs(int i, int x, int y) {
    if (x < 0 || y < 0) return INF;
    if (i == N) {
        if (x == 0 && y == 0) return 0;
        return INF;
    }
    if (dp[i][x][y] != -1) return dp[i][x][y];
    int ans = INF;
    // place in team 0
    if (A[i] == 0) {
        ans = min(ans, dfs(i + 1, x - B[i], y));
        ans = min(ans, dfs(i + 1, x, y - B[i]) + 1);
        ans = min(ans, dfs(i + 1, x, y) + 1);
    } else if (A[i] == 1) {
        ans = min(ans, dfs(i + 1, x - B[i], y) + 1);
        ans = min(ans, dfs(i + 1, x, y - B[i]));
        ans = min(ans, dfs(i + 1, x, y) + 1);
    } else {
        ans = min(ans, dfs(i + 1, x - B[i], y) + 1);
        ans = min(ans, dfs(i + 1, x, y - B[i]) + 1);
        ans = min(ans, dfs(i + 1, x, y));
    }
    return dp[i][x][y] = ans;
}

void solve() {
    cin >> N;
    A.resize(N);
    B.resize(N);
    int sum = 0;
    for (int i = 0; i < N; i++) {
        cin >> A[i] >> B[i];
        A[i]--;
        sum += B[i];
    }
    if (sum % 3) {
        cout << -1 << endl;
        return;
    }
    target = sum / 3;
    dp.assign(N + 1, vector<vector<int>>(target + 1, vector<int>(target + 1, -1)));
    int ans = dfs(0, target, target);
    cout << (ans < INF ? ans : -1) << endl;
}

signed main() {
    solve();
    return 0;
}
```

## F - Road Blocked

### Solution 1:  all pairs shortest path, floyd warshall, offline queries, reverse queries

1. Use floyd warshall because can be dense graph, so it is better with O(N^3) time for initial computation of all pairs shortest path, with all the edges you start with.
1. Update the distance for all pairs of nodes x, y with the addition of an edge between u and v with weight w.
1. Process the queries offline and in reverse order, because it is easier to deal with adding edges, than it is to remove edges.  can update distance with addition of edge in O(N^2) time. 


```cpp
struct Edge {
    int u, v, w;
    Edge() {}
    Edge(int u, int v, int w) : u(u), v(v), w(w) {}
};

struct Query {
    int t, u, v;
    Query() {}
    Query(int t, int u) : t(t), u(u) {}
    Query(int t, int u, int v) : t(t), u(u), v(v) {}
};

const int INF = 1e12;
int N, M, Q;
vector<vector<int>> dist;
vector<Edge> edges;
vector<bool> removed;

void floyd_warshall() {
    for (int k = 0; k < N; k++) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

void update(int u, int v, int w) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            dist[i][j] = min(dist[i][j], dist[i][u] + w + dist[v][j]);
            dist[i][j] = min(dist[i][j], dist[i][v] + w + dist[u][j]);
        }
    }
}

void solve() {
    cin >> N >> M >> Q;
    dist.assign(N, vector<int>(N, INF));
    edges.resize(M);
    for (int i = 0; i < M; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        edges[i] = Edge(u, v, w);
    }
    removed.assign(M, false);
    vector<Query> queries;
    for (int i = 0; i < Q; i++) {
        int t;
        cin >> t;
        if (t == 1) {
            int x;
            cin >> x;
            x--;
            removed[x] = true;
            queries.emplace_back(t, x);
        } else {
            int u, v;
            cin >> u >> v;
            u--, v--;
            queries.emplace_back(t, u, v);
        }
    }
    for (int i = 0; i < M; i++) {
        if (removed[i]) continue;
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        dist[u][v] = min(dist[u][v], w);
        dist[v][u] = min(dist[v][u], w);
    }
    for (int i = 0; i < N; i++) {
        dist[i][i] = 0;
    }
    floyd_warshall();
    vector<int> ans;
    reverse(queries.begin(), queries.end());
    for (const Query& q : queries) {
        if (q.t == 1) {
            update(edges[q.u].u, edges[q.u].v, edges[q.u].w);
        } else {
            ans.emplace_back(dist[q.u][q.v] < INF ? dist[q.u][q.v] : -1);
        }
    }
    reverse(ans.begin(), ans.end());
    for (int x : ans) {
        cout << x << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

## G - Road Blocked 2

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 376

## D - Cycle 

### Solution 1:  bfs, directed graph, shortest distance for cycle

```cpp
const int INF = 1e9;
int N, M;
vector<vector<int>> adj;
vector<int> dist;

int bfs(int src, const vector<vector<int>>& adj) {
    queue<int> q;
    q.push(src);
    dist[src] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (v == src) {
                return dist[u] + 1;
            }
            if (dist[v] == INF) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    return -1;
}

void solve() {
    cin >> N >> M;
    adj.assign(N, vector<int>());
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
    }
    dist.assign(N, INF);
    int ans = bfs(0, adj);
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## E - Max × Sum 

### Solution 1:  maxheap, sorting, greedy

```cpp
const int INF = 1e18;
int N, K;
vector<int> A, B;

void solve() {
    cin >> N >> K;
    A.resize(N);
    B.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> B[i];
    }
    vector<pair<int, int>> values;
    priority_queue<int> maxheap;
    for (int i = 0; i < N; i++) {
        values.emplace_back(A[i], B[i]);
    }
    sort(values.begin(), values.end());
    int sum = 0;
    for (int i = 0; i < K; i++) {
        sum += values[i].second;
        maxheap.push(values[i].second);
    }
    int ans = values[K - 1].first * sum;
    for (int i = K; i < N; i++) {
        sum += values[i].second;
        maxheap.push(values[i].second);
        sum -= maxheap.top();
        maxheap.pop();
        ans = min(ans, values[i].first * sum);
    }
    cout << ans << endl;
}

signed main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

## F - Hands on Ring (Hard) 

### Solution 1:  dynamic programming, modular arithmetic, math

1. hard edge case to see is when start = 4, end = 1, and other = 1, as well,  so in this case you can move clockwise and anti-clockwise and both times you have to move the other hand as well, because it is at the location you want to move current hand to. 
1. 

```cpp
const int INF = 1e15;
int N, Q;
vector<pair<char, int>> q;
vector<vector<int>> dp;
int pos[2];

int id(const char ch) {
    if (ch == 'R') return 1;
    return 0;
}

int clockwise(int l, int r) {
    if (r >= l) return r - l;
    return N - l + r;
}

int between(int l, int r, int p) {
    if (r >= l) return l <= p && p <= r;
    return p <= r || p >= l;
}

vector<pair<int, int>> moves(int p1, int p2, int other) {
    vector<pair<int, int>> res;
    int dist = clockwise(p1, p2);
    if (p2 != other) {
        if (!between(p1, p2, other)) {
            res.emplace_back(dist, other);
        } else {
            res.emplace_back(N - dist, other);
        }
    }
    if (between(p1, p2, other)) {
        res.emplace_back(dist + clockwise(other, (p2 + 1) % N), (p2 + 1) % N);
        if (other == p2) {
            res.emplace_back(2 * N - dist - clockwise(other, (p2 - 1 + N) % N), (p2 - 1 + N) % N);
        }
    } else {
        res.emplace_back(2 * N - dist - clockwise(other, (p2 - 1 + N) % N), (p2 - 1 + N) % N);
    }
    return res;
}

void solve() {
    cin >> N >> Q;
    q.clear();
    for (int i = 0; i < Q; i++) {
        char c;
        int k;
        cin >> c >> k;
        q.push_back({c, k - 1});
    }
    for (int i = 0; i < 2; i++) pos[i] = i;
    int ph = id(q[0].first);
    int pp = ph;
    dp.assign(Q + 1, vector<int>(N, INF));
    dp[0][pp ^ 1] = 0;
    for (int i = 0; i < Q; i++) {
        int h = id(q[i].first);
        int target = q[i].second;
        for (int j = 0; j < N; j++) {
            if (dp[i][j] == INF) continue;
            if (pp == j) continue;
            pos[ph] = pp;
            pos[ph ^ 1] = j;
            for (auto [dist, npos] : moves(pos[h], target, pos[h ^ 1])) {
                dp[i + 1][npos] = min(dp[i + 1][npos], dp[i][j] + dist);
            }
        }
        ph = h;
        pp = target;
    }
    int ans = *min_element(dp[Q].begin(), dp[Q].end());
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 377

## D - Many Segments 2 

### Solution 1:  line sweep

1. just keep start point for each end point.

```cpp
int N, M;
vector<int> start;

void solve() {
    cin >> N >> M;
    start.assign(M + 1, 0);
    for (int i = 0; i < N; i++) {
        int l, r;
        cin >> l >> r;
        start[r] = max(start[r], l);
    }
    int ans = M * (M + 1) / 2, last = 0;
    for (int i = 1; i <= M; i++) {
        last = max(last, start[i]);
        ans -= last;
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## E - Permute K times 2 

### Solution 1:  directed graph, permutation cycles, binary exponentiation

1. Solves it in O(NlogK) time complexity which is fast enough. 

```cpp
int N, K;
vector<int> A, in_cycle, in_cycle_index;
vector<vector<int>> cycles;

int exponentiation(int b, int p, int m) {
    int res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}

void solve() {
    cin >> N >> K;
    A.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        A[i]--;
    }
    in_cycle.assign(N, -1);
    in_cycle_index.resize(N);
    for (int u : A) {
        if (in_cycle[u] != -1) continue;
        vector<int> cycle;
        int v = u;
        while (in_cycle[v] == -1) {
            in_cycle[v] = cycles.size();
            in_cycle_index[v] = cycle.size();
            cycle.emplace_back(v);
            v = A[v];
        }
        cycles.emplace_back(cycle);
    }
    for (int u : A) {
        int mod = cycles[in_cycle[u]].size();
        int x = (exponentiation(2, K, mod) - 1 + mod) % mod;
        int cur_cycle = in_cycle[u];
        int idx = (in_cycle_index[u] + x) % mod;
        cout << cycles[cur_cycle][idx] + 1 << " ";
    }
    cout << endl;
}

signed main() {
    solve();
    return 0;
}
```

## F - Avoid Queen Attack 

### Solution 1:  2d coordinates, geometry, math, lines

1. I represented everything in terms of y=mx+b line equations
1. With that can find (x, y) of intersection points between lines. 
1. And just using the lines can track the distinct (x, y) that the current line intersects with from prior. 
1. And use that to correctly adjust the over substracting from solution. 
1. Can determine if intersection is valid based on if it is within the chess board. 
1. Some minor transformations to make everything work within the cartesian coordinates. 

```cpp
struct Line {
    int x, y, m, b;
    Line() {}
    Line(int x, int y, int m, int b) : x(x), y(y), m(m), b(b) {}
    bool operator<(const Line& other) const {
        if (m == other.m) {
            return b < other.b;
        }
        return m < other.m;
    }
};

int N, M;
set<Line> lines;

int y_intercept(int x, int y, int m) {
    return y - m * x;
}

bool in_bounds(int x, int y) {
    return x >= 1 && x <= N && y >= 1 && y <= N;
}

bool whole(double x) {
    int v = x;
    return x == floor(x) &&  v == static_cast<int>(x);
}

pair<int, int> intersection(int m1, int b1, int m2, int b2) {
    double x = (double)(b2 - b1) / (m1 - m2);
    double y = m1 * x + b1;
    if (whole(x) && whole(y)) {
        return {x, y};
    }
    return {0, 0};
}

void solve() {
    cin >> N >> M;
    for (int i = 0; i < M; i++) {
        int y, x;
        cin >> y >> x;
        y = N - y + 1;
        for (int m = -1; m <= 1; m++) {
            int b = y_intercept(x, y, m);
            Line line = Line(x, y, m, b);
            lines.insert(line);
        }
        // vertical line
        lines.insert({x, y, -2, x});
    }
    int ans = N * N;
    vector<Line> arr(lines.begin(), lines.end());
    for (int i = 0; i < arr.size(); i++) {
        auto [x1, y1, m1, b1] = arr[i];
        if (m1 == -2 || m1 == 0) ans -= N;
        else if (m1 == 1) ans -= (N - max(x1, y1) + min(x1 - 1, y1 - 1) + 1);
        else ans -= (min(N - x1, y1 - 1) + min(x1 - 1, N - y1) + 1);
        set<pair<int, int>> vis;
        for (int j = 0; j < i; j++) {
            auto [x2, y2, m2, b2] = arr[j];
            if (m1 == m2) continue;
            int x, y;
            if (m1 == -2) { // vertical line
                x = b1;
                y = m2 * x + b2;
            } else if (m2 == -2) {
                x = b2;
                y = m1 * x + b1;
            } else {
                tie(x, y) = intersection(m1, b1, m2, b2);
            }
            vis.insert({x,  y});
        }
        for (const auto& [x, y] : vis) {
            if (!in_bounds(x, y)) continue;
            ans++;
        }
    }
    cout << ans << endl;
}

signed main() {
    solve();
    return 0;
}
```

## G - Edit to Match 

### Solution 1: dynamic programming with trie, prefix tree, string

1. The key is that you have only N characters in all strings. 
1. Observe that for any prefix that matches the current string, you need to know the smallest string seen before that has that prefix. 
1. The reason is the calculation is that you are going to perform x delete operations on current string, and y additions to get the string to match the previous smallest string that matches this prefix. 
1. dp on trie helps make this fast, cause you can store prefix in the tree. and iterate over the prefixes using a trie.

```cpp
const int INF = 1e9;
int N;

struct Node {
    int children[26];
    int val;
    Node() { 
        fill(children, children + 26, -1);
        val = INF;
    }
    void update(int x) {
        val = min(val, x);
    }
};

int unicode(const char& c) {
    return c - 'a';
}

vector<Node> trie;

void solve() {
    cin >> N;
    Node node;
    node.update(0);
    trie.emplace_back(node);
    for (int i = 0; i < N; i++) {
        string S;
        cin >> S;
        int cur = 0;
        int N = S.size();
        int ans = N;
        for (int len = 1; len <= N; len++) {
            int cv = unicode(S[len - 1]);
            if (trie[cur].children[cv] == -1) {
                Node n;
                trie[cur].children[cv] = trie.size();
                trie.emplace_back(n);
            }
            cur = trie[cur].children[cv];
            ans = min(ans, trie[cur].val + N - 2 * len);
            trie[cur].update(N);
        }
        cout << ans << endl;
    }
}

signed main() {
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 378

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 379

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 380

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 381

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```