# Atcoder Beginner Contest 400 - 499

# Atcoder Beginner Contest 400

## Takahashi the Wall Breaker

### Solution 1: transform 2d to 1d, dijkstra, priority queue, grid

```cpp
const int INF = (1 << 31) - 1;
int R, C, sr, sc, tr, tc;
vector<vector<char>> grid;
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minheap;

int map2dTo1d(int r, int c) {
    return r * C + c;
}

pair<int, int> map1dTo2d(int idx) {
    return {idx / C, idx % C};
}

vector<pair<int, int>> neighborhood(int r, int c) {
    return {{r - 1, c}, {r + 1, c}, {r, c - 1}, {r, c + 1}, {r - 2, c}, {r + 2, c}, {r, c - 2}, {r, c + 2}};
}

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

void solve() {
    cin >> R >> C;
    grid.resize(R, vector<char>(C));
    for (int r = 0; r < R; r++) {
        string s;
        cin >> s;
        for (int c = 0; c < C; c++) {
            grid[r][c] = s[c];
        }
    }
    cin >> sr >> sc >> tr >> tc;
    sr--, sc--, tr--, tc--;
    minheap.emplace(0, map2dTo1d(sr, sc));
    vector<int> dist(R * C, INF);
    while (!minheap.empty()) {
        auto [cost, idx] = minheap.top();
        minheap.pop();
        auto [r, c] = map1dTo2d(idx);
        if (r == tr && c == tc) {
            cout << cost << endl;
            return;
        }
        for (auto [nr, nc] : neighborhood(r, c)) {
            if (!inBounds(nr, nc)) continue;
            int ncost = cost;
            bool wall = false;
            if (nr > r && nr - r == 2) {
                if (grid[nr - 1][nc] == '#') wall = true;
            } else if (nr < r && r - nr == 2) {
                if (grid[nr + 1][nc] == '#') wall = true;
            } else if (nc > c && nc - c == 2) {
                if (grid[nr][nc - 1] == '#') wall = true;
            } else if (nc < c && c - nc == 2) {
                if (grid[nr][nc + 1] == '#') wall = true;
            }
            if (grid[nr][nc] == '#') wall = true;
            ncost += wall;
            int i = map2dTo1d(nr, nc);
            if (dist[i] <= ncost) continue;
            dist[i] = ncost;
            minheap.emplace(ncost, i);

        }
    }
    cout << -1 << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Ringos Favorite Numbers 3

### Solution 1: sieve of eratosthenes, count distinct primes, binary search 

1. You just need to do the square root value up to 10^6, cause it squared i 10^12. 

```cpp
const int MAXN = 1e6 + 5;
int64 N;
bool isprime[MAXN];
int primesCount[MAXN];
vector<int64> values;

void sieve(int n) {
    fill(isprime, isprime + n, true);
    isprime[0] = isprime[1] = false;
    for (int64 p = 2; p < n; p++) {
        if (isprime[p]) {
            for (int64 i = p; i < n; i += p) {
                isprime[i] = false;
                primesCount[i]++;
            }
        }
    }
}

void precompute() {
    for (int i = 1; i < MAXN; i++) {
        if (primesCount[i] == 2) {
            values.emplace_back(static_cast<int64>(i) * i);
        }
    }
}

void solve() {
    cin >> N;
    int64 ans = *prev(upper_bound(values.begin(), values.end(), N));
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    sieve(MAXN);
    precompute();
    sort(values.begin(), values.end());
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Atcoder Beginner Contest 401

## Reachable Set

### Solution 1: undirected graph, sets, dfs

```cpp
int N, M;
vector<vector<int>> adj;
vector<int> ans;
set<int> in, out;

void dfs(int u, int k) {
    for (int v : adj[u]) {
        if (in.count(v)) continue;
        out.insert(v);
    }
    if (in.size() == k) ans[k] = out.size();
    in.insert(u);
    if (out.empty()) return;
    int v = *out.begin();
    out.erase(v);
    dfs(v, max(v, k));
}

void solve() {
    cin >> N >> M;
    adj.assign(N, vector<int>());
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    ans.assign(N, -1);
    dfs(0, 0);
    for (int x : ans) {
        cout << x << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Add One Edge 3

### Solution 1: reroot tree diameter, dfs, reroot, binary search, tree dp

```cpp
int64 N1, N2;
int64 ans;
vector<vector<int>> adj1, adj2;
vector<int64> mx1, mx2, node1, node2, par, dist1, dist2;
int64 diam;

// mx1[u] = maximum distance from u to any other node and mx2 (second max)
void dfs1(const vector<vector<int>> &adj, int u, int p = -1) {
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs1(adj, v, u);
        if (mx1[v] + 1 > mx1[u]) {
            mx2[u] = mx1[u];
            mx1[u] = mx1[v] + 1;
            node2[u] = node1[u];
            node1[u] = v;
        } else if (mx1[v] + 1 > mx2[u]) {
            mx2[u] = mx1[v] + 1;
            node2[u] = v;
        }
    }
}

// Calculates the diameter
void dfs2(const vector<vector<int>> &adj, int u, vector<int64> &dist, int p = -1) {
    diam = max(diam, mx1[u] + par[u]);
    dist.emplace_back(max(mx1[u], par[u]));
    for (int v : adj[u]) {
        if (v == p) continue;
        par[v] = par[u];
        if (v != node1[u]) par[v] = max(par[v], mx1[u]);
        else par[v] = max(par[v], mx2[u]);
        par[v]++;
        dfs2(adj, v, dist, u);
    }
}

void solve() {
    cin >> N1;
    adj1.assign(N1, vector<int>());
    for (int i = 0; i < N1 - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj1[u].emplace_back(v);
        adj1[v].emplace_back(u);
    }
    cin >> N2;
    adj2.assign(N2, vector<int>());
    for (int i = 0; i < N2 - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj2[u].emplace_back(v);
        adj2[v].emplace_back(u);
    }
    diam = ans = 0;
    mx1.assign(N1, 0);
    mx2.assign(N1, 0);
    node1.assign(N1, 0);
    node2.assign(N1, 0);
    par.assign(N1, 0);
    dfs1(adj1, 0);
    dfs2(adj1, 0, dist1);
    mx1.assign(N2, 0);
    mx2.assign(N2, 0);
    node1.assign(N2, 0);
    node2.assign(N2, 0);
    par.assign(N2, 0);
    dfs1(adj2, 0);
    dfs2(adj2, 0, dist2);
    sort(dist1.begin(), dist1.end());
    sort(dist2.begin(), dist2.end());
    vector<int64> psum(N2 + 1, 0);
    for (int i = 0; i < N2; i++) {
        psum[i + 1] = psum[i] + dist2[i];
    }
    for (int64 x : dist1) {
        int i = lower_bound(dist2.begin(), dist2.end(), diam - x) - dist2.begin();
        ans += (N2 - i) * x + psum[N2] - psum[i];
        ans += N2 - i;
        ans += i * diam;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Push Simultaneously

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 402

## Line Crossing

### Solution 1: modulo, map, prefix sum

```cpp
int N, M;

void solve() {
    cin >> N >> M;
    map<int, int> freq;
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        freq[(u + v) % N]++;
    }
    int64 ans = 0, psum = 0;
    for (auto &[k, v] : freq) {
        ans += v * psum;
        psum += v;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Payment Required

### Solution 1:  dynamic programming, recurrence relation, expectation value, probability, bitmask

1. move from when you have 0 yen to X yen, so in the direction of increasing yen remaining to spend. 
1. And use a bitmask to represent which problems have been solved in that state already. 
1. And you try a submission of problem i, and that will involve probability of success and that of failure which builds upon prior expectation values.

```cpp
int N, X;
vector<int> C, S;
vector<long double> P;
vector<vector<long double>> dp;

bool isSet(int mask, int i) {
    return (mask >> i) & 1;
}

void solve() {
    cin >> N >> X;
    C.resize(N);
    S.resize(N);
    P.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> S[i] >> C[i] >> P[i];
        P[i] /= 100;
    }
    dp.assign(X + 1, vector<long double>(1 << N, 0));
    for (int i = 0; i <= X; i++) {
        for (int mask = 0; mask < (1 << N); mask++) {
            for (int j = 0; j < N; j++) {
                if (isSet(mask, j) || i < C[j]) continue;
                // try submission to problem j
                long double failure = dp[i - C[j]][mask] * (1 - P[j]);
                long double success = P[j] * (S[j] + dp[i - C[j]][mask | (1 << j)]);
                dp[i][mask] = max(dp[i][mask], failure + success);
            }
        }
    }
    cout << fixed << setprecision(10) << dp[X][0] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Path to Integer

### Solution 1: grid, binary search, exponentiation, modulo, bitmask, 

1. convert path in grid of down and right movements into a bitmask
1. And find this location which is a diagonal through the grid where each path must cross exaclty one location
1. So create this diagonal from (i, N - 1 - i), which is a diagonal from top right to bottom left
1. And then compute for the bitmask of N - 1 moves from (0, 0) to one of the cells on the diagonal and the same from (N - 1, N - 1) to (i, N - 1 - i)
1. Since each cell in diagonal is on a unique row, you can organize these by rows, and so from the top path landing in row r and bottom path landing in row r, you know these two will join.
1. So you iterate over one of the sets which is 2^n iterations, and then you binary search through the second, but the modulus doesn't interfere surprisingly, you can use it, that is you say value is x, so you look for M - x in the sorted second set, but find the largest that is strictly less than M - x, and you can do that with binary search.  Anything larger obviously will reduce when you combine (x + y) % M, so you want the largest that is less than M - x.

```cpp
int N, M;
vector<vector<int>> grid;

int64 exponentiation(int64 b, int64 p, int64 m) {
    int64 res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}

bool isSet(int mask, int i) {
    return (mask >> i) & 1;
}

void solve() {
    cin >> N >> M;
    grid.resize(N, vector<int>(N));
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> grid[i][j];
            grid[i][j] *= exponentiation(10, 2 * N - i - j - 2, M);
            grid[i][j] %= M;
        }
    }
    vector<vector<int>> sums1(N, vector<int>()), sums2(N, vector<int>());
    for (int mask = 0; mask < (1 << (N - 1)); mask++) {
        int r = 0, c = 0, sum = 0;
        sum += grid[r][c];
        for (int i = 0; i < N - 1; i++) {
            if (isSet(mask, i)) {
                r++;
            } else {
                c++;
            }
            sum = (sum + grid[r][c]) % M;
        }
        sums1[r].emplace_back(sum);
    }
    for (int mask = 0; mask < (1 << (N - 1)); mask++) {
        int r = N - 1, c = N - 1, sum = 0;
        for (int i = 0; i < N - 1; i++) {
            sum = (sum + grid[r][c]) % M;
            if (isSet(mask, i)) {
                r--;
            } else {
                c--;
            }
        }
        sums2[r].emplace_back(sum);
    }
    int ans = 0;
    for (int i = 0; i < N; i++) {
        sort(sums2[i].begin(), sums2[i].end());
        for (int x : sums1[i]) {
            int target = M - x;
            int j = lower_bound(sums2[i].begin(), sums2[i].end(), target) - sums2[i].begin();
            if (j > 0) j--;
            ans = max(ans, (x + sums2[i][j]) % M);
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 403

## Forbidden Difference

### Solution 1: dynamic programming, residue classes, modular arithmetic

1. The key is to observe that you should perform the calculation on each residue class separately and sum up the minimum deletes for each residue class.
1. The residue classes are independent of each other. 
1. The residue class is i mod D, so everything with same remainder when divided by D is in the same class, because these are going to be the elements that have distance D between adjacent elements. the transitions are very easy then cause it is either you keep or delete current element, which dicates what the prior state it can transition from.

```cpp
const int MAXN = 1e6 + 5;
int N, D;
int freq[MAXN];

void solve() {
    cin >> N >> D;
    memset(freq, 0, sizeof(freq));
    int ans = 0;
    for (int i = 0; i < N; i++) {
        int x;
        cin >> x;
        freq[x]++;
    }
    if (!D) {
        for (int i = 0; i < MAXN; i++) {
            ans += max(0, freq[i] - 1);
        }
        cout << ans << endl;
        return;
    }
    // reside classes
    for (int i = 0; i < D; i++) {
        int dpKeep = 0, dpDelete = 0, ndpKeep = 0, ndpDelete = 0;
        for (int j = i; j < MAXN; j += D) {
            ndpKeep = dpDelete;
            ndpDelete = min(dpKeep, dpDelete) + freq[j];
            swap(dpKeep, ndpKeep);
            swap(dpDelete, ndpDelete);
        }
        ans += min(dpKeep, dpDelete);
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Forbidden Prefix

### Solution 1: trie data structure, prefix tree, string

1. few methods on trie can be used to solve this problem.

```cpp
struct Node {
    int children[26];
    bool isLeaf;
    int cnt;
    void init() {
        memset(children, 0, sizeof(children));
        isLeaf = false;
        cnt = 0;
    }
};
struct Trie {
    vector<Node> trie;
    void init() {
        Node root;
        root.init();
        trie.emplace_back(root);
    }
    void insert(const string& s) {
        int cur = 0;
        for (const char &c : s) {
            int i = c - 'a';
            if (trie[cur].children[i]==0) {
                Node root;
                root.init();
                trie[cur].children[i] = trie.size();
                trie.emplace_back(root);
            }
            cur = trie[cur].children[i];
            trie[cur].cnt++;
        }
        trie[cur].isLeaf= true;
    }
    bool startsWith(const string& s) {
        int cur = 0;
        for (const char &c : s) {
            int i = c - 'a';
            if (!trie[cur].children[i]) return false;
            cur = trie[cur].children[i];
            if (trie[cur].isLeaf) return true;
        }
        return false;
    }
    int countPrefix(const string& s) {
        int cur = 0;
        for (const char &c : s) {
            int i = c - 'a';
            if (!trie[cur].children[i]) return 0;
            cur = trie[cur].children[i];
        }
        return trie[cur].cnt;
    }
    void eraseCount(const string& s, int val) {
        int cur = 0;
        for (const char &c : s) {
            int i = c - 'a';
            if (!trie[cur].children[i]) return;
            cur = trie[cur].children[i];
            trie[cur].cnt -= val;
        }
        queue<int> q;
        q.emplace(cur);
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            trie[node].cnt = 0;
            for (int i = 0; i < 26; i++) {
                if (trie[node].children[i] && trie[trie[node].children[i]].cnt) {
                    q.emplace(trie[node].children[i]);
                }
            }
        }
    }
};

int N;

void solve() {
    cin >> N;
    Trie trieX, trieY;
    trieX.init();
    trieY.init();
    int ans = 0;
    for (int i = 0; i < N; i++) {
        int t;
        string s;
        cin >> t >> s;
        if (t == 1) {
            int countPrefix = trieY.countPrefix(s);
            ans -= countPrefix;
            trieY.eraseCount(s, countPrefix);
            trieX.insert(s);
        } else {
            bool foundPrefix = trieX.startsWith(s);
            if (!foundPrefix) {
                trieY.insert(s);
                ans++;
            }
        }
        cout << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Shortest One Formula

### Solution 1: mathematical expression, dynamic programming, parallel dp, string manipulation

1. minimize the length of the expression that evaluates to dp(i), and you need dp1 and dp2 to handle order of operations kinda. 

```cpp
const int MAXN = 2e3 + 5;
int N;
vector<string> dp1, dp2;

int lenOnes(int x) {
    int ans = 0;
    while (x > 0) {
        if (x % 10 != 1) return 0;
        x /= 10;
        ans++;
    }
    return ans;
}

void update(string &s, const string &t) {
    if (t.size() < s.size()) {
        s = t;
    }
}

void solve() {
    cin >> N;
    dp1.assign(N + 1, string(MAXN, '1'));
    dp2.assign(N + 1, string(MAXN, '1'));
    for (int i = 1; i <= N; i++) {
        int len = lenOnes(i);
        if (len > 0) {
            dp1[i] = string(len, '1');
            dp2[i] = string(len, '1');
        }
        for (int j = 1; j < i; j++) {
            update(dp1[i], dp1[j] + '+' + dp1[i - j]);
            if (i % j == 0) {
                update(dp2[i], dp2[j] + '*' + dp2[i / j]);
            }
        }
        update(dp2[i], string(1, '(') + dp1[i] + ')');
        update(dp1[i], dp2[i]);
    }
    if (dp1[N].size() < dp2[N].size()) {
        cout << dp1[N] << endl;
        return;
    }
    cout << dp2[N] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 404

## Bowls and Beans

### Solution 1: dynamic programming, fewest jumps between ones

```cpp
const int INF = 1e9;
int N;
vector<int> A, C, dp;

void solve() {
    cin >> N;
    A.assign(N, 0);
    C.assign(N, 0);
    dp.assign(N, INF);
    for (int i = 1; i < N; ++i) {
        cin >> C[i];
    }
    for (int i = 1; i < N; ++i) {
        cin >> A[i];
    }
    for (int i = N - 1; i >= 0; i--) {
        if (A[i]) {
            dp[i] = 0;
            break;
        }
    }
    for (int i = N - 1; i >= 0; i--) {
        if (dp[i] == INF) continue;
        for (int j = i - 1; j >= max(0, i - C[i]); j--) {
            dp[j] = min(dp[j], dp[i] + 1);
            if (A[j]) break;
        }
    }
    cout << dp[0] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Specified Range Sums

### Solution 1: Ushi game, linear programming problem, bellman ford algorithm, directed graph, negative edge weights, shortest path

```cpp
const int INF = 1e9;
int N, M;
vector<vector<int>> edges;

// Returns a vector of shortest distances from src to every node 0…n-1,
// or an empty vector if a negative cycle is reachable.
vector<int64> bellmanFord(int src) {
    vector<int64> dist(N, INF);
    dist[src] = 0;
    // Relax up to n-1 times, early exit if no change
    for (int i = 0; i < N - 1; i++) {
        bool any_relaxed = false;
        for (const auto& e : edges) {
            int u = e[0], v = e[1], w = e[2];
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                any_relaxed = true;
            }
        }
        if (!any_relaxed) break;
    }
    // Check for negative cycles
    for (const auto& e : edges) {
        int u = e[0], v = e[1], w = e[2];
        if (dist[u] + w < dist[v]) {
            // Negative cycle detected
            return {};
        }
    }
    return dist;
}

void solve() {
    cin >> N >> M;
    N++;
    for (int i = 0; i < M; i++) {
        int l, r, w;
        cin >> l >> r >> w;
        edges.emplace_back(vector<int>{r, l - 1, -w});
        edges.emplace_back(vector<int>{l - 1, r, w});
    }
    for (int i = 1; i < N; i++) {
        edges.emplace_back(vector<int>{i, i - 1, -1});
    }
    vector<int64> dist = bellmanFord(N - 1);
    if (dist.empty()) {
        cout << -1 << endl;
        return;
    }
    cout << -dist[0] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 405

## Fruit Lineup

### Solution 1: combinatorics, multiplicative inverse, modulo

## Key Idea: Fix the Position of the Last Apple

Let $N = A + B + C + D$.

Because apples must come before bananas and grapes, the **last apple** plays a key role.

Let $i$ be the position of the **last apple** in the arrangement.

Since we need at least $A$ positions to place the apples, and oranges can be mixed before or after apples, the valid range for $i$ is:

$$
i \in [A,\ A + B]
$$

---

## Counting the Prefix (Positions 1 to i)

This prefix contains:

- **All $A$ apples**, including the one in position $i$
- **$i - A$ oranges**, since the other $A - 1$ apples go in the first $i - 1$ slots

To choose which positions hold the apples (with the last one fixed at $i$):

$$
\text{Ways to place apples} = \binom{i - 1}{A - 1}
$$

The remaining $i - A$ positions are oranges.

---

## Counting the Suffix (Positions $i+1$ to $N$)

This suffix contains:

- **All $C$ bananas**
- **The remaining $B - (i - A)$ oranges**
- **All $D$ grapes**

Constraint: **All oranges must come before all grapes**, and **bananas can go anywhere** in the suffix.

If you choose which $C$ of the $N - i$ suffix positions are bananas, then:

- The non-banana slots will automatically be filled first with the remaining oranges, then with the grapes, which has only **1 valid ordering** (since oranges must come before grapes).

So the number of valid suffix arrangements is:

$$
\text{Ways to place bananas} = \binom{N - i}{C}
$$

---

## Final Formula

For each valid $i$ from $A$ to $A + B$, we compute:

$$
\text{total} += 
\binom{i - 1}{A - 1}
\times
\binom{N - i}{C}
$$

Then take the result modulo $998244353$.

---

## Time and Space Complexity

- Precomputing factorials and inverse factorials: **$O(N)$**
- Loop from $A$ to $A + B$: **$O(B)$**
- Each step uses constant time binomial computations: **$O(1)$**

**Overall complexity: $O(N + B)$**

Efficient enough for $N$ up to several million.


---


```cpp
const int64 MOD = 998244353, MAXN = 4e6 + 5;
int A, B, C, D;

int64 inv(int i, int64 m) {
  return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

vector<int64> fact, inv_fact;

void factorials(int n, int64 m) {
    fact.assign(n + 1, 1);
    inv_fact.assign(n + 1, 0);
    for (int i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % m;
    }
    inv_fact.end()[-1] = inv(fact.end()[-1], m);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
    }
}

int64 choose(int n, int r, int64 m) {
    if (n < r) return 0;
    return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
}

// A is apple, B is orange, C is banana, D is grape
void solve() {
    cin >> A >> B >> C >> D;
    int N = A + B + C + D;
    int64 ans = 0;
    for (int i = A; i <= A + B; i++) {
        int64 c1 = choose(i - 1, A - 1, MOD);
        int64 c2 = choose(N - i, C, MOD);
        ans = (ans + c1 * c2) % MOD;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    factorials(MAXN, MOD);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 406

## Popcount Sum 3

### Solution 1: dynamic programming, binomial coefficients, combinatorics

Bitmask Sum Calculator with Popcount Constraints

C[i][j]: Binomial coefficient table, stores number of bitstrings of length i with j bits set.

dp[i][j]: Sum of all numbers < 2^i with exactly j bits set.

pow2[i]: Precomputed powers of 2 modulo MOD.

ans += dp[i][K - cur]; // Sum from numbers with lower bits
ans += suffix * C[i][K - cur]; // Add values formed by prefix + combinations of remaining bits

```cpp
const int MOD = 998244353, MAXN = 60;
int64 N;
int K;
int C[MAXN + 1][MAXN + 1]; //c[i][j]=(the number of x  s.t. 0<=x<(2^i), popcount(x)=j) for 0<=j<=i<=60
int dp[MAXN + 1][MAXN + 1]; //s[i][j]=(the sum    of x  s.t. 0<=x<(2^i), popcount(x)=j) for 0<=j<=i<=60
int pow2[MAXN + 1]; //pow2[i]=(2^i)%MOD for 0<=i<=60

void precompute() {
    pow2[0] = 1;
    for (int i = 1; i <= MAXN; i++) {
        pow2[i] = (pow2[i - 1] * 2LL) % MOD;
    }
    C[0][0] = 1;
    for (int i = 0; i < MAXN; i++) {
        for (int j = 0; j <= i; j++) {
            C[i + 1][j + 1] += C[i][j];
            C[i + 1][j + 1] %= MOD;
            C[i + 1][j] += C[i][j];
            C[i + 1][j] %= MOD;
            dp[i + 1][j + 1] += dp[i][j];
            dp[i + 1][j + 1] %= MOD;
            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + static_cast<int64>(C[i][j]) * pow2[i] % MOD) % MOD;
            dp[i + 1][j] += dp[i][j];
            dp[i + 1][j] %= MOD;
        }
    }
}

bool isSet(int64 mask, int i) {
    return (mask >> i) & 1;
}

void solve() {
    cin >> N >> K;
    int ans = 0, cur = 0, suffix = 0;
    for (int i = MAXN - 1; i >= 0; i--) {
        if (!isSet(N, i)) continue;
        if (cur <= K) {
            ans = (ans + dp[i][K - cur]) % MOD;
            ans = (ans + static_cast<int64>(suffix) * C[i][K - cur] % MOD) % MOD;
        }
        cur++;
        suffix = (suffix + (1LL << i)) % MOD;
    }
    if (cur == K) {
        ans = (ans + suffix) % MOD;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    precompute();
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Compare Tree Weights

### Solution 1: euler tour, dfs, fenwick tree

```cpp
int N, Q, timer;
vector<vector<int>> adj;
vector<int> values, tin, tout, par;
vector<pair<int, int>> edges;

void dfs(int u, int p = -1) {
    tin[u] = timer++;
    par[u] = p;
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
    }
    tout[u] = timer - 1;
}

int neutral = 0;
struct FenwickTree {
    vector<int> nodes;
    void init(int n) {
        nodes.assign(n + 1, neutral);
    }
    void update(int idx, int val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }
    int query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : 0;
    }
    int query(int idx) {
        int result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }
};

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
        edges.emplace_back(u, v);
    }
    values.assign(N, 1);
    tin.resize(N);
    tout.resize(N);
    par.assign(N, -1);
    dfs(0);
    FenwickTree ft;
    ft.init(N);
    for (int i = 0; i < N; i++) {
        ft.update(tin[i] + 1, values[i]); // 1-indexed
    }
    cin >> Q;
    while (Q--) {
        int type;
        cin >> type;
        if (type == 1) {
            int u, x;
            cin >> u >> x;
            u--;
            ft.update(tin[u] + 1, x);
            values[u] += x;
        } else {
            int idx;
            cin >> idx;
            idx--;
            auto [u, v] = edges[idx];
            if (par[v] == u) swap(u, v);
            int ans = abs(ft.query(tin[0] + 1, tout[0] + 1) - 2 * ft.query(tin[u] + 1, tout[u] + 1));
            cout << ans << endl;
        }
    }
}
```

# Atcoder Beginner Contest 407

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 408

## Minimum Or

### Solution 1: greedy bitmask, union find, connectivity, forbidden bitmask

Minimize a bitwise-aggregate over a subset, under some feasibility constraint.

Find a subset (e.g. path, spanning tree, etc.) such that the bitwise-OR (or AND) of weights is minimized (or maximized), subject to a structural constraint (e.g. connectivity), and the weights are bounded (e.g. < 2³⁰).

### Algorithmic Observations
- Greedy bitwise optimization (MSB -> LSB).
- Connectivity or feasibility checking using DSU or BFS/DFS.
- Offline filtering of edges/items based on bitmasks.
- A subtype of greedy algorithms where each bit is treated independently due to the nature of bitwise OR/AND.
- Each step tries to forbid one bit (from high to low) and checks structural feasibility using tools like DSU.

### Problem is Monotonic in Bit-Forbidding
- If I disallow this bit, does a valid solution still exist?
- If I disallow all edges with bit b = 1, can I still connect node 1 to N?
- This monotonicity is what allows a greedy approach — if a solution exists under stricter constraints, it also exists under looser ones.

Because each bit you successfully forbid (i.e., force to be zero in the final result) narrows the set of usable edges. You’re cumulatively tightening the constraint:

```cpp
const int INF = (1LL << 31) - 1;
int N, M;
vector<vector<pair<int, int>>> adj;

struct Edge {
    int u, v, w;
    Edge() {}
    Edge(int u, int v, int w) : u(u), v(v), w(w) {}
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

struct UnionFind {
    vector<int> parents, size;
    UnionFind(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};

void solve() {
    cin >> N >> M;
    vector<Edge> edges(M);
    for (int i = 0; i < M; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        edges[i] = {u, v, w};
    }
    int forbiddenMask = 0;
    for (int i = 30; i >= 0; i--) {
        UnionFind dsu(N);
        int nmask = forbiddenMask | (1 << i);
        for (const Edge &edge : edges) {
            if ((nmask & edge.w) == 0) dsu.same(edge.u, edge.v);
        }
        if (!dsu.same(0, N - 1)) continue;
        forbiddenMask = nmask; // We can forbid this bit
    }
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        if ((forbiddenMask & (1 << i)) == 0) {
            ans |= (1 << i);
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Athletic

### Solution 1: dynamic programming, greedy, range max query, segment tree optimization

Dynamic programming with range queries
technique: segment tree + sliding window DP

if I end my chain at value i, what is the best chain‐length I can achieve?

We want to build a chain of values, picking elements from the array under two constraints:
- Their values increase by at least D,
- Their positions in the array are within a radius of R.

This is solved by a combination of:
- Dynamic Programming (DP) to track the best possible chain ending at each value.
- A Segment Tree to efficiently look up the best previous chain within the allowed index window.

Segment Tree
- Used to quickly query the maximum dp[j] value among all j values that:
- Have been processed (i.e., j ≤ i - D),
- Have pos[j] within R distance of pos[i] (index window).

dp[i] = max(dp[j] + 1), for j in some range [L(i), R(i)]
This is the key to use segment tree to speed up the dp transitions. 

```cpp
const int INF = (1LL << 31) - 1;
int N, D, R;
vector<int> A, pos, dp;

struct SegmentTree {
    int size;
    int neutral = -INF;
    vector<int> nodes;

    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, neutral);
    }

    int func(int x, int y) {
        return max(x, y);
    }

    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }

    void update(int segment_idx, int val) {
        segment_idx += size;
        nodes[segment_idx] = val;
        segment_idx >>= 1;
        ascend(segment_idx);
    }

    int query(int left, int right) {
        left += size, right += size;
        int res = neutral;
        while (left <= right) {
           if (left & 1) {
                // res on left
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                // res on right
                res = func(nodes[right], res);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};

void solve() {
    cin >> N >> D >> R;
    pos.assign(N, -1);
    A.resize(N);
    dp.assign(N, 0);
    SegmentTree seg;
    seg.init(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        pos[--A[i]] = i;
    }
    for (int i = 0; i < N; i++) {
        if (i - D >= 0) {
            seg.update(pos[i - D], dp[i - D]);
        }
        int l = max(0, pos[i] - R), r = min(N - 1, pos[i] + R);
        int mx = seg.query(l, r);
        dp[i] = max(dp[i], mx + 1);
    }
    int ans = *max_element(dp.begin(), dp.end());
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 409

## Pair Annihilation

### Solution 1: dfs, tree traversal, weighted tree, subtree sum

```cpp
int64 ans;
int N;
vector<int> values;
vector<vector<pair<int, int>>> adj;
int64 dfs(int u, int p = -1) {
    int bal = values[u];
    for (auto [v, w] : adj[u]) {
        if (v == p) continue;
        int64 ret = dfs(v, u);
        ans += abs(ret) * w;
        bal += ret;
    }
    return bal;
}

void solve() {
    cin >> N;
    adj.assign(N, vector<pair<int, int>>());
    values.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> values[i];
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--, v--;
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    ans = 0;
    dfs(0);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Connecting Points

### Solution 1: union find, online queries, min heap, manhattan distance, graph on grid

Dynamic Manhattan-MST with Connectivity Queries

Overview
Maintains a growing set of 2D points and supports three operations in an online fashion:
Add a point
Extract the next shortest edge that connects two previously unconnected components (i.e. advance the Minimum Spanning Forest by one edge)
Check connectivity between any two points

Under the hood it’s essentially an incremental Kruskal’s algorithm over a complete graph (with Manhattan‐distance weights), augmented with union-find for connectivity.

```cpp
int N, Q;
vector<int> X, Y;

struct Event {
    int u, v, d;
    Event(int u, int v, int d) : u(u), v(v), d(d) {}
    bool operator<(const Event &other) const {
        return other.d < d;
    }
};

struct UnionFind {
    vector<int> parents, size;
    UnionFind(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    void unite(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
        }
    }

    bool same(int i, int j) {
        return find(i) == find(j);
    }
};

int manhattan(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

void solve() {
    cin >> N >> Q;
    priority_queue<Event> minheap;
    X.resize(N);
    Y.resize(N);
    for (int i = 0; i < N; i++) {
        cin >> X[i] >> Y[i];
    }
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            int dist = manhattan(X[i], Y[i], X[j], Y[j]);
            minheap.emplace(i, j, dist);
        }
    }
    UnionFind dsu(N + Q);
    while (Q--) {
        int t;
        cin >> t;
        if (t == 1) { 
            int x, y;
            cin >> x >> y;
            X.emplace_back(x);
            Y.emplace_back(y);
            for (int i = 0; i < N; i++) {
                int dist = manhattan(X[i], Y[i], x, y);
                minheap.emplace(i, N, dist);
            }
            N++;
        } else if (t == 2) {
            int ans = -1;
            while (!minheap.empty()) {
                auto [u, v, d] = minheap.top();
                if (ans != -1 && d > ans) break;
                minheap.pop();
                if (!dsu.same(u, v)) {
                    ans = d;
                    dsu.unite(u, v);
                }
            }
            cout << ans << endl;
        } else {
            int u, v;
            cin >> u >> v;
            u--, v--;
            if (dsu.same(u, v)) {
                cout << "Yes" << endl;
            } else {
                cout << "No" << endl;
            }
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 410

## Battles in a Row

### Solution 1: 

```cpp
int N, H, M;

void solve() {
    cin >> N >> H >> M;
    vector<int> dp(M + 1, -1), ndp(M + 1, -1);
    dp[M] = H;
    for (int i = 0; i < N; i++) {
        int h, m;
        cin >> h >> m;
        ndp.assign(M + 1, -1);
        for (int j = 0; j <= M; j++) {
            ndp[j] = max(ndp[j], dp[j] - h);
            if (j >= m) ndp[j - m] = max(ndp[j - m], dp[j]);
        }
        swap(dp, ndp);
        int v = *max_element(dp.begin(), dp.end());
        if (v < 0) {
            cout << i << endl;
            return;
        }
    }
    cout << N << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Balanced Rectangles

### Solution 1: matrix, transpose, prefix sum, frequency counting

Involves analyzing the math of the matrix, and realizing that one of the dimensions must be rather small that is square root of multiple of both
And just let that be the rows, and we can always use transposition if we want to switch the rows and columns

This uses frequency of prefix sums to count how many arrays that have sum equal to zero.  The trick here is that you need to use an array and make sure it can reset the values in O(C) time, which is possible, but you do need an offset to allow the negative values.  But they are limited to something like -R*C to R*C

```cpp
int R, C;
vector<vector<char>> mat;

vector<vector<char>> transpose(const vector<vector<char>>& mat) {
    vector<vector<char>> ans(C, vector<char>(R));
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            ans[j][i] = mat[i][j];
        }
    }
    return ans;
}

void solve() {
    cin >> R >> C;
    mat.assign(R, vector<char>(C));
    for (int i = 0; i < R; ++i) {
        string s;
        cin >> s;
        for (int j = 0; j < C; ++j) {
            mat[i][j] = s[j];
        }
    }
    if (R > C) {
        mat = transpose(mat);
        swap(R, C);
    }

    vector<int> freq(2 * R * C + 1, 0);
    int offset = R * C;
    int64 ans = 0;
    for (int i = 0; i < R; i++) {
        vector<int> cnt(C, 0);
        for (int j = i; j < R; j++) {
            for (int k = 0; k < C; k++) {
                if (mat[j][k] == '#') cnt[k]++;
                else cnt[k]--;
            }
            int psum = 0;
            freq[offset] = 1;
            for (int k = 0; k < C; k++) {
                psum += cnt[k];
                ans += freq[psum + offset];
                freq[psum + offset]++;

            }
            // reset
            psum = 0;
            for (int k = 0; k < C; k++) {
                psum += cnt[k];
                freq[psum + offset] = 0;
            }
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Atcoder Beginner Contest 411

## Emax

### Solution 1: probability, combinatorics, modular arithmetic, multiplicative inverse, probability trick

```cpp
const int64 MOD = 998244353;
int N;

int64 inv(int i, int64 m) {
    return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

int64 exponentiation(int64 b, int64 p, int64 m) {
    int64 res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}

void solve() {
    cin >> N;
    vector<int> values;
    vector<vector<int>> A(N, vector<int>(6, 0));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < 6; j++) {
            cin >> A[i][j];
            values.emplace_back(A[i][j]);
        }
    }
    sort(values.begin(), values.end());
    values.erase(unique(values.begin(), values.end()), values.end());
    int M = values.size();
    vector<vector<int>> updates(M, vector<int>());
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < 6; j++) {
            int idx = lower_bound(values.begin(), values.end(), A[i][j]) - values.begin();
            updates[idx].emplace_back(i);
        }
    }
    vector<int> prod(M + 1, 1), cnt(N, 0);
    int cntZero = N, prevProd = 0, ans = 0;
    for (int i = 0; i < M; i++) {
        prod[i + 1] = prod[i];
        for (int j : updates[i]) {
            if (!cnt[j]) cntZero--;
            else prod[i + 1] = (1LL * prod[i + 1] * inv(cnt[j], MOD)) % MOD;
            cnt[j]++;
            prod[i + 1] = (1LL * prod[i + 1] * cnt[j]) % MOD;
        }
        if (cntZero) continue;
        int delta = (prod[i + 1] - prevProd + MOD) % MOD;
        int cur = 1LL * values[i] * delta % MOD;
        ans = (ans + cur) % MOD;
        prevProd = prod[i + 1];
    }
    int den = exponentiation(6, N, MOD);
    ans = (1LL * ans * inv(den, MOD)) % MOD;
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Contraction

### Solution 1:  undirected graph, edge contraction, small-to-large technique

- Stoer–Wagner global minimum-cut: edge-contraction phase needs repeated merges and edge-count updates in a simple graph.
- Hierarchical clustering: you can greedily contract edges to build a tree (e.g. single linkage).
- Graph coarsening/preprocessing for multilevel solvers: shrink parts of the graph to reduce size before refinement.
- Dynamic connectivity under contraction: if all you ever do is contract (and never split), this handles it cleanly.

```cpp
int N, M, Q;
vector<set<int>> adj;
vector<pair<int, int>> edges;
vector<int> vertex;
vector<vector<int>> vertices;

void solve() {
    cin >> N >> M;
    adj.assign(N, set<int>());
    edges.resize(M);
    vertices.assign(N, vector<int>());
    vertex.assign(N, 0);
    for (int i = 0; i < N; i++) {
        vertices[i].emplace_back(i);
        vertex[i] = i;
    }
    for (int i = 0; i < M; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].insert(v);
        adj[v].insert(u);
        edges[i] = {u, v};
    }
    cin >> Q;
    while (Q--) {
        int idx;
        cin >> idx;
        idx--;
        // perform contraction on edge idx, by merging vertex v into u
        auto [u, v] = edges[idx];
        u = vertex[u];
        v = vertex[v];
        if (vertices[u].size() + adj[u].size() < vertices[v].size() + adj[v].size()) { // small-to-large technique
            swap(u, v);
        }
        if (!adj[u].count(v)) {
            cout << M << endl;
            continue;
        }
        // merge v into u
        for (int w : vertices[v]) {
            vertex[w] = u;
            vertices[u].emplace_back(w);
        }
        vertex[v] = u;
        vertices[u].emplace_back(v);
        adj[v].erase(u);
        adj[u].erase(v);
        for (int w : adj[v]) {
            adj[w].erase(v);
            if (adj[u].count(w)) {
                M--;
                continue;
            }
            adj[u].insert(w);
            adj[w].insert(u);
        }
        adj[v].clear();
        vertices[v].clear();
        M--;
        cout << M << endl;
    }
    
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 412

## LCM Sequence

### Solution 1: prime sieve, segmented sieve, prime powers

```cpp
int64 L, R;

int64 ceil(int64 x, int64 y) {
    return (x + y - 1) / y;
}

int segmentedSievePrimePowers(int64 l, int64 r) {
    int ans = 0;
    int64 lim = sqrt(r);
    vector<bool> marked(lim + 1, false);
    vector<int64> primes;
    for (int64 i = 2; i <= lim; ++i) {
        if (marked[i]) continue;
        primes.emplace_back(i);
        for (int64 j = i * i; j <= lim; j += i) {
            marked[j] = true;
        }
    }
    vector<bool> isPrime(r - l + 1, true);
    for (int64 p : primes) {
        for (int64 i = max(p * p, ceil(l, p) * p); i <= r; i += p) {
            isPrime[i - l] = false;
        }
    }
    if (l == 1) isPrime[0] = false;
    for (int i = 0; i < r - l + 1; ++i) {
        if (isPrime[i]) ans++;
    }
    for (int64 p : primes) {
        for (int64 i = p * p; i <= r; i *= p) {
            if (i < l) continue;
            ans++;
        }
    }
    return ans;
}

void solve() {
    cin >> L >> R;
    int ans = 1 + segmentedSievePrimePowers(L + 1, R);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Socks 4

### Solution 1: expected value, dynamic programming, expected value recurrence, state transition, prefix sums

### State and sorting
So the states to me are what index I'm in the array, so which sock I'm holding at the moment, so then the transition is I can transition to hold the same sock or to some other sock j where j > i, because we always want to hold the sock with the largest frequency in the drawer. 
We sort the sock colors so that:
$$A_1 \le A_2 \le \cdots \le A_N,$$
and keep track of which index corresponds to the initial color $C$. Let state $i$ represent ``holding a sock whose color is at index $i$ in the sorted list''.

Define the total number of socks (including the one initially outside the drawer) as:
$$S = \sum_{k=1}^{N} A_k$$
When we are in state $i$, there are $A_i - 1$ socks of color $i$ remaining in the drawer.

### First-Step Recurrence
From state $i$, Takahashi draws a sock from the drawer. The expected number of total draws until termination is:
- Always at least $1$ draw.
- With probability $\dfrac{A_i - 1}{S}$, he draws the same color and terminates (absorbing state, so 0 further cost).
- With probability $\dfrac{A_j}{S}$ for $j < i$, he draws a weaker color and chooses to stay in state $i$.
- With probability $\dfrac{A_j}{S}$ for $j > i$, he draws a stronger color and moves to state $j$.

Hence the recurrence relation becomes:
$$E[X_i] = 1 + \sum_{j<i} \frac{A_j}{S} \cdot E[X_i] + \sum_{j>i} \frac{A_j}{S} \cdot E[X_j]$$

So now we can write a recurrence relation for this quite easily. 

$$E[X_i] = 1 + \frac{A_i - 1}{S} \cdot E[X_{end}] + \sum_{j=0}^{i-1} \frac{A_j}{S} \cdot E[X_i] + \sum_{j=i+1}^N \frac{A_j}{S} \cdot E[X_j]$$

If you rearrange to solve for $E[X_i]$

$$E[X_i] = \frac{1 + \sum_{j=i+1}^N \frac{A_j}{S} \cdot E[X_j]}{1 - \sum_{j=0}^{i-1} \frac{A_j}{S}}$$

Which we can convert these to prefix and suffix sums to be honest to get time complexity to O(N) roughly. 

$$E[X_i] = \frac{1 + \text{suf}(i + 1)}{1 - \text{pref}(i)}$$ 

Now what are the base cases
$E[X_{end}] = 0$ and 

$$E[X_n] = 1 + \sum_{j=0}^{N-1} E[X_N] $$
Solve and you get 
$$E[X_N] = \frac{1}{1 - pref(N)}$$

Now you can compute the answer by working your way from the right side (the socks with highest frequency or base case) towards the one you want to solve for $E[X_{start}]$

```cpp
const int64 MOD = 998244353;
int N, C;
vector<int64> A;

int64 inv(int i, int64 m) {
    return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}

void solve() {
    cin >> N >> C;
    --C;
    A.resize(N);
    int total = 0;
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
        total += A[i];
    }
    A[C]++;
    int s = A[C];
    sort(A.begin(), A.end());
    int startIndex = lower_bound(A.begin(), A.end(), s) - A.begin();
    int suf = 0, pref = 0;
    for (int i = 0; i < N; ++i) {
        int64 term = A[i] * inv(total, MOD) % MOD;
        pref = (pref + term) % MOD;
    }
    vector<int> E(N, 0);
    for (int i = N - 1; i >= startIndex; --i) {
        int64 invTotal = inv(total, MOD);
        int64 weight = A[i] * invTotal % MOD;
        pref = (pref - weight + MOD) % MOD;
        int64 x = (suf + 1) % MOD;
        int64 y = (1 - pref + MOD) % MOD;
        int64 term = x * inv(y, MOD) % MOD;
        E[i] = term;
        int64 sufDelta = term * weight % MOD;
        suf = (suf + sufDelta) % MOD;
    }
    cout << E[startIndex] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 413

## Reverse 2^i

### Solution 1: 

```cpp

```

## No Passage

### Solution 1: 4-connectivity, grid, multisource bfs, backwards search

```cpp
const int INF = numeric_limits<int>::max();
int R, C, K;
vector<vector<int>> grid;

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

vector<pair<int, int>> neighborhood(int r, int c) {
    return {{r - 1, c}, {r + 1, c}, {r, c - 1}, {r, c + 1}};
}

int numberOfAssignedNeighbors(int r, int c) {
    int cnt = 0;
    for (auto [nr, nc] : neighborhood(r, c)) {
        if (!inBounds(nr, nc) || grid[nr][nc] == INF) continue;
        ++cnt;
    }
    return cnt;
}

void solve() {
    cin >> R >> C >> K;
    grid.assign(R, vector<int>(C, INF));
    queue<pair<int, int>> q;
    for (int i = 0; i < K; ++i) {
        int r, c;
        cin >> r >> c;
        --r, --c;
        grid[r][c] = 0;
    }
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            if (grid[r][c] != INF) continue; // already assigned
            int cnt = numberOfAssignedNeighbors(r, c);
            if (cnt > 1) {
                q.emplace(r, c);
            }
        }
    }
    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();
        if (grid[r][c] != INF) continue; // already assigned
        vector<int> cands;
        for (auto [nr, nc] : neighborhood(r, c)) {
            if (!inBounds(nr, nc)) continue;
            cands.emplace_back(grid[nr][nc]);
        }
        sort(cands.begin(), cands.end());
        int val = cands[1];
        grid[r][c] = val + 1;
        for (auto [nr, nc] : neighborhood(r, c)) {
            if (!inBounds(nr, nc) || grid[nr][nc] != INF) continue;
            // Check if this cell can be added to the queue
            int cnt = numberOfAssignedNeighbors(nr, nc);
            if (cnt > 1) {
                q.emplace(nr, nc);
            }
        }
    }
    int64 ans = 0;
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            if (grid[r][c] == INF) continue;
            ans += grid[r][c];
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

## Big Banned Grid

### Solution 1:  8-connectivity, dfs, grid traversal, bitmask, set

```cpp
int R, C, K;
set<pair<int, int>> banned, vis;

int decode(int r, int c) {
    int mask = 0;
    if (r == 0 || c == C - 1) mask |= 1; // top or right
    if (r == R - 1 || c == 0) mask |= 2; // bottom or left
    return mask;
}

int dfs(int r, int c) {
    if (vis.count({r, c})) return 0;
    vis.emplace(r, c);
    int mask = decode(r, c);
    for (int dr = -1; dr <= 1; ++dr) {
        for (int dc = -1; dc <= 1; ++dc) {
            if (dr == 0 && dc == 0) continue; 
            int nr = r + dr, nc = c + dc;
            if (banned.count({nr, nc})) {
                mask |= dfs(nr, nc);
            }
        }
    }
    return mask;
}

void solve() {
    cin >> R >> C >> K;
    for (int i = 0; i < K; ++i) {
        int r, c;
        cin >> r >> c;
        --r, --c;
        banned.emplace(r, c);
    }
    for (auto [r, c] : banned) {
        if (vis.count({r, c})) continue;
        int mask = dfs(r, c);
        if (mask == 3) {
            cout << "No" << endl;
            return;
        }
    }
    cout << "Yes" << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

# Atcoder Beginner Contest 414

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```

# Atcoder Beginner Contest 415

##

### Solution 1: 

```cpp

```

##

### Solution 1: 

```cpp

```