# Meta Hacker Cup 2016

# Round 2

## 

```py

```

## Problem B: Carnival Coins

N = 2, K = 1, p = 0.5
 
flip 2 coins, what's the probability of one head
0.5*0.5 + 0.5*0.5 = 0.5
flip 2 coins what's the probability of two heads
0.5*0.5 = 0.25

flip 2 coins the probability of at least one being head is 0.75
flip 1 coins the probability of at least one being head is 0.5

N = 10, K = 5, p  = 0.9, tails is 0.1
flip 10 coins, what's the probability of at least 5 heads
(10 5)*0.9^5*0.1^5 + (10 6)*0.9^6*0.1^4 + (10 7)*0.9^7*0.1^3 + (10 8)*0.9^8*0.1^2 + (10 9)*0.9^9*0.1^1 + (10 10)*0.9^10*0.1^0
P(X>=5) = P(X=5)+P(X=6)+P(X=7)+P(X=8)+P(X=9)+P(X=10)

flip 9 coins at least 5 heads and flip 1 coin at least 5 heads
P(X>=5) = P(X=5)+P(X=6)+P(X=7)+P(X=8)+P(X=9)

flip 5 coins at least 5 heads and flip 5 coins at least 5 heads
P(X>=5) = P(X=5) 

expectation value for indicator variable is just summation of the probabilities
value is just 1 for success, in this case success is winning a prize, and it is 0 for a failure to win a prize, so that doesn't add anything so it is just the sum of probabilies

N = 3000, K = 50, p = 0.123
flip 3000 coins, what's the probability of at least 50 heads
P(X>=50) = P(X=50)+P(X=51)+...+P(X=3000)
flip 2950 coins and flip 50 coins what's the probability
P(X>=50) = P(X=50)+P(X=51)+...+P(X=2950) + P(X=50)
flip 2949 coins and flip 51 coins
P(X=50)+P(X=51)+...+P(X=2949) + P(X=50) + P(X=51)
flip 2900 coins and flip 100 coins or flip 2900 coins and flip 50 coins and flip 50 coins
max(P(X=50)+P(X=51)+...+P(X=2900) + P(X=50) + P(X=51) + P(X=52) + ... + P(X=100), P(X=50)+P(X=51)+...+P(X=2900) + P(X=50) + P(X=50))

x1+x2+x3+...+xn = N
P(x1, X>=K) + P(x2, X>=K) + P(x3, X>=K) + ... + P(xn, X>=K)

so you just need to calculate all the ways to split N into 
1 part, 2 parts, 3 parts, 4 parts and so on


do this N // K times




prefix sum precomputed, in order to get range over sums in O(1) time for instance get sum from L = 50 to R = 2900
wait the binomial coefficient is going to be changing, cause you are changing the number of trials but holding the number of successes constant


for each n from K to N
you can can precalculate the probablity for each n trials and m successes
O(n^2) time complexity

P(n, X>=K) = P(n, K) + P(n, K + 1) + ... + P(n, n)





probability of getting k successes or heads
n is number of trials
P(X = k) 

standard dp to calculate probability of j heads when i coins flipped
dp[i][j] = probability when i coins flipped with j heads

dp[0][0] = 1
dp[i][j] = dp[i - 1][j - 1] * p + dp[i - 1][j] * (1 - p)


dp2[i] = maximum expected number of prizes after flipping i coins


given i coins at current step, take a partition step j
where i - j is the number of coins to flip, so say you flip these coins,
you need how many heads
dp2[0] = 0
dp2[i] = dp2[j] + dp[i - j] where 0 <= j <= i

so suppose you have the maximum expected value for flipping j coins, but you have remaining i - j coins to flip, so you want to find the max of those over all possible number of heads right? 

Note be careful when input double type it causes issue, just avoid read() all together it seems to work.

```cpp
const double SMALL = numeric_limits<double>::min();
vector<vector<double>> prob;
vector<double> dp, expected;

void solve() {
    int N, K;
    double p;
    cin >> N >> K >> p;
    prob.assign(N + 1, vector<double>(N + 1, 0.0));
    dp.assign(N + 1, 0.0);
    expected.assign(N + 1, SMALL);
    prob[0][0] = 1.0;
    for (int i = 1; i <= N; i++ ) { // flip i coins
        for (int j = 0; j <= i; j++) { // exactly j heads
            prob[i][j] = (1 - p) * prob[i - 1][j];
            if (j > 0) prob[i][j] += p * prob[i - 1][j - 1];
        }
    }
    // dp[i] calculates the probability when flipping i coins to get at least K heads
    for (int i = 1; i <= N; i++) {
        for (int j = K; j <= i; j++) {
            dp[i] += prob[i][j];
        }
    }
    expected[0] = 0.0;
    // maximum expected value
    for (int i = 1; i <= N; i++) { // up to i coins flippped
        for (int j = 0; j < i; j++ ) { 
            expected[i] = max(expected[i], expected[j] + dp[i - j]);
        }
    }
    printf("%.12f\n", expected.end()[-1]);
}

int32_t main() {
	ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    string in = "inputs/" + name;
    string out = "outputs/" + name;
    freopen(in.c_str(), "r", stdin);
    freopen(out.c_str(), "w", stdout);
    int T;
    cin >> T;
    for (int i = 1; i <= T ; i++) {
        printf("Case #%d", i);
        solve();
    }
    return 0;
}
```

## 

```py

```

##

```py

```

##

```py

```

##

```py

```

##

```py

```