# Meta Hacker Cup 2023

# Practice Round

## Cheeseburger Corollary 1

```cpp
void solve(int t) {
    int S = read(), D = read(), K = read();
    int buns = 2 * (S + D);
    int patties = S + 2 * D;
    int decker = min(buns - 1, patties);
    string res = decker >= K ? "YES" : "NO";
    cout << "Case #" << t << ": " << res << endl;
}

int32_t main() {
	ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    string in = "inputs/" + name;
    string out = "outputs/" + name;
    freopen(in.c_str(), "r", stdin);
    freopen(out.c_str(), "w", stdout);
    int T = read();
    for (int i = 1; i <= T ; i++) {
        solve(i);
    }
    return 0;
}
```

## Cheeseburger Corollary 2

```cpp
void solve(int t) {
    int A = read(), B = read(), C = read();
    int res = 0LL;
    res = max(res, C / A);
    res = max(res, 2 * (C / B) - 1);
    if (C >= A) {
        res = max(res, 2 * ((C - A) / B) + 1);
    }
    if (C >= 2 * A) {
        res = max(res, 2 * ((C - 2 * A) / B) + 2);
    }
    cout << "Case #" << t << ": " << res << endl;
}

int32_t main() {
	ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    string in = "inputs/" + name;
    string out = "outputs/" + name;
    freopen(in.c_str(), "r", stdin);
    freopen(out.c_str(), "w", stdout);
    int T = read();
    for (int i = 1; i <= T ; i++) {
        solve(i);
    }
    return 0;
}

```

## Dim Sum Delivery

### Solution 1:  ad hoc

```cpp
void solve(int t) {
    int R = read(), C = read(), A = read(), B = read();
    string res = R > C ? "YES" : "NO";
    cout << "Case #" << t << ": " << res << endl;
}

int32_t main() {
	ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    string in = "inputs/" + name;
    string out = "outputs/" + name;
    freopen(in.c_str(), "r", stdin);
    freopen(out.c_str(), "w", stdout);
    int T = read();
    for (int i = 1; i <= T ; i++) {
        solve(i);
    }
    return 0;
}
```

## Two Apples a Day

### Solution 1:  two pointers + 3 candidate Ks to check + math 

Use observation that the summation of 2*N elements should be divisible by N.

```cpp
vector<int> arr;
int N;

bool check(int x, int k) {
    if (x <= 0) return false;
    int left = 0, right = 2 * N - 2;
    bool used = false;
    while (left < right) {
        if (arr[left] + arr[right] != k && !used) {
            if (arr[left] + x == k) {
                left++;
                used = true;
            } else if (x + arr[right] == k) {
                right--;
                used = true;
            } else {
                return false;
            }
        }
        else if (arr[left] + arr[right] != k) {
            return false;
        }
        left++;
        right--;
    }
    if (left == right && (arr[left] + x != k || used)) return false;
    return true;
}

int solve() {
    N = read();
    int M = 2 * N - 1;
    arr.resize(M);
    for (int i = 0; i < M; i++) {
        arr[i] = read();
    }
    int res = LLONG_MAX;
    if (N == 1) {
        return 1;
    }
    sort(arr.begin(), arr.end());
    int S = accumulate(arr.begin(), arr.end(), 0LL);
    vector<int> vals{arr[0] + arr.end()[-2], arr[0] + arr.end()[-1], arr[1] + arr.end()[-1]};
    for (int K : vals) {
        int x = K * N - S;
        if (check(x, K)) res = min(res, x);
    }
    if (res == LLONG_MAX) {
        res = -1;
    }
    return res;
}
int32_t main() {
	ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    string in = "inputs/" + name;
    string out = "outputs/" + name;
    freopen(in.c_str(), "r", stdin);
    freopen(out.c_str(), "w", stdout);
    int T = read();
    for (int i = 1; i <= T ; i++) {
        cout << "Case #" << i << ": " << solve() << endl;
    }
    return 0;
}
```

## Road to Nutella

The knowledge needed for this problem is graph theory, 2-edge connected components, bridge trees, bipartite graph is 2 colorable or in other words contain no odd length cycle. 

The idea is to get all the non-bipartite 2-edge connected components, can call these blocks.  

The bridge tree is a conversion of graph to a tree where the edges are the bridge edges and the nodes are 2-edge connected components (blocks).  A 2-edge connected component could be bipartite or non-bipartite, this can indicate if it has odd length cycle within it or not.  

Convert to bridge tree by using Tarjan's bridge finding algorithm.

For each node pair ai, bi for the simple path connecting them within the bridge tree, find the path minimum along the simple path from ai to bi and their corresponding blocks in the bridge tree. The value you are minimizing is that for each block in the tree you need to calculate the shortest distance to a non bipartite block in the tree.  

Can calculate the shortest distance by using a multisource bfs from each non bipartite block in the tree and storing the shortest distance to each other block. 

Then you have these values so you want the path minimum query for each ai to bi block.  You can solve this efficiently in a tree with binary jumping/lifting, heavy light decomposition or link-cut tree

```py

```