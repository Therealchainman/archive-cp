# Everybody Codes 2025


# Quest 1: Whispers in the Shell

## Part 2

### Solution 1: modulo 

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

void solve() {
    string S1, S2;
    getline(cin, S1);
    getline(cin, S2);
    getline(cin, S2);
    vector<string> A = process(S1, ','), B = process(S2, ',');
    int N = A.size();
    int pos = 0;
    for (const string& s : B) {
        char dir = s[0];
        int x = stoi(s.substr(1));
        if (dir == 'R') {
            pos = (pos + x) % N;
        } else {
            pos = (pos - x + N) % N;
        }
    }
    cout << A[pos] << endl;
}
```

## Part 3

### Solution 1: modulo, swapping

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

void solve() {
    string S1, S2;
    getline(cin, S1);
    getline(cin, S2);
    getline(cin, S2);
    vector<string> A = process(S1, ','), B = process(S2, ',');
    int N = A.size();
    for (const string& s : B) {
        char dir = s[0];
        int x = stoi(s.substr(1));
        int j = 0;
        if (dir == 'R') {
            j = x % N;
        } else {
            j = -x;
            while (j < 0) j += N;
        }
        swap(A[0], A[j]);
    }
    cout << A[0] << endl;
}
```

# Quest 2: From Complex to Clarity

## Part 1

### Solution 1: brute force

```cpp
void multiply(pair<int, int>& a, const pair<int, int>& b) {
    int first = a.first * b.first - a.second * b.second;
    int second = a.first * b.second + a.second * b.first;
    a = {first, second};
}
void add(pair<int, int>& a, const pair<int, int>& b) {
    a.first += b.first;
    a.second += b.second;
}
void divide(pair<int, int>& a, const pair<int, int>& b) {
    a.first /= b.first;
    a.second /= b.first;
}

void solve() {
    pair<int, int> A = {162, 59}, B = {10, 10};
    pair<int, int> number;
    for (int i = 0; i < 3; ++i) {
        multiply(number, number);
        divide(number, B);
        add(number, A);
    }
    cout << number.first << " " << number.second << endl;
}
```

## Part 3

### Solution 1: brute force

Part 2 is the same just change to increment by 10 instead of 1. 

```cpp
void multiply(pair<int64, int64>& a, const pair<int64, int64>& b) {
    int64 first = a.first * b.first - a.second * b.second;
    int64 second = a.first * b.second + a.second * b.first;
    a = {first, second};
}
void add(pair<int64, int64>& a, const pair<int64, int64>& b) {
    a.first += b.first;
    a.second += b.second;
}
void divide(pair<int64, int64>& a, const pair<int64, int64>& b) {
    a.first /= b.first;
    a.second /= b.first;
}

bool inBounds(const pair<int64, int64>& p) {
    if (p.first > 1000000 || p.second > 1000000 || p.first < -1000000 || p.second < -1000000) return false;
    return true;
}

bool simulation(const pair<int64, int64>& A) {
    pair<int64, int64> number = {0, 0}, B = {100000, 100000};
    for (int i = 0; i < 100; ++i) {
        multiply(number, number);
        divide(number, B);
        add(number, A);
        if (!inBounds(number)) return false;
    }
    return true;
}

void solve() {
    pair<int64, int64> A = {-79047, 14068};
    pair<int64, int64> tl = {-79047, 14068}, tr = {1000, 1000};
    add(tr, A);
    int ans = 0;
    for (int64 x = tl.first; x <= tr.first; x++) {
        for (int64 y = tl.second; y <= tr.second; y++) {
            pair<int64, int64> point = {x, y};
            if (simulation(point)) ans++;
        }
    }
    cout << ans << endl;
}
```

# Quest 3: The Deepest Fit

## Part 1

### Solution 1: unique and accumulate

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    A.erase(unique(A.begin(), A.end()), A.end());
    int64 ans = accumulate(A.begin(), A.end(), 0LL);
    cout << ans << endl;
}
```

## Part 2

### Solution 1: unique and accumulate first 20

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    A.erase(unique(A.begin(), A.end()), A.end());
    int64 ans = accumulate(A.begin(), A.begin() + 20, 0LL);
    cout << ans << endl;
}
```

## Part 3

### Solution 1: max frequency

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    vector<int> freq(*max_element(A.begin(), A.end()) + 1, 0);
    for (int x : A) {
        freq[x]++;
    }
    int ans = *max_element(freq.begin(), freq.end());
    cout << ans << endl;
}
```

# Quest 4: Teeth of the Wind

## Part 3

### Solution 1: circle, radius, ratios

I skipped the part 1 and 2, because they are super simple just like using ratio of the first and last gear, can do it without code even, just calculator. 

```cpp
void solve() {
    long double m = 100.0L;
    vector<pair<long double, long double>> gears;
    string line;
    while (getline(cin, line)) {
        auto bar = line.find('|');
        if (bar == string::npos) {
            gears.emplace_back(stold(line), stold(line));
        } else {
            long double left = stold(line.substr(0, bar));
            long double right = stold(line.substr(bar + 1));
            gears.emplace_back(left, right);
        }
    }
    int N = gears.size();
    long double cur = 1.0L;
    for (int i = 0; i + 1 < N; ++i) {
        long double leftRadius = gears[i].second;
        long double rightRadius = gears[i + 1].first;
        long double ratio = leftRadius / rightRadius;
        cur *= ratio;
    }
    cur *= m;
    int64 ans = floorl(cur);
    cout << ans << endl;
}
```

# Quest 5: Fishbone Order

## Part 2

### Solution 1: rules, greedy placement

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

struct Spine {
    bool l, r;
    int v;
    Spine(bool l, int v, bool r) : l(l), v(v), r(r) {}
};

string buildSword(const vector<int>& A) {
    vector<Spine> spines;
    for (int x : A) {
        bool placed = false;
        for (auto &spine : spines) {
            if (x < spine.v && !spine.l) {
                spine.l = true;
                placed = true;
                break;
            } else if (x > spine.v && !spine.r) {
                spine.r = true;
                placed = true;
                break;
            }
        }
        if (placed) continue;
        spines.emplace_back(false, x, false);
    }
    string ans;
    for (auto &spine : spines) {
        ans += to_string(spine.v);
    }
    return ans;
}

void solve() {
    string line;
    vector<vector<int>> A;
    vector<int64> swords;
    while (getline(cin, line)) {
        int idx = line.find(':');
        int swordId = stoi(line.substr(0, idx));
        A.emplace_back(process(line.substr(idx + 1), ','));
        string sword = buildSword(A.back());
        swords.emplace_back(stoll(sword));
    }
    sort(swords.begin(), swords.end());
    int64 ans = swords.back() - swords.front();
    cout << ans << endl;
}
```

## Part 3

### Solution 1: sorting, rules, custom comparator, 

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

struct Spine {
    int l, v, r;
    Spine(int l, int v, int r) : l(l), v(v), r(r) {}
};

struct Sword {
    int id;
    int64 quality;
    vector<int64> levels;
    Sword() : quality(0) {}
    Sword(int id, int64 quality, const vector<int64>& levels) : id(id), quality(quality), levels(levels) {}
    bool operator<(const Sword& other) const {
        if (quality != other.quality) return quality > other.quality;
        for (int i = 0; i < min(levels.size(), other.levels.size()); ++i) {
            if (levels[i] != other.levels[i]) return levels[i] > other.levels[i];
        }
        if (levels.size() != other.levels.size()) return levels.size() > other.levels.size();
        return id > other.id;
    }
};

Sword buildSword(int id, const vector<int>& A) {
    vector<Spine> spines;
    for (int x : A) {
        bool placed = false;
        for (auto &spine : spines) {
            if (x < spine.v && spine.l == -1) {
                spine.l = x;
                placed = true;
                break;
            } else if (x > spine.v && spine.r == -1) {
                spine.r = x;
                placed = true;
                break;
            }
        }
        if (placed) continue;
        spines.emplace_back(-1, x, -1);
    }
    string q;
    for (auto &spine : spines) {
        q += to_string(spine.v);
    }
    vector<int64> levels;
    for (auto &spine : spines) {
        string s;
        if (spine.l != -1) s += to_string(spine.l);
        s += to_string(spine.v);
        if (spine.r != -1) s += to_string(spine.r);
        levels.emplace_back(stoll(s));
    }
    Sword sword(id, stoll(q), levels);
    return sword;
}

void solve() {
    string line;
    vector<Sword> swords;
    while (getline(cin, line)) {
        int idx = line.find(':');
        int swordId = stoi(line.substr(0, idx));
        vector<int> A = process(line.substr(idx + 1), ',');
        Sword sword = buildSword(swordId, A);
        swords.emplace_back(sword);
    }
    sort(swords.begin(), swords.end());
    int64 ans = 0;
    for (int i = 0; i < swords.size(); ++i) {
        ans += static_cast<int64>(swords[i].id) * (i + 1);
    }
    cout << ans << endl;
}
```

# Quest 6: Mentorship Matrix

## Part 3

### Solution 1: sliding window, counting pairs, reversing array

```cpp
int64 count(const vector<char>& arr) {
    int M = arr.size();
    vector<int> mentors(26, 0);
    int64 ans = 0;
    for (int i = 0; i < M; ++i) {
        char ch = arr[i];
        if (isupper(ch)) {
            mentors[ch - 'A']++;
        } else {
            ans += mentors[ch - 'a'];
        }
        if (i >= 1000) {
            char old_ch = arr[i - 1000];
            if (isupper(old_ch)) {
                mentors[old_ch - 'A']--;
            }
        }
    }
    return ans;
}

void solve() {
    string S;
    cin >> S;
    int N = S.size();
    vector<char> arr;
    arr.reserve(1000 * N);
    for (int i = 0; i < 1000; ++i) {
        for (char ch : S) arr.emplace_back(ch);
    }
    int64 ans = count(arr);
    reverse(arr.begin(), arr.end());
    ans += count(arr);
    debug(ans, "\n");
}
```

# Quest 7: Namegraph

## Part 2

### Solution 1: strings, adjacency list, bfs, queue

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

map<char, vector<char>> adj;

bool check(const string& S) {
    int N = S.size();
    for (int i = 1; i < N; ++i) {
        const char u = S[i - 1];
        const char v = S[i];
        if (adj.find(u) == adj.end()) return false;
        const vector<char> &vec = adj[u];
        if (find(vec.begin(), vec.end(), v) == vec.end()) return false;
    }
    return true;
}

void solve() {
    string line;
    getline(cin, line);
    vector<string> A = process(line, ',');
    int N = A.size();
    getline(cin, line);
    while (getline(cin, line)) {
        int idx = line.find('>');
        char u = line.substr(0, idx - 1)[0];
        vector<string> vs = process(line.substr(idx + 2), ',');
        for (const string& v : vs) {
            adj[u].emplace_back(v[0]);
        }
    }
    int64 ans = 0;
    for (int i = 0; i < N; ++i) {
        if (check(A[i])) {
            ans += (i + 1);
        }
    }
    cout << ans << endl;
}
```

## Part 3

### Solution 1: strings, adjacency list, bfs, queue

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

unordered_map<char, vector<char>> adj;
unordered_set<string> names;

bool check(const string& S) {
    int N = S.size();
    for (int i = 1; i < N; ++i) {
        const char u = S[i - 1];
        const char v = S[i];
        if (adj.find(u) == adj.end()) return false;
        const vector<char> &vec = adj[u];
        if (find(vec.begin(), vec.end(), v) == vec.end()) return false;
    }
    return true;
}

void generate(const string& pref) {
    queue<string> q;
    q.emplace(pref);
    while (!q.empty()) {
        string s = q.front();
        q.pop();
        if (s.size() > 11) continue;
        if (s.size() >= 7) names.insert(s);
        char u = s.back();
        for (char v : adj[u]) {
            q.emplace(s + v);
        }
    }
}

void solve() {
    string line;
    getline(cin, line);
    vector<string> A = process(line, ',');
    int N = A.size();
    getline(cin, line);
    while (getline(cin, line)) {
        int idx = line.find('>');
        char u = line.substr(0, idx - 1)[0];
        vector<string> vs = process(line.substr(idx + 2), ',');
        for (const string& v : vs) {
            adj[u].emplace_back(v[0]);
        }
    }
    for (int i = 0; i < N; ++i) {
        if (!check(A[i])) continue;
        generate(A[i]);
    }
    int ans = names.size();
    cout << ans << endl;
}
```

# Quest 8: The Art of Connection

## Part 2

### Solution 1: modular arithmetic, pairs

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

void solve() {
    string line;
    getline(cin, line);
    int n = 256;
    // int n = 8;
    vector<int> A = process(line, ',');
    int N = A.size();
    vector<pair<int, int>> pairs;
    int ans = 0;
    for (int i = 1; i < N; ++i) {
        int u = A[i - 1], v = A[i];
        if (u > v) swap(u, v);
        // u < v so u to v
        for (auto &[x, y] : pairs) {
            // skip if one of the endpoints is touching
            if (x == u || x == v || y == u || y == v) continue;
            int cnt = 0;
            if (x > u && x < v) cnt++;
            if (y > u && y < v) cnt++;
            if (cnt == 1) ans++;
        }
        pairs.emplace_back(u, v);
    }
    debug(ans, "\n");
}
```

## Part 3

### Solution 1: modular arithmetic, pairs

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

void solve() {
    string line;
    getline(cin, line);
    int n = 256;
    vector<int> A = process(line, ',');
    int N = A.size();
    vector<pair<int, int>> pairs;
    int ans = 0;
    for (int i = 1; i < N; ++i) {
        int u = A[i - 1], v = A[i];
        if (u > v) swap(u, v);
        pairs.emplace_back(u, v);
    }
    for (int u = 1; u <= n; ++u) {
        for (int v = u + 1; v <= n; ++v) {
            int cur = 0;
            for (auto &[x, y] : pairs) {
                // If this thread is exactly the same as the cut, it is fully cut
                if ((x == u && y == v) || (x == v && y == u)) {
                    cur++;
                    continue;
                }
                int cnt = 0;
                if (x > u && x < v) cnt++;
                if (y > u && y < v) cnt++;

                // Touching only at endpoints does NOT count
                if (x == u || x == v || y == u || y == v) continue;
                if (cnt == 1) cur++;
            }
            ans = max(ans, cur);
        }
    }
    debug(ans, "\n");
}
```

# Quest 9: Encoded in the Scales

## Part 2

### Solution 1: iteration

```cpp
int64 calc(const vector<char>& A, const vector<char>& B, const vector<char>& C) {
    int N = A.size();
    assert(A.size() == B.size() && B.size() == C.size());
    int64 cnt1 = 0, cnt2 = 0;
    for (int i = 0; i < N; ++i) {
        if (A[i] != C[i] && B[i] != C[i]) return 0;
        if (A[i] == C[i]) cnt1++;
        if (B[i] == C[i]) cnt2++;
    }
    return cnt1 * cnt2;
}

void solve() {
    string line;
    vector<vector<char>> arr;
    while (getline(cin, line)) {
        int idx = line.find(':');
        line = line.substr(idx + 1);
        vector<char> chars(line.begin(), line.end());
        arr.emplace_back(chars);
    }
    int64 ans = 0;
    int N = arr.size();
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            for (int k = 0; k < N; ++k) {
                if (i == k || j == k) continue;
                int64 res = calc(arr[i], arr[j], arr[k]);
                ans += res;
            }
        }
    }
    debug(ans, "\n");
}
```

## Part 3

### Solution 1: undirected graph, tree, size of connected components, dfs

```cpp
bool check(const vector<char>& A, const vector<char>& B, const vector<char>& C) {
    int N = A.size();
    assert(A.size() == B.size() && B.size() == C.size());
    for (int i = 0; i < N; ++i) {
        if (A[i] != C[i] && B[i] != C[i]) return false;
    }
    return true;
}

vector<vector<int>> adj;
vector<bool> vis;
int curb, cura;

void dfs(int u, int p = -1) {
    vis[u] = true;
    curb++;
    cura += u + 1;
    for (int v : adj[u]) {
        if (v == p) continue;
        if (vis[v]) continue;
        dfs(v, u);
    }
}

void solve() {
    string line;
    vector<vector<char>> arr;
    while (getline(cin, line)) {
        int idx = line.find(':');
        line = line.substr(idx + 1);
        vector<char> chars(line.begin(), line.end());
        arr.emplace_back(chars);
    }
    int N = arr.size();
    adj.assign(N, vector<int>());
    for (int i = 0; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            for (int k = 0; k < N; ++k) {
                if (i == k || j == k) continue;
                if (!check(arr[i], arr[j], arr[k])) continue;
                adj[i].emplace_back(k);
                adj[k].emplace_back(i);
                adj[j].emplace_back(k);
                adj[k].emplace_back(j);
            }
        }
    }
    vis.assign(N, false);
    int bs = 0, ans = 0;
    for (int i = 0; i < N; ++i) {
        if (vis[i]) continue;
        curb = cura = 0;
        dfs(i);
        if (curb > bs) {
            bs = curb;
            ans = cura;
        }
    }
    debug(ans, "\n");
}
```

# Quest 10: Feast on the Board

## Part 1

### Solution 1:

```cpp
int R, C;
vector<vector<char>> grid;

// represent chess moves
pair<int, int> findChar(char target) {
    for (int r = 0; r < (int)grid.size(); r++) {
        for (int c = 0; c < (int)grid[r].size(); c++) {
            if (grid[r][c] == target) {
                return {r, c};
            }
        }
    }
    return {-1, -1}; // not found
}

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

vector<pair<int, int>> neighborhood(int r, int c) {
    // chess knight moves
    vector<pair<int, int>> moves = {
        {2, 1}, {2, -1}, {-2, 1}, {-2, -1},
        {1, 2}, {1, -2}, {-1, 2}, {-1, -2}
    };
    vector<pair<int, int>> neighbors;
    for (auto [dr, dc] : moves) {
        int nr = r + dr;
        int nc = c + dc;
        if (inBounds(nr, nc)) {
            neighbors.emplace_back(nr, nc);
        }
    }
    return neighbors;
}

void solve() {
    string line;
    while (getline(cin, line)) {
        vector<char> row(line.begin(), line.end());
        grid.emplace_back(row);
    }
    R = grid.size();
    C = grid[0].size();
    auto [sr, sc] = findChar('D');
    int step = 0;
    queue<pair<int, int>> q;
    q.emplace(sr, sc);
    int ans = 0;
    while (!q.empty() && step < 4) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            auto [r, c] = q.front();
            q.pop();
            for (auto [nr, nc] : neighborhood(r, c)) {
                if (grid[nr][nc] == 'D') continue;
                if (grid[nr][nc] == 'S') ans++;
                q.emplace(nr, nc);
                grid[nr][nc] = 'D';
            }
        }
        step++;
    }
    debug(ans, "\n");
}

```

## Part 2

### Solution 1:

```cpp
int R, C;
vector<vector<char>> grid;

// represent chess moves
pair<int, int> findChar(char target) {
    for (int r = 0; r < (int)grid.size(); r++) {
        for (int c = 0; c < (int)grid[r].size(); c++) {
            if (grid[r][c] == target) {
                return {r, c};
            }
        }
    }
    return {-1, -1}; // not found
}

set<pair<int, int>> findAllChar(char target) {
    set<pair<int, int>> positions;
    for (int r = 0; r < (int)grid.size(); r++) {
        for (int c = 0; c < (int)grid[r].size(); c++) {
            if (grid[r][c] == target) {
                positions.emplace(r, c);
            }
        }
    }
    return positions;
}

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

vector<pair<int, int>> neighborhood(int r, int c) {
    // chess knight moves
    vector<pair<int, int>> moves = {
        {2, 1}, {2, -1}, {-2, 1}, {-2, -1},
        {1, 2}, {1, -2}, {-1, 2}, {-1, -2}
    };
    vector<pair<int, int>> neighbors;
    for (auto [dr, dc] : moves) {
        int nr = r + dr;
        int nc = c + dc;
        if (inBounds(nr, nc)) {
            neighbors.emplace_back(nr, nc);
        }
    }
    return neighbors;
}

void solve() {
    string line;
    while (getline(cin, line)) {
        vector<char> row(line.begin(), line.end());
        grid.emplace_back(row);
    }
    R = grid.size();
    C = grid[0].size();
    auto [sr, sc] = findChar('D');
    set<pair<int, int>> sheep = findAllChar('S');
    int step = 0, ans = 0;
    queue<pair<int, int>> q;
    q.emplace(sr, sc);
    while (!q.empty() && step < 20 && !sheep.empty()) {
        int sz = q.size();
        set<pair<int, int>> visited;
        for (int i = 0; i < sz; i++) {
            auto [r, c] = q.front();
            q.pop();
            for (auto [nr, nc] : neighborhood(r, c)) {
                if (visited.find({nr, nc}) != visited.end()) continue;
                if (grid[nr][nc] != '#') {
                    set<pair<int, int>> to_remove;
                    for (auto [rr, cc] : sheep) {
                        // was sheep at that location where dragon moved
                        int newr = rr + step;
                        if (!inBounds(newr, cc)) {
                            to_remove.emplace(rr, cc);
                            continue;
                        }
                        if ((newr == nr && cc == nc) || (newr + 1 == nr && cc == nc)) {
                            ans++;
                            to_remove.emplace(rr, cc);
                        }
                    }
                    for (auto pos : to_remove) {
                        sheep.erase(pos);
                    }
                }
                q.emplace(nr, nc);
                visited.emplace(nr, nc);
            }
        }
        step++;
    }
    debug(ans, "\n");
}
```

## Part 3

### Solution 1:

1. should I store the positions of the sheep as a vector<int> where there is one for each column and the value is the row position.  There is only 7^6 possiblities there.
1. I just need to know how many sequence of moves to get to this state of the board dp[state][step]? 
1. So when transitioning where dragon is moving, just update the state and add the count 
1. how many rounds will this game go on for though? I think it will finish at some point, wait I think I know if you reach the same state again what does that mean, without eating all the sheep you are in a loop.  So you can just stop at that point.
1. sheep can only move down and there are 5 sheep in my input. so why don't I just model the row position of each sheep, and the cell location of the dragon as the state of the board.  I should be able to memoize on that? 
1. so basically the game can't last forever. 

```cpp

```

# Quest 11: The Scout Duck Protocol

## Part 2

### Solution 1: simulate the phases

```cpp
int64 level;
vector<int64> A;

void simulate() {
    int N = A.size();
    bool found = true;
    while (found) {
        found = false;
        for (int i = 1; i < N; ++i) {
            if (A[i - 1] > A[i]) {
                A[i - 1]--;
                A[i]++;
                found = true;
            }
        }
        if (found) level++;
    }
}
void simulate2() {
    int N = A.size();
    bool found = true;
    while (found) {
        found = false;
        for (int i = 0; i + 1 < N; ++i) {
            if (A[i + 1] > A[i]) {
                A[i + 1]--;
                A[i]++;
                found = true;
            }
        }
        if (found) level++;
    }
}

void solve() {
    string line;
    while (getline(cin, line)) {
        int64 val = stoll(line);
        A.emplace_back(val);
    }
    int N = A.size();
    level = 0;
    // first phase
    simulate();
    simulate2();
    debug(level, "\n");
}
```

## Part 3

### Solution 1:  map, set

1. Only need to consider phase 2, it is easy enough to see how many operations it takes for a group of elements with same value to decrease to another value. 

```cpp
vector<int64> A;

int64 simulate(int64 target) {
    int64 ans = 0;
    map<int64, int> freq;
    set<pair<int64, int>> blocks;
    for (int i = 0; i < A.size(); ++i) {
        freq[A[i]]++;
    }
    for (auto &[val, cnt] : freq) {
        blocks.emplace(val, cnt);
    }
    while (blocks.size() > 1) {
        auto it1 = prev(blocks.end());
        auto it2 = prev(it1);
        auto [v1, c1] = *it1;
        auto [v2, c2] = *it2;
        if (v1 < target) break;
        int64 delta = v1 - max(target, v2);
        ans += delta * c1;
        blocks.erase(it1);
        blocks.erase(it2);
        blocks.emplace(v2, c1 + c2);
    }
    return ans;
}

void solve()
{
    string line;
    while (getline(cin, line))
    {
        int64 val = stoll(line);
        A.emplace_back(val);
    }
    int N = A.size();
    int64 total = accumulate(A.begin(), A.end(), 0LL);
    int64 ans = simulate(total / N);
    debug(ans, "\n");
}
```

# Quest 12: One Spark to Burn Them All

## Part 2

### Solution 1: grid, dfs

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    for (char ch : s) {
        ans.emplace_back(ch - '0');
    }
    return ans;
}

int R, C, ans;
vector<vector<int>> grid;
vector<vector<bool>> vis;

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

vector<pair<int, int>> neighborhood(int r, int c) {
    return {{r-1, c}, {r+1, c}, {r, c-1}, {r, c+1}};
}

void dfs(int r, int c) {
    if (vis[r][c]) return;
    ans++;
    vis[r][c] = true;
    for (auto [nr, nc] : neighborhood(r, c)) {
        if (inBounds(nr, nc) && grid[nr][nc] <= grid[r][c]) {
            dfs(nr, nc);
        }
    }
}

void solve() {
    string line;
    while (getline(cin, line)) {
        grid.emplace_back(process(line));
    }
    R = grid.size();
    C = grid[0].size();
    vis.assign(R, vector<bool>(C, false));
    ans = 0;
    dfs(0, 0);
    dfs(R - 1, C - 1);
    debug(ans, "\n");
}

```

## Part 3

### Solution 1: grid, visited, dfs

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    for (char ch : s) {
        ans.emplace_back(ch - '0');
    }
    return ans;
}

int R, C;
vector<vector<int>> grid;
vector<vector<bool>> vis;

bool inBounds(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C;
}

void dfs(int r, int c, int& cur) {
    if (vis[r][c]) return;
    vis[r][c] = true;
    cur++;
    for (int dr = -1; dr <= 1; ++dr) {
        for (int dc = -1; dc <= 1; ++dc) {
            if (abs(dr) + abs(dc) != 1) continue;
            int nr = r + dr, nc = c + dc;
            if (!inBounds(nr, nc) || grid[nr][nc] == 10 || grid[nr][nc] > grid[r][c]) continue;
            dfs(nr, nc, cur);
        }
    }
}

void simulate() {
    int sr = -1, sc = -1, best = 0;
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            if (grid[r][c] == 10) continue;
            int cur = 0;
            vis.assign(R, vector<bool>(C, false));
            dfs(r, c, cur);
            if (cur > best) {
                best = cur;
                sr = r;
                sc = c;
            }
        }
    }
    vis.assign(R, vector<bool>(C, false));
    int cur = 0;
    dfs(sr, sc, cur);
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            if (!vis[r][c]) continue;
            grid[r][c] = 10;
        }
    }
}

void solve() {
    string line;
    while (getline(cin, line)) {
        grid.emplace_back(process(line));
    }
    R = grid.size(), C = grid[0].size();
    int ans = 0;
    for (int i = 0; i < 3; ++i) {
        simulate();
    }
    for (int r = 0; r < R; ++r) {
        for (int c = 0; c < C; ++c) {
            if (grid[r][c] == 10) ans++;
        }
    }
    debug(ans, "\n");
}
```

# Quest 13: Unlocking the Mountain

## Part 1

### Solution 1: modular arithmetic, arrays

```cpp
void solve() {
    string line;
    vector<int64> arr;
    while (getline(cin, line)) {
        int64 x = stoll(line);
        arr.emplace_back(x);
    }
    vector<int64> A, B;
    A.emplace_back(1);
    for (int i = 0; i < arr.size(); ++i) {
        if (i % 2 == 0) {
            A.emplace_back(arr[i]);
        } else {
            B.emplace_back(arr[i]);
        }
    }
    reverse(B.begin(), B.end());
    A.insert(A.end(), B.begin(), B.end());
    int N = A.size();
    int64 ans = A[2025 % N];
    debug(ans, "\n");
}
```

## Part 3

### Solution 1: modular arithmetic, intervals, iterate over the intervals, reverse

```cpp
void solve() {
    string line;
    vector<pair<int, int>> arr;
    while (getline(cin, line)) {
        int idx = line.find('-');
        int x = stoi(line.substr(0, idx));
        int y = stoi(line.substr(idx + 1));
        arr.emplace_back(x, y);
    }
    int64 rem = 202520252025L;
    vector<pair<int, int>> A, B;
    int64 total = accumulate(arr.begin(), arr.end(), 1LL, [](int64 acc, const pair<int, int> &p) {
        return acc + (p.second - p.first + 1);
    });
    A.emplace_back(1, 1);
    for (int i = 0; i < arr.size(); ++i) {
        if (i % 2 == 0) {
            A.emplace_back(arr[i].first, arr[i].second);
        } else {
            B.emplace_back(arr[i].second, arr[i].first);
        }
    }
    reverse(B.begin(), B.end());
    A.insert(A.end(), B.begin(), B.end());
    int N = A.size();
    rem %= total;
    int64 ans = 0;
    for (auto [x, y] : A) {
        int64 len = abs(y - x) + 1;
        if (rem <= len) {
            ans = x + (y >= x ? rem : -rem);
            break;
        }
        rem -= len;
    }
    debug(ans, "\n");
}
```

#

## Part 1

### Solution 1:

```cpp

```

## Part 2

### Solution 1:

```cpp

```

## Part 3

### Solution 1:

```cpp

```

#

## Part 1

### Solution 1:

```cpp

```

## Part 2

### Solution 1:

```cpp

```

## Part 3

### Solution 1:

```cpp

```