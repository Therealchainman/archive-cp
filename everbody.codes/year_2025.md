# Everybody Codes 2025


# Quest 1: Whispers in the Shell

## Part 2

### Solution 1: modulo 

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

void solve() {
    string S1, S2;
    getline(cin, S1);
    getline(cin, S2);
    getline(cin, S2);
    vector<string> A = process(S1, ','), B = process(S2, ',');
    int N = A.size();
    int pos = 0;
    for (const string& s : B) {
        char dir = s[0];
        int x = stoi(s.substr(1));
        if (dir == 'R') {
            pos = (pos + x) % N;
        } else {
            pos = (pos - x + N) % N;
        }
    }
    cout << A[pos] << endl;
}
```

## Part 3

### Solution 1: modulo, swapping

```cpp
vector<string> process(const string& s, char delimiter = ' ') {
    vector<string> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(word);
    return ans;
}

void solve() {
    string S1, S2;
    getline(cin, S1);
    getline(cin, S2);
    getline(cin, S2);
    vector<string> A = process(S1, ','), B = process(S2, ',');
    int N = A.size();
    for (const string& s : B) {
        char dir = s[0];
        int x = stoi(s.substr(1));
        int j = 0;
        if (dir == 'R') {
            j = x % N;
        } else {
            j = -x;
            while (j < 0) j += N;
        }
        swap(A[0], A[j]);
    }
    cout << A[0] << endl;
}
```

# Quest 2: From Complex to Clarity

## Part 1

### Solution 1: brute force

```cpp
void multiply(pair<int, int>& a, const pair<int, int>& b) {
    int first = a.first * b.first - a.second * b.second;
    int second = a.first * b.second + a.second * b.first;
    a = {first, second};
}
void add(pair<int, int>& a, const pair<int, int>& b) {
    a.first += b.first;
    a.second += b.second;
}
void divide(pair<int, int>& a, const pair<int, int>& b) {
    a.first /= b.first;
    a.second /= b.first;
}

void solve() {
    pair<int, int> A = {162, 59}, B = {10, 10};
    pair<int, int> number;
    for (int i = 0; i < 3; ++i) {
        multiply(number, number);
        divide(number, B);
        add(number, A);
    }
    cout << number.first << " " << number.second << endl;
}
```

## Part 3

### Solution 1: brute force

Part 2 is the same just change to increment by 10 instead of 1. 

```cpp
void multiply(pair<int64, int64>& a, const pair<int64, int64>& b) {
    int64 first = a.first * b.first - a.second * b.second;
    int64 second = a.first * b.second + a.second * b.first;
    a = {first, second};
}
void add(pair<int64, int64>& a, const pair<int64, int64>& b) {
    a.first += b.first;
    a.second += b.second;
}
void divide(pair<int64, int64>& a, const pair<int64, int64>& b) {
    a.first /= b.first;
    a.second /= b.first;
}

bool inBounds(const pair<int64, int64>& p) {
    if (p.first > 1000000 || p.second > 1000000 || p.first < -1000000 || p.second < -1000000) return false;
    return true;
}

bool simulation(const pair<int64, int64>& A) {
    pair<int64, int64> number = {0, 0}, B = {100000, 100000};
    for (int i = 0; i < 100; ++i) {
        multiply(number, number);
        divide(number, B);
        add(number, A);
        if (!inBounds(number)) return false;
    }
    return true;
}

void solve() {
    pair<int64, int64> A = {-79047, 14068};
    pair<int64, int64> tl = {-79047, 14068}, tr = {1000, 1000};
    add(tr, A);
    int ans = 0;
    for (int64 x = tl.first; x <= tr.first; x++) {
        for (int64 y = tl.second; y <= tr.second; y++) {
            pair<int64, int64> point = {x, y};
            if (simulation(point)) ans++;
        }
    }
    cout << ans << endl;
}
```

# Quest 3: The Deepest Fit

## Part 1

### Solution 1: unique and accumulate

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    A.erase(unique(A.begin(), A.end()), A.end());
    int64 ans = accumulate(A.begin(), A.end(), 0LL);
    cout << ans << endl;
}
```

## Part 2

### Solution 1: unique and accumulate first 20

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    A.erase(unique(A.begin(), A.end()), A.end());
    int64 ans = accumulate(A.begin(), A.begin() + 20, 0LL);
    cout << ans << endl;
}
```

## Part 3

### Solution 1: max frequency

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}
void solve() {
    string line;
    cin >> line;
    vector<int> A = process(line, ',');
    sort(A.begin(), A.end());
    vector<int> freq(*max_element(A.begin(), A.end()) + 1, 0);
    for (int x : A) {
        freq[x]++;
    }
    int ans = *max_element(freq.begin(), freq.end());
    cout << ans << endl;
}
```

# Quest 4: Teeth of the Wind

## Part 3

### Solution 1: circle, radius, ratios

I skipped the part 1 and 2, because they are super simple just like using ratio of the first and last gear, can do it without code even, just calculator. 

```cpp
void solve() {
    long double m = 100.0L;
    vector<pair<long double, long double>> gears;
    string line;
    while (getline(cin, line)) {
        auto bar = line.find('|');
        if (bar == string::npos) {
            gears.emplace_back(stold(line), stold(line));
        } else {
            long double left = stold(line.substr(0, bar));
            long double right = stold(line.substr(bar + 1));
            gears.emplace_back(left, right);
        }
    }
    int N = gears.size();
    long double cur = 1.0L;
    for (int i = 0; i + 1 < N; ++i) {
        long double leftRadius = gears[i].second;
        long double rightRadius = gears[i + 1].first;
        long double ratio = leftRadius / rightRadius;
        cur *= ratio;
    }
    cur *= m;
    int64 ans = floorl(cur);
    cout << ans << endl;
}
```

# Quest 5: Fishbone Order

## Part 2

### Solution 1: rules, greedy placement

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

struct Spine {
    bool l, r;
    int v;
    Spine(bool l, int v, bool r) : l(l), v(v), r(r) {}
};

string buildSword(const vector<int>& A) {
    vector<Spine> spines;
    for (int x : A) {
        bool placed = false;
        for (auto &spine : spines) {
            if (x < spine.v && !spine.l) {
                spine.l = true;
                placed = true;
                break;
            } else if (x > spine.v && !spine.r) {
                spine.r = true;
                placed = true;
                break;
            }
        }
        if (placed) continue;
        spines.emplace_back(false, x, false);
    }
    string ans;
    for (auto &spine : spines) {
        ans += to_string(spine.v);
    }
    return ans;
}

void solve() {
    string line;
    vector<vector<int>> A;
    vector<int64> swords;
    while (getline(cin, line)) {
        int idx = line.find(':');
        int swordId = stoi(line.substr(0, idx));
        A.emplace_back(process(line.substr(idx + 1), ','));
        string sword = buildSword(A.back());
        swords.emplace_back(stoll(sword));
    }
    sort(swords.begin(), swords.end());
    int64 ans = swords.back() - swords.front();
    cout << ans << endl;
}
```

## Part 3

### Solution 1: sorting, rules, custom comparator, 

```cpp
vector<int> process(const string& s, char delimiter = ' ') {
    vector<int> ans;
    istringstream iss(s);
    string word;
    while (getline(iss, word, delimiter)) ans.emplace_back(stoi(word));
    return ans;
}

struct Spine {
    int l, v, r;
    Spine(int l, int v, int r) : l(l), v(v), r(r) {}
};

struct Sword {
    int id;
    int64 quality;
    vector<int64> levels;
    Sword() : quality(0) {}
    Sword(int id, int64 quality, const vector<int64>& levels) : id(id), quality(quality), levels(levels) {}
    bool operator<(const Sword& other) const {
        if (quality != other.quality) return quality > other.quality;
        for (int i = 0; i < min(levels.size(), other.levels.size()); ++i) {
            if (levels[i] != other.levels[i]) return levels[i] > other.levels[i];
        }
        if (levels.size() != other.levels.size()) return levels.size() > other.levels.size();
        return id > other.id;
    }
};

Sword buildSword(int id, const vector<int>& A) {
    vector<Spine> spines;
    for (int x : A) {
        bool placed = false;
        for (auto &spine : spines) {
            if (x < spine.v && spine.l == -1) {
                spine.l = x;
                placed = true;
                break;
            } else if (x > spine.v && spine.r == -1) {
                spine.r = x;
                placed = true;
                break;
            }
        }
        if (placed) continue;
        spines.emplace_back(-1, x, -1);
    }
    string q;
    for (auto &spine : spines) {
        q += to_string(spine.v);
    }
    vector<int64> levels;
    for (auto &spine : spines) {
        string s;
        if (spine.l != -1) s += to_string(spine.l);
        s += to_string(spine.v);
        if (spine.r != -1) s += to_string(spine.r);
        levels.emplace_back(stoll(s));
    }
    Sword sword(id, stoll(q), levels);
    return sword;
}

void solve() {
    string line;
    vector<Sword> swords;
    while (getline(cin, line)) {
        int idx = line.find(':');
        int swordId = stoi(line.substr(0, idx));
        vector<int> A = process(line.substr(idx + 1), ',');
        Sword sword = buildSword(swordId, A);
        swords.emplace_back(sword);
    }
    sort(swords.begin(), swords.end());
    int64 ans = 0;
    for (int i = 0; i < swords.size(); ++i) {
        ans += static_cast<int64>(swords[i].id) * (i + 1);
    }
    cout << ans << endl;
}
```

#

## Part 1

### Solution 1:

```cpp

```

## Part 2

### Solution 1:

```cpp

```

## Part 3

### Solution 1:

```cpp

```

#

## Part 1

### Solution 1:

```cpp

```

## Part 2

### Solution 1:

```cpp

```

## Part 3

### Solution 1:

```cpp

```