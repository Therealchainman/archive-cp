# Codeforces Round 1000-1049

# Codeforces Round 1000 div 2

## Game with Triangles

### Solution 1:  sorting, prefix sum, convexity, ternary search

1. sum of convex functions is convex, prefix sum from strictly decreasing sequence.

```cpp
int N, M;
vector<int> A, B;
vector<int64> psA, psB;

int64 f(int x, int y) {
    return psA[x] + psB[y - x];
}

void solve() {
    cin >> N >> M;
    A.resize(N);
    B.resize(M);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < M; i++) {
        cin >> B[i];
    }
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    psA.assign(N / 2 + 1, 0);
    psB.assign(M / 2 + 1, 0);
    for (int i = 0; i < N / 2; i++) {
        psA[i + 1] = A.end()[~i] - A[i] + psA[i];
    }
    for (int i = 0; i < M / 2; i++) {
        psB[i + 1] = B.end()[~i] - B[i] + psB[i];
    }
    int K = min({N, M, (N + M) / 3});
    cout << K << endl;
    for (int k = 1; k <= K; k++) {
        int l = max(0, 2 * k - M), r = min(k, N - k);
        while (r - l > 3) {
            int m1 = l + (r - l) / 3;
            int m2 = r - (r - l) / 3;
            int64 f1 = f(m1, k), f2 = f(m2, k);
            if (f1 < f2) l = m1 + 1;
            else r = m2 - 1;
        }
        int64 ans = 0;
        for (int i = l; i <= r; i++) {
            ans = max(ans, f(i, k));
        }
        cout << ans << " ";
    }
    cout << endl;   
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Triangle Tree

### Solution 1:  tree, math, combinatorics, lowest common ancestor, dfs, suffix sum, counting

1. The real trick is to figure out the math that makes it possible to compute everything. 
1. The first obvservation is that you need the distances to satisfy triangle inequality which will give you max(a - b, b - a) < x < a + b.
1. In other words the number of possible values for x are a + b - max(a - b, b - a) - 1, but if you enumerate both cases that is if a > b or b > a, you will find that a > b reduces to 2 * b - 1, and b > a reduces to 2 * a - 1, so you can rewrite the solution for count of valid x values to be 2 * min(a, b) - 1.
1. Now in this case a and be represented distances in tree between a node and lowest common ancestor, so min(dist(u, lca(u, v)), dist(v, lca(u, v))) - 1.
1. Now another way to compute dist(u, lca(u, v)) is using the depth of nodes in the tree.  depth(u) - depth(lca), so you get an equation which is 2 * min(depth(u), depth(v)) - 2 * depth(lca) - 1.
1. So lets calculate the last part which is 2 * depth(lca) + 1. 
1. Think about it like this given an node w, you will have some children subtrees, you just need to count the number of ways to take a node from one child subtree to every node in all the other child subtrees. You can calculate this in O(n) with summation of all children and taking s(child) * (s(lca) - w - s(child)) for all children. This will overcount by 2, so you need to divide by 2.
1. Do the math and you can derive the best way to represent this, and this is how many time syou want to subtract by 1 as well.  So just count the number of ways to have this lca, and use it's depth and everything, so imagine it as (2 * depth(lca) + 1) * count(lca) that is how much these terms contribute.
1. Okay so how to calculate how much the other term contributes, 2 * min(depth(u), depth(v))
1. Split it as well, consider if depth(u) is the minimum depth, can you count how many nodes have a greater depth?
1. Then it would be 2 * depth(u) * (count(depth(i) >= depth(u)) - size(u)), you need to subtract size(u) cause they will be at greater depth and included in the count, but they are not valid cause they are a descendent of u. 
1. Now this counts it all well, but it overcounts for when depth(u) == depth(i), but those you can count how many times you have a node at same depth, so you have 5 nodes at depth 2, for example, how many ways can you select two nodes at the same depth.  that is simple 5 choose 2.  And you just need to subtract by this, so it correct for the double counting.  Cause it counted d(u), d(v), and d(v), d(u).  But now you remove like d(v), d(u) for instance.

```cpp
int N;
vector<vector<int>> adj;
vector<int64> sz, dcnt, depth, ssum;

int64 chooseTwo(int64 n) {
    return n * (n - 1) / 2;
}

void dfs(int u, int p = -1, int d = 0) {
    sz[u] = 1;
    dcnt[d]++;
    depth[u] = d;
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u, d + 1);
        sz[u] += sz[v];
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    sz.assign(N, 0);
    dcnt.assign(N, 0);
    depth.assign(N, 0);
    ssum.assign(N + 1, 0);
    dfs(0);
    for (int i = N - 1; i >= 0; i--) {
        ssum[i] = dcnt[i] + ssum[i + 1];
    }
    int64 ans = 0;
    for (int i = 0; i < N; i++) {
        ans += 2LL * depth[i] * (ssum[depth[i]] - sz[i]);
        ans -= 2LL * i * chooseTwo(dcnt[i]);
        int64 combinationsBetweenSubtrees = 0;
        for (int v : adj[i]) {
            if (depth[v] > depth[i]) {
                combinationsBetweenSubtrees += sz[v] * (sz[i] - sz[v] - 1);
            }
        }
        ans -= (2LL * depth[i] + 1) * combinationsBetweenSubtrees / 2;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1001 div 1+2

## Cirno and Operations

### Solution 1:  calculate difference arrays, brute force

1. Turns out the reversing just basically is like negating, so just calculate the sum of all the difference arrays, and take the max. 

```cpp
int N;
vector<int64> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    int64 ans = accumulate(A.begin(), A.end(), 0LL);
    while (A.size() > 1) {
        vector<int64> B;
        for (int i = 1; i < A.size(); i++) {
            B.emplace_back(A[i] - A[i - 1]);
        }
        swap(A, B);
        int64 cand = accumulate(A.begin(), A.end(), 0LL);
        ans = max({ans, cand, -cand});
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

### Solution 2:  pascal's triangle, precomputation, loop over all scenarios, math

1. Derive the math, there is a simple relationship between the coefficients and the pascal's triangle
1. In addition you can try each size of polynomials from 1 to N.  
1. Derive on paper the mathematical relationship and code it, the reverse operation, just allows you two possible answers for each size of each element.
1. So I think of when I have combined 2 elements, 3 element, 4 elements and so on with the difference operation. 
1. The reverse operation just switches the signs actually, and can only apply when you have merged at least 2 elements.

```cpp
const int MAXN = 55, INF = 1e18;
int N;
vector<int> A;
int64 pascal[MAXN][MAXN];

void precompute(int N) {
    for (int i = 0; i < N; i++) {
        pascal[i][0] = pascal[i][i] = 1;
        for (int j = 1; j < i; j++) {
            pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]);
        }
    }
}

int64 calc(int idx, int l, int r, int64 m) {
    int64 ans = 0;
    for (int i = 0; i < r - l; i++) {
        ans += A[l + i] * ((i % 2 == 0) ? m : -1 * m) * pascal[idx][i];
    }
    return ans;
}

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    int64 ans = -INF;
    for (int i = 1; i <= N; i++) {
        int64 cur1 = 0, cur2 = 0;
        for (int j = 0; j < N - i + 1; j++) {
            cur1 += calc(i - 1, j, j + i, 1);
            if (i > 1) cur2 += calc(i - 1, j, j + i, -1);
        }
        if (i == 1) cur2 = -INF;
        ans = max({ans, cur1, cur2});
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    precompute(MAXN);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Balanced Tree

### Solution 1:  tree, dfs, observation

1. Really it is hard to make the observation that you can root the tree anyway, arbitrarily and just take the difference of elements. 
1. One observaiton not too hard is that you really are taking the edges, and increasing the side where the value is smaller for all the nodes. 

```cpp
int64 N, ans;
vector<vector<int>> adj;
vector<int64> A, L, R;

void dfs(int u, int p = -1) {
    A[u] = L[u];
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
        A[u] = max(A[u], A[v]);
    }
    A[u] = min(R[u], A[u]);
    for (int v : adj[u]) {
        if (v == p) continue;
        ans += max(0LL, A[v] - A[u]);
    }
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    L.assign(N, 0);
    R.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> L[i] >> R[i];
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    ans = 0;
    A.assign(N, 0);
    dfs(0);
    ans += A[0];
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## The Game (Easy Version)

### Solution 1: 

```cpp
int N, timer;
vector<int> values, tin, tout, timerToNode;
vector<vector<int>> adj;

void dfs(int u, int p = -1) {
    tin[u] = ++timer;
    timerToNode[timer] = u;
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
    }
    tout[u] = timer;
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    values.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> values[i];
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    tin.assign(N, 0);
    tout.assign(N, 0);
    timerToNode.assign(N + 1, 0);
    timer = 0;
    dfs(0);
    vector<int> pmax(N + 2, 0), smax(N + 2, 0);
    for (int i = 1; i <= N; ++i) {
        pmax[i] = max(pmax[i - 1], values[timerToNode[i]]);
    }
    for (int i = N; i > 0; --i) {
        smax[i] = max(smax[i + 1], values[timerToNode[i]]);
    }
    int64 ans = 0;
    for (int u = 0; u < N; ++u) {
        int maxAroundSubtree = max(pmax[tin[u] - 1], smax[tout[u] + 1]);
        if (maxAroundSubtree > values[u] && (!ans || values[u] > values[ans])) {
            ans = u;
        }
    }
    if (ans) ++ans;
    cout << ans  << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

# Codeforces Round 1002 div 2

## Customer Service

### Solution 1:  mex, frequency array, greedy, suffix count of consecutive ones

```cpp
int N;
vector<vector<int>> grid;

void solve() {
    cin >> N;
    grid.assign(N, vector<int>(N));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> grid[i][j];
        }
    }
    vector<int> freq(N + 1, 0);
    for (int i = 0; i < N; i++) {
        for (int j = N - 1; j >= 0; j--) {
            if (grid[i][j] != 1) break;
            freq[i]++;
        }
    }
    sort(freq.begin(), freq.end());
    int ans = 1;
    for (int x : freq) {
        if (x >= ans) ans++;
    }
    ans = min(ans, N);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Graph and Graph

### Solution 1:  undirected graphs, min heap, dijkstra, shortest path, 

```cpp
struct State {
    int u, v, d;
    State() {}
    State(int u, int v, int d) : u(u), v(v), d(d) {}
    bool operator<(const State& other) const {
        return d > other.d;
    }
};

const int INF = 1e9;
int N, s1, s2, M1, M2;
vector<vector<int>> adj1, adj2;

void solve() {
    cin >> N >> s1 >> s2;
    --s1, --s2;
    cin >> M1;
    adj1.assign(N, vector<int>());
    for (int i = 0; i < M1; i++) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj1[u].emplace_back(v);
        adj1[v].emplace_back(u);
    }
    for (int i = 0; i < N; i++) {
        sort(adj1[i].begin(), adj1[i].end());
    }
    cin >> M2;
    adj2.assign(N, vector<int>());
    for (int i = 0; i < M2; i++) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj2[u].emplace_back(v);
        adj2[v].emplace_back(u);
    }
    for (int i = 0; i < N; i++) {
        sort(adj2[i].begin(), adj2[i].end());
    }
    vector<vector<int>> dist(N, vector<int>(N, INF));
    vector<bool> finish(N, false);
    for (int i = 0; i < N; i++) {
        for (int j = 0, k = 0; j < adj1[i].size() && k < adj2[i].size();) {
            if (adj1[i][j] == adj2[i][k]) {
                finish[i] = true;
                break;
            }
            if (adj1[i][j] < adj2[i][k]) {
                j++;
            } else {
                k++;
            }
        }
    }
    priority_queue<State> minheap;
    minheap.emplace(s1, s2, 0);
    while (!minheap.empty()) {
        State cur = minheap.top();
        if (cur.u == cur.v && finish[cur.u]) {
            cout << cur.d << endl;
            return;
        }
        minheap.pop();
        for (int u : adj1[cur.u]) {
            for (int v : adj2[cur.v]) {
                int cost = abs(u - v);
                if (cur.d + cost < dist[u][v]) {
                    dist[u][v] = cur.d + cost;
                    minheap.emplace(u, v, cur.d + cost);
                }
            }
        }
    }
    cout << -1 << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## 

### Solution 1: 

```cpp

```

# Codeforces Round 1003 div 4

## C2 

### Solution 1: sorting, binary search, greedy

```cpp
const int64 INF = 1e10;
int N, M;
vector<int> A, B;

void solve() {
    cin >> N >> M;
    A.assign(N, 0);
    B.assign(M, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < M; i++) {
        cin >> B[i];
    }
    sort(B.begin(), B.end());
    int64 last = -INF;
    for (int i = 0; i < N; i++) {
        int lo = 0, hi = M - 1;
        while (lo < hi) {
            int mi = lo + (hi - lo) / 2;
            if (B[mi] - A[i] < last) lo = mi + 1;
            else hi = mi;
        }
        int cand = B[lo] - A[i];
        if (cand < last && A[i] < last) {
            cout << "NO" << endl;
            return;
        }
        if (cand >= last && A[i] >= last) {
            last = min(A[i], cand);
        } else if (cand >= last) {
            last = cand;
        } else {
            last = A[i];
        }
    }

    cout << "YES" << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## D

### Solution 1:  math, greedy, observation, sorting

1. If you suspect that the array with greater sums are the ones you want to pick first, that is actually correct.  What is the intuition and proof for that though? 

```cpp
int R, C;
vector<vector<int>> mat;

void solve() {
    cin >> R >> C;
    mat.assign(R, vector<int>(C));
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) cin >> mat[i][j];
    }
    vector<pair<int64, int>> values;
    for (int i = 0; i < R; i++) {
        int64 sum = accumulate(mat[i].begin(), mat[i].end(), 0LL);
        values.emplace_back(sum, i);
    }
    sort(values.rbegin(), values.rend());
    int64 ans = 0, mult = static_cast<int64>(R) * C;
    for (int i = 0; i < R; i++) {
        int idx = values[i].second;
        for (int j = 0; j < C; j++) {
            ans += mat[idx][j] * mult--;
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## E

### Solution 1: greedy, string

```cpp
int N, M, K;

void solve() {
    cin >> N >> M >> K;
    if (K < abs(N - M) || K > max(N, M)) {
        cout << -1 << endl;
        return;
    }
    string ans;
    int n = N, m = M;
    for (int i = 0; i < K; i++) {
        if (N > M) ans += '0';
        else ans += '1';
    }
    if (N > M) n -= K;
    else m -= K;
    while (n > 0 && m > 0) {
        if (N > M) ans += "10", n--, m--;
        else ans += "01", n--, m--;
    }
    while (n--) ans += '0';
    while (m--) ans += '1';
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## F

### Solution 1: tree, dfs, sets, 

1. Observation that for it to be a majority it must be adjacent or separate by a middle node.  So that simplifies the problem.

```cpp
int N;
vector<int> ans, A;
vector<vector<int>> adj;

void dfs(int u, int p = -1) {
    set<int> neighbors;
    if (p != -1) neighbors.insert(A[p]);
    for (int v : adj[u]) {
        if (v == p) continue;
        if (A[u] == A[v]) ans[A[u]] = 1;
        if (neighbors.count(A[v])) ans[A[v]] = 1;
        neighbors.insert(A[v]);
        dfs(v, u);
    }
}

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    ans.assign(N + 1, 0);
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    dfs(0);
    for (int i = 1; i <= N; i++) {
        cout << ans[i];
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## G

### Solution 1: prime sieve, prime factorization, number theory, counting, frequency

```cpp
const int MAXN = 2e5 + 5;
int N;
vector<int> A;
int64 freq[MAXN];
vector<vector<int>> primes;

void sieve(int n) {
    primes.assign(n + 1, vector<int>());
    for (int i = 2; i <= n; i++) {
        if (primes[i].empty()) {
            for (int j = i; j <= n; j += i) {
                primes[j].push_back(i);
            }
        }
    }
}

void solve() {
    cin >> N;
    A.assign(N, 0);
    memset(freq, 0, sizeof(freq));
    int64 total = 0, ans = 0;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        freq[A[i]]++;
        if (primes[A[i]].size() == 1) {
            int64 p = primes[A[i]][0];
            if (p == A[i]) {
                total++;
                ans += total - freq[p];
                if (p * p < MAXN) {
                    ans += freq[p * p];
                }
            } else if (p * p == A[i]) {
                ans += freq[p];
                if (p * p < MAXN) ans += freq[p * p];
            }
        } else if (primes[A[i]].size() == 2) {
            int64 p = primes[A[i]][0], q = primes[A[i]][1];
            if (p * q == A[i]) {
                ans += freq[p * q];
            }
        }
    }
    for (int i = 0; i < N; i++) {
        if (primes[A[i]].size() == 2) {
            int p = primes[A[i]][0], q = primes[A[i]][1];
            if (p * q == A[i]) {
                ans += freq[p] + freq[q];
            }
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    sieve(MAXN);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## H

### Solution 1: point query, range query segment tree, addition update, combinatorics, counting number of subsets

1. Realize you need prefix and suffix range sum queries but with updates.  So consider using separate segment trees for the prefix and suffix, since different solution for those. 
1. The main observation is that you need to look at each 0, 1 pair and realize those borders increase by one, then say the i, j where s[i] != s[j] and suppose nothing between, them so they are adjacent, then how many times will that border contribute `one` to the answer.  It is how many subsets you can pick in the prefix or suffix.  
1. By thinking of what is the contribution of a single element like s(i) you can realize the updates needed for each step. 
1. when in doubt with those hints, just think counting number of subsets and prefix sums. 

```cpp
const int64 MOD = 998244353;

struct SegmentTree {
    int size;
    int64 neutral = 0;
    vector<int64> nodes;

    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, 0);
    }

    int64 func(int64 x, int64 y) {
        return (x + y) % MOD;
    }

    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }

    void update(int segment_idx, int val) {
        segment_idx += size;
        nodes[segment_idx] = val;
        segment_idx >>= 1;
        ascend(segment_idx);
    }

    int query(int left, int right) {
        left += size, right += size;
        int64 res = neutral;
        while (left <= right) {
            if (left & 1) {
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                res = func(res, nodes[right]);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};

const int MAXN = 2e5 + 5;
int N, Q;
string S;
vector<int> A;
int64 pow2[MAXN];

int decode(char c) {
    return c - '0';
}

void solve() {
    cin >> S;
    cin >> Q;
    int N = S.size();
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        A[i] = decode(S[i]);
    }
    SegmentTree segPre[2], segSuf[2];
    for (int i = 0; i < 2; i++) {
        segPre[i].init(N + 1);
        segSuf[i].init(N + 1);
    }
    for (int i = 1; i <= N; i++) {
        segPre[A[i - 1]].update(i, pow2[i - 1]);
        segSuf[A[i - 1]].update(i, pow2[N - i]);
    }
    int64 ans = (pow2[N] - 1 + MOD) % MOD;
    int64 psum[2];
    memset(psum, 0, sizeof(psum));
    for (int i = 1; i <= N; i++) {
        psum[A[i - 1]] = (psum[A[i - 1]] + pow2[i - 1]) % MOD;
        ans = (ans + psum[A[i - 1] ^ 1] * pow2[N - i] % MOD) % MOD;
    }
    while (Q--) {
        int q;
        cin >> q;
        int64 pre = segPre[A[q - 1] ^ 1].query(0, q - 1), suf = segSuf[A[q - 1] ^ 1].query(q + 1, N);
        ans = (ans - pre * pow2[N - q] % MOD + MOD) % MOD;
        ans = (ans - suf * pow2[q - 1] % MOD + MOD) % MOD;
        segPre[A[q - 1]].update(q, 0);
        segSuf[A[q - 1]].update(q, 0);
        A[q - 1] ^= 1;
        segPre[A[q - 1]].update(q, pow2[q - 1]);
        segSuf[A[q - 1]].update(q, pow2[N - q]);
        int64 pre2 = segPre[A[q - 1] ^ 1].query(0, q - 1), suf2 = segSuf[A[q - 1] ^ 1].query(q + 1, N);
        ans = (ans + pre2 * pow2[N - q] % MOD) % MOD;
        ans = (ans + suf2 * pow2[q - 1] % MOD) % MOD;
        cout << ans << " ";
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    pow2[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        pow2[i] = 2LL * pow2[i - 1] % MOD;
    }
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

# Codeforces Round 1004 div 2

## Object Identification

### Solution 1: directed graph, manhattan distance

```cpp
int N;
vector<int> A;

int ask(int x, int y) {
    cout << "? " << x << " " << y << endl;
    cout.flush();
    int res;
    cin >> res;
    return res;
}

void answer(char ch) {
    cout << "! " << ch << endl;
    cout.flush();
}

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    vector<int> loc(N + 1, -1);
    for (int i = 0; i < N; i++) {
        loc[A[i]] = i + 1;
    }
    for (int i = 1; i <= N; i++) {
        if (loc[i] == -1) {
            int res;
            if (i == 1) {
                res = ask(1, 2);
                ask(1, 2);
            } else {
                res = ask(i, 1);
                ask(i, 1);
            }
            if (!res) {
                answer('A');
            } else {
                answer('B');
            }
            return;
        }
    }
    int res1 = ask(loc[1], loc[N]), res2 = ask(loc[N], loc[1]);
    if (res1 == res2 && res1 >= N - 1) {
        answer('B');
    } else {
        answer('A');
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## White magic

### Solution 1: min, mex, greedy, logic, multiset, prefix min, suffix mex

1. multiset works well with fact you have many test cases, otherwise I would have used frequency array, can still get frequency array to work with this efficiently, but you'd have to use another data structure to track all the elements.
1. multiset is just simpler for this one and calculating the mex of the suffix array. 

```cpp
const int INF = 1e9;
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    int ans = 0;
    bool isZero = false;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        if (A[i] > 0) ans++;
        else isZero = true;
    }
    if (!isZero) {
        cout << ans << endl;
        return;
    }
    multiset<int> vis;
    for (int i = 0; i < N; i++) {
        vis.insert(A[i]);
    }
    int mex = 0;
    while (vis.find(mex) != vis.end()) mex++;
    int pmin = INF;
    bool flag = true;
    for (int i = 0; i < N; i++) {
        if (!A[i]) {
            if (flag) {
                ans++;
                break;
            }
            flag = true;
        }
        pmin = min(pmin, A[i]);
        auto it = vis.find(A[i]);
        int x = *it;
        vis.erase(it);
        if (x < mex && vis.find(x) == vis.end()) mex = x;
        if (mex > pmin) flag = false;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1005 div 2

## Remove the Ends

### Solution 1:  prefix sum, suffix sum, greedy

```cpp
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    vector<int64> B;
    bool isPos = A[0] > 0;
    int64 cur = 0;
    for (int x : A) {
        if (x > 0 && !isPos) {
            B.emplace_back(cur);
            cur = 0;
        } else if (x < 0 && isPos) {
            B.emplace_back(cur);
            cur = 0;
        }
        isPos = x > 0;
        cur += x;
    }
    if (cur != 0) B.emplace_back(cur);
    int M = B.size();
    vector<int64> pre(M + 1, 0), suf(M + 1, 0);
    for (int i = 0; i < M; i++) {
        pre[i + 1] = pre[i];
        if (B[i] > 0) pre[i + 1] += B[i];
    }
    for (int i = M - 1; i >= 0; i--) {
        suf[i] = suf[i + 1];
        if (B[i] < 0) suf[i] += abs(B[i]);
    }
    int64 ans = 0;
    for (int i = 0; i <= M; i++) {
        ans = max(ans, pre[i] + suf[i]);
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

## Eating

### Solution 1: bit manipulation, prefix sum for xor, most significant bit (msb)

1. Analyze how msb changes, that is all that matters in reality.
1. It can only decrease at most logarithmic times, so 30 times.  So is there a way to iterate over just the times when msb clashes?
1. Another difficult part is how to precompute to make the query fast, so it jumpts to the next relevant index. 


```cpp
const int BIT = 30;
int N, Q;
vector<int> A, pref;
vector<vector<int>> msb;

void solve() {
    cin >> N >> Q;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    pref.assign(N, 0);
    for (int i = 0; i < N; i++) {
        pref[i] = A[i];
        if (i > 0) pref[i] ^= pref[i - 1];
    }
    msb.assign(N, vector<int>(BIT, 0));
    for (int i = 0; i < N; i++) {
        if (i > 0) {
            for (int j = 0; j < BIT; j++) {
                msb[i][j] = msb[i - 1][j];
            }
        }
        int x = static_cast<int>(log2(A[i]));
        msb[i][x] = i;
        for (int j = BIT - 2; j >= 0; j--) {
            msb[i][j] = max(msb[i][j], msb[i][j + 1]);
        }
    }
    while (Q--) {
        int x;
        cin >> x;
        int idx = N - 1;
        while (idx >= 0 && x > 0) {
            int b = static_cast<int>(log2(x));
            int nxt = msb[idx][b];
            x ^= pref[idx] ^ pref[nxt];
            idx = nxt;
            if (x < A[nxt]) break;
            x ^= A[nxt];
            idx--;
        }
        cout << N - idx - 1 << " ";
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1006 div x

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Codeforces Round 1007 div 2

## Perfecto

### Solution 1: greedy, perfect squares

```cpp
const vector<int> bad = {1, 8, 49, 288, 1681, 9800, 57121, 332928};
int N;

void solve() {
    cin >> N;
    if (find(bad.begin(), bad.end(), N) != bad.end()) {
        cout << -1 << endl;
        return;
    }
    for (int x = 1; x <= N; x++) {
        if (find(bad.begin(), bad.end(), x) != bad.end()) {
            cout << x + 1 << " " << x << " ";
            x++;
        } else {
            cout << x << " ";
        }
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Trapmigiano Reggiano

### Solution 1: dfs, tree, depth, greedy

```cpp
int N, st, en;
vector<vector<int>> adj, depths;

void dfs(int u, int p = -1, int d = 0) {
    depths[d].emplace_back(u);
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u, d + 1);
    }
}

void solve() {
    cin >> N >> st >> en;
    en--;
    adj.assign(N, vector<int>());
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        u--, v--;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    depths.assign(N, vector<int>());
    dfs(en);
    for (int i = N - 1; i >= 0; i--) {
        for (int j : depths[i]) {
            cout << j + 1 << " ";
        }
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Infinite Sequence (Easy Version)

### Solution 1: bit manipulation, parity, recursion

```cpp
int N, P;
int64 L, R;
vector<int> A;

int calc(int64 x) {
    if (x <= 2 * N + 1) {
        return A[x]; 
    }
    int res = P;
    int64 v = (x - 2 * N) / 2;
    if (v & 1) {
        res ^= calc(x / 2);
    }
    return res;
}

void solve() {
    cin >> N >> L >> R;
    A.assign(N + 1, 0);
    for (int i = 1; i <= N; i++) {
        cin >> A[i];
    }
    int val = 0;
    for (int i = 1; i <= N / 2; i++) {
        val ^= A[i];
    }
    if (N % 2 == 0) {
        A.emplace_back(val);
        N++;
    }
    P = accumulate(A.begin(), A.end(), 0, bit_xor<int>());
    for (int i = N + 1; i <= 2 * N + 1; i++) {
        if (i % 2 == 0) val ^= A[i / 2];
        A.emplace_back(val);
    }
    int ans = calc(L);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1008 div x

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Codeforces Round 1009 div 3

## Counting Points

### Solution 1: map, precompute squares, binary search, circle, radius

```cpp
const int MAXN = 10e5 + 5;
int N, M;
vector<int64> X, R;
int64 squares[MAXN];
 
void solve() {
    cin >> N >> M;
    X.assign(N, 0);
    R.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> X[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> R[i];
    }
    map<int, int64> Y;
    for (int i = 0; i < N; i++) {
        for (int x = X[i] - R[i]; x <= X[i] + R[i]; x++) {
            int64 h = upper_bound(squares, squares + MAXN, R[i] * R[i] - (x - X[i]) * (x - X[i])) - squares - 1;
            Y[x] = max(Y[x], h);
        }
    }
    int64 ans = 0;
    for (auto [x, h] : Y) {
        ans += 2LL * h + 1;
    }
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    for (int64 i = 1; i < MAXN; i++) {
        squares[i] = i * i;
    }
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

## Empty Triangle

### Solution 1: random

```cpp
int N;
const vector<pair<int, int>> choices = {{0, 1}, {1, 2}, {0, 2}};
 
int ask(int i, int j, int k) {
    cout << "? " << i << ' ' << j << ' ' << k << endl;
    cout.flush();
    int res;
    cin >> res;
    return res;
}
 
void answer(int i, int j, int k) {
    cout << "! " << i << ' ' << j << ' ' << k << endl;
    cout.flush();
}
 
void solve() {
    cin >> N;
    vector<int> triangle = {1, 2, 3};
    for (int i = 0; i < 75; i++) {
        int resp = ask(triangle[0], triangle[1], triangle[2]);
        if (resp == 0) {
            answer(triangle[0], triangle[1], triangle[2]);
            return;
        }
        int j = rand() % 3;
        auto [a, b] = choices[j];
        triangle = {triangle[a], triangle[b], resp};
    }
    answer(triangle[0], triangle[1], triangle[2]);
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Counting Necessary Nodes

### Solution 1: 2d segment tree, segment tree intervals, divide and conquer, recursion

```cpp
const int BITS = 21;
int l1, r1, l2, r2;
vector<int> A, B;

void dfs(int L, int R, int l, int r, vector<int> &vec) {
    if (l >= r) return;
    if (l == L && r == R) {
        vec.emplace_back(R - L);
        return;
    }
    int mid = (L + R) >> 1;
    dfs(L, mid, l, min(r, mid), vec);
    dfs(mid, R, max(l, mid), r, vec);
}

void solve() {
    cin >> l1 >> r1 >> l2 >> r2;
    A.clear();
    B.clear();
    dfs(0, 1 << BITS, l1, r1, A);
    dfs(0, 1 << BITS, l2, r2, B);
    int ans = 0;
    for (int a : A) {
        for (int b : B) {
            ans += max(a, b) / min(a, b);
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Game With Triangles Season 2

### Solution 1: interval dynamic programming, 

```cpp

```

# Codeforces Round 1010 div 2

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Codeforces Round 1011 div 2

## Serval and Final MEX

### Solution 1: greedy, intervals

```cpp
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    if (all_of(A.begin(), A.end(), [](int x) { return x == 0; })) {
        cout << 3 << endl;
        cout << 3 << " " << N << endl;
        cout << 1 << " " << 2 << endl;
        cout << 1 << " " << 2 << endl;
        return;
    }
    vector<pair<int, int>> ans;
    bool isZero = false;
    int last = -1;
    for (int i = N - 1; i >= 0; i--) {
        if (A[i] == 0) {
            last = max(last, i);
            isZero = true;
        } else {
            if (isZero) {
                if (last - (i + 1) == 0) ans.emplace_back(i, last);
                else ans.emplace_back(i + 1, last);
                last = -1;
                isZero = false;
            }
        }
        if (i == 0 && isZero) {
            if (last == 0) last++;
            ans.emplace_back(0, last);
        }
    }
    for (auto [l, r] : ans) {
        N -= r - l;
    }
    if (N > 1) {
        ans.emplace_back(0, N - 1);
    }
    cout << ans.size() << endl;
    for (auto [l, r] : ans) {
        cout << l + 1 << " " << r + 1 << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Serval and the Formula

### Solution 1: poer of 2

1.  So if you use large enough power of 2, you get one of the values equal to 2^50 and the other is less than 2^50 so they don't overlap. 

```cpp
int64 X, Y;

void solve() {
    cin >> X >> Y;
    if (X == Y) {
        cout << -1 << endl;
        return;
    }
    int64 ans = (1LL << 50) - max(X, Y);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Serval and the Kaitenzushi Buffet

### Solution 1: max heap, greedy

```cpp
int N, K;
vector<int> A;

void solve() {
    cin >> N >> K;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    priority_queue<int> maxheap;
    int64 ans = 0;
    for (int i = 1; i <= N; i++) {
        maxheap.emplace(A[i - 1]);
        if ((N - i + 1) % (K + 1) == 0) {
            ans += maxheap.top();
            maxheap.pop();
        }
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1012 div x

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Codeforces Round 1013 div 3

## Place of the Olympiad

### Solution 1: binary search

```cpp
int64 N, M, K;
 
void solve() {
    cin >> N >> M >> K;
    int64 lo = 0, hi = K;
    while (lo < hi) {
        int64 mid = lo + (hi - lo) / 2;
        int64 numSeatsInRow = M / (mid + 1) * mid + (M % (mid + 1));
        int64 numSeats = numSeatsInRow * N;
        debug(lo, mid, hi, numSeatsInRow, numSeats, "\n");
        if (numSeats < K) lo = mid + 1;
        else hi = mid;
    }
    cout << lo << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Interesting Ratio

### Solution 1: number theory, gcd, lcm, prime sieve

```cpp

```

## Igore in Mountain

### Solution 1: dynamic programming, binary search, prefix sum, grid

```cpp
const int64 MOD = 998244353;
int R, C, D;
vector<vector<char>> grid;
vector<int64> psum;
 
int search(int64 target) {
    int64 lo = 0, hi = 1e9;
    while (lo < hi) {
        int64 mid = lo + (hi - lo + 1) / 2;
        if (mid * mid > target) hi = mid - 1;
        else lo = mid;
    }
    return lo;
}
 
int64 query(int l, int r) {
    if (l > r) return 0;
    int64 ans = psum[min(r, C - 1)];
    if (l > 0) ans -= psum[l - 1];
    if (ans < 0) ans += MOD;
    return ans % MOD;
}
 
void solve() {
    cin >> R >> C >> D;
    grid.assign(R, vector<char>(C));
    for (int i = 0; i < R; ++i) {
        for (int j = 0; j < C; ++j) {
            cin >> grid[i][j];
        }
    }
    int x = search(D * D - 1); // prior level distance
    vector<int64> dp(C, 0);
    for (int i = 0; i < C; i++) {
        if (grid[R - 1][i] == 'X') {
            dp[i] = 1;
        }
    }
    psum.assign(C, 0);
    for (int i = 0; i < C; i++) {
        psum[i] = dp[i];
        if (i > 0) psum[i] += psum[i - 1];
    }
    for (int i = 0; i < C; i++) {
        if (grid[R - 1][i] == 'X') {
            dp[i] = query(i - D, i + D);
        }
    }
    for (int r = R - 2; r >= 0; r--) {
        // prior level distance
        for (int i = 0; i < C; i++) {
            psum[i] = dp[i];
            if (i > 0) psum[i] = (psum[i] + psum[i - 1]) % MOD;
        }
        dp.assign(C, 0);
        for (int c = 0; c < C; c++) {
            if (grid[r][c] == 'X') {
                dp[c] = query(c - x, c + x);
            }
        }
        // level distance
        for (int i = 0; i < C; i++) {
            psum[i] = dp[i];
            if (i > 0) psum[i] = (psum[i] + psum[i - 1]) % MOD;
        }
        for (int i = 0; i < C; i++) {
            if (grid[r][i] == 'X') {
                dp[i] = query(i - D, i + D);
            }
        }
    }
    int64 ans = accumulate(dp.begin(), dp.end(), 0LL) % MOD;
    cout << ans << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1014 div 2

## Asuna and the Mosquitoes

### Solution 1: parity

```cpp
int N;
vector<int> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    int odd = 0, even = 0;
    for (int i = 0; i < N; i++) {
        cin >> A[i];
        if (A[i] & 1) odd++;
        else even++;
    }
    int64 sum = accumulate(A.begin(), A.end(), 0LL);
    int64 ans = 0;
    if (odd > 0 && even > 0) {
        ans = sum - (N - 1 - even);
    } else {
        ans = *max_element(A.begin(), A.end());
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Mishkin Energizer

### Solution 1: greedy, brute force

```cpp
const vector<char> lit = {'L', 'I', 'T'};
int N;
string S;
vector<int> pool[3];

void solve() {
    cin >> N >> S;
    vector<int> cnt(3, 0);
    for (int i = 0; i < 3; i++) pool[i].clear();
    for (int i = 0; i < N; i++) {
        int idx = find(lit.begin(), lit.end(), S[i]) - lit.begin();
        cnt[idx]++;
        if (i > 0) {
            int pidx = find(lit.begin(), lit.end(), S[i - 1]) - lit.begin();
            if (pidx != idx) {
                for (int j = 0; j < 3; j++) {
                    if (j != idx && j != pidx) {
                        pool[j].emplace_back(i);
                    }
                }
            }
        }
    }
    int target = *max_element(cnt.begin(), cnt.end());
    vector<int> ans;
    for (int i = 0; i < 2 * N; i++) {
        if (all_of(cnt.begin(), cnt.end(), [&](int x) { return x == target; })) {
            break;
        }
        vector<pair<int, int>> characters;
        for (int j = 0; j < 3; j++) {
            characters.emplace_back(cnt[j], j);
        }
        sort(characters.begin(), characters.end());
        for (const auto &[c, j] : characters) {
            if (!pool[j].empty()) {
                int idx = pool[j].back();
                pool[j].pop_back();
                ans.emplace_back(idx);
                cnt[j]++;
                target = max(target, cnt[j]);
                S.insert(S.begin() + idx, lit[j]);
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < pool[k].size(); l++) {
                        if (pool[k][l] > idx) pool[k][l]++;
                    }
                }
                // before
                int pj = find(lit.begin(), lit.end(), S[idx - 1]) - lit.begin();
                for (int k = 0; k < 3; k++) {
                    if (k != j && k != pj) {
                        pool[k].emplace_back(idx);
                    }
                }
                // after
                int nj = find(lit.begin(), lit.end(), S[idx + 1]) - lit.begin();
                for (int k = 0; k < 3; k++) {
                    if (k != j && k != nj) {
                        pool[k].emplace_back(idx + 1);
                    }
                }
                break;
            }
        }

    }
    if (any_of(cnt.begin(), cnt.end(), [&](int x) { return x != target; })) {
        cout << -1 << endl;
        return;
    }
    cout << ans.size() << endl;
    for (int x : ans) {
        cout << x << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## She Knows...

### Solution 1: 

```cpp

```

# Codeforces Round 1015 div 1+2

## You Soared Afar with Grace

### Solution 1: vector to map index and connections, implementation

```cpp
int N;
vector<int> A, B;
 
void solve() {
    cin >> N;
    A.assign(N, 0);
    B.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < N; i++) {
        cin >> B[i];
    }
    int eq = 0, eqi = -1;
    vector<int> idx(N + 1, -1);
    vector<int> val(N, -1);
    vector<int> out(N + 1, -1);
    for (int i = 0; i < N; i++) {
        if (A[i] == B[i]) {
            eq++;
            eqi = i;
        }
        out[A[i]] = B[i];
        idx[A[i]] = i;
        val[i] = A[i];
    }
    if (N % 2 == 0 && eq > 0) {
        cout << -1 << endl;
        return;
    }
    if (N & 1 && eq != 1) {
        cout << -1 << endl;
        return;
    }
    for (int i = 1; i <= N; i++) {
        if (out[out[i]] != i) {
            cout << -1 << endl;
            return;
        }
    }
    vector<pair<int ,int>> ans;
    if (N & 1 && eqi != N / 2) {
        ans.emplace_back(eqi, N / 2);
        int val1 = -1, val2 = -1;
        for (int v = 1; v <= N; v++) {
            if (idx[v] == N / 2) {
                val1 = v;
            }
            if (idx[v] == eqi) {
                val2 = v;
            }
        }
        swap(val[eqi], val[N / 2]);
        swap(idx[val1], idx[val2]);
    }
    for (int v = 1; v <= N; v++) {
        int i = idx[v];
        int x = out[v];
        if (idx[x] == N - i - 1) continue;
        // need to swap
        int y = val[N - i - 1];
        ans.emplace_back(idx[x], N - i - 1);
        swap(val[idx[x]], val[N - i - 1]);
        swap(idx[x], idx[y]);
    }
    cout << static_cast<int>(ans.size()) << endl;
    for (const auto &[x, y] : ans) {
        cout << x + 1 << " " << y + 1 << endl;
    }
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Arcology on Permafrost

### Solution 1: mex, contiguous blocks, greedy

1. Depends on the size sometimes the mex is greater than or equal to k, so you want to space out M + 1 blocks of size mex
2. Other times the mex is less than, so you fill in blocks of size k, but not completely only some will form mex, and do it M times with the remainder N - M * K

```cpp
int N, M, K;
 
void solve() {
    cin >> N >> M >> K;
    int mex = min(N / (M + 1), N - M * K);
    vector<int> ans(N, mex);
    if (N >= (M + 1) * K) {
        for (int i = 0; i < mex; i++) {
            for (int j = 0, k = i; j <= M && k < N; j++, k += mex) {
                ans[k] = i;
            }
        }
    } else {
        for (int i = 0; i < mex; i++) {
            for (int j = 0, k = i; j <= M && k < N; j++, k += K) {
                ans[k] = i;
            }
        }
    }
    for (int x : ans) {
        cout << x << " ";
    }
    cout << endl;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1016 div 3

## Skibidi Table

### Solution 1: 

```cpp
int N, Q;

pair<int, int> getCoordinates(int64 d) {
    int x1 = 1, y1 = 1, x2 = 1 << N, y2 = 1 << N;
    int64 numCells = 1LL << (2 * N), val = 0;
    while (numCells > 1) {
        numCells >>= 2;
        int dx = x2 - x1 + 1, dy = y2 - y1 + 1;
        if (val < d && d <= val + numCells) {
            x2 -= dx / 2;
            y2 -= dy / 2;
        } else if (val + numCells < d && d <= val + 2 * numCells) {
            x1 += dx / 2;
            y1 += dy / 2;
            val += numCells;
        } else if (val + 2 * numCells < d && d <= val + 3 * numCells) {
            x1 += dx / 2;
            y2 -= dy / 2;
            val += 2 * numCells;
        } else {
            y1 += dy / 2;
            x2 -= dx / 2;
            val += 3 * numCells;
        }
    }
    return {x1, y1};
}

int64 getValue(int x, int y) {
    int x1 = 0, y1 = 0, x2 = 1 << N, y2 = 1 << N;
    int64 numCells = 1LL << (2 * N), val = 1;
    while (numCells > 1) {
        numCells >>= 2;
        int dx = x2 - x1, dy = y2 - y1;
        if (x1 < x && x <= x2 - dx / 2 && y1 < y && y <= y2 - dy / 2) {
            x2 -= dx / 2;
            y2 -= dy / 2;
        } else if (x1 + dx / 2 < x && x <= x2 && y1 + dy / 2 < y && y <= y2) {
            x1 += dx / 2;
            y1 += dy / 2;
            val += numCells;
        } else if (x1 + dx / 2 < x && x <= x2 && y1 < y && y <= y2 - dy / 2) {
            x1 += dx / 2;
            y2 -= dy / 2;
            val += 2 * numCells;
        } else {
            y1 += dy / 2;
            x2 -= dx / 2;
            val += 3 * numCells;
        }
    }
    return val;
}

void solve() {
    cin >> N >> Q;
    while (Q--) {
        string s;
        cin >> s;
        if (s == "->") {
            int x, y;
            cin >> x >> y;
            cout << getValue(x, y) << endl;
        } else {
            int64 d;
            cin >> d;
            auto [x, y] = getCoordinates(d);
            cout << x << " " << y << endl;
        }
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Min Max MEX

### Solution 1: greedy binary search, mex, visited boolean array, two pointers

```cpp
int N, K;
vector<int> A;

bool possible(int target) {
    int cnt = 0;
    vector<bool> vis(target, false);
    int mex = 0;
    for (int i = 0; i < N; i++) {
        if (A[i] < target) vis[A[i]] = true;
        while (mex < target && vis[mex]) mex++;
        if (mex == target) {
            cnt++;
            mex = 0;
            fill(vis.begin(), vis.end(), false);
        }
    }
    return cnt >= K;
}

void solve() {
    cin >> N >> K;
    A.assign(N, 0);
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }
    int lo = 0, hi = N + 1;
    while (lo < hi) {
        int mid = lo + (hi - lo + 1) / 2;
        if (possible(mid)) lo = mid;
        else hi = mid - 1;
    }
    cout << lo << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Hackers and Neural Networks

### Solution 1: greedy, count

1. Weird to explain but this is way to guarantee minimize operations and guarantee you get the right answer.  Be careful to know it is not asking for expected values, but because of the randomness you'd instanlty think that. 

```cpp
int N, M;
vector<string> A;
vector<vector<string>> B;

void solve() {
    cin >> N >> M;
    A.assign(N, "");
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    B.assign(M, vector<string>(N));
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            cin >> B[i][j];
        }
    }
    vector<int> matchCount(M, 0);
    for (int i = 0; i < N; i++) {
        bool isGood = false;
        for (int j = 0; j < M; j++) {
            if (A[i] == B[j][i]) {
                isGood = true;
                matchCount[j]++;
            }
        }
        if (!isGood) {
            cout << -1 << endl;
            return;
        }
    }
    int maxCount = *max_element(matchCount.begin(), matchCount.end());
    int ans = N + 2 * (N - maxCount);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Shorten the Array

### Solution 1: bitwise trie, xor operation, maximize index variable in trie nodes

```cpp
const int BITS = 30;
int N, K;
vector<int> A;

struct Node {
    int children[2];
    int last;
    void init() {
        memset(children, 0, sizeof(children));
        last = -1;
    }
};
struct Trie {
    vector<Node> trie;
    void init() {
        Node root;
        root.init();
        trie.emplace_back(root);
    }
    void add(int mask, int idx) {
        int cur = 0;
        trie[cur].last = max(trie[cur].last, idx);
        for (int i = BITS - 1; i >= 0; i--) {
            int bit = (mask >> i) & 1;
            if (trie[cur].children[bit] == 0) {
                Node root;
                root.init();
                trie[cur].children[bit] = trie.size();
                trie.emplace_back(root);
            }
            cur = trie[cur].children[bit];
            trie[cur].last = max(trie[cur].last, idx);
        }
    }
    int find(int val, int border) {
        int cur = 0, ans = -1;
        bool isMatching = true;
        for (int i = BITS - 1; i >= 0 && isMatching; i--) {
            int valBit = (val >> i) & 1;
            int borderBit = (border >> i) & 1;
            if (borderBit) {
                if (trie[cur].children[valBit ^ 1] != 0) {
                    cur = trie[cur].children[valBit ^ 1];
                } else {
                    isMatching = false;
                }
            } else {
                if (trie[cur].children[valBit ^ 1] != 0) {
                    ans = max(ans, trie[trie[cur].children[valBit ^ 1]].last); // pointers to next node on this path. 
                }
                if (trie[cur].children[valBit] != 0) {
                    cur = trie[cur].children[valBit];
                } else {
                    isMatching = false;
                }
            }
        }
        if (isMatching) {
            ans = max(ans, trie[cur].last);
        }
        return ans;
    }
};

void solve() {
    cin >> N >> K;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    Trie trie;
    trie.init();
    int ans = N + 1;
    for (int i = 0; i < N; i++) {
        trie.add(A[i], i);
        int j = trie.find(A[i], K);
        if (j != -1) ans = min(ans, i - j + 1);
    }
    if (ans == N + 1) {
        cout << -1 << endl;
        return;
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

# Codeforces Round 1017 div 4

## Trulimero Trulicina

### Solution 1: remainder, greedy

1. Figure you can just place them in order if neither N or M is divisible by K, so you can just place them in order.
1. But if they are divisible you need to come up with some way to arrange them so they never overlap between rows or columns. 

```cpp
int N, M, K;

void solve() {
    cin >> N >> M >> K;
    debug(N, M, K, "\n");
    int cnt = N * M / K;
    vector<vector<int>> grid(N, vector<int>(M));
    vector<int> arr1(K), arr2(K);
    iota(arr1.begin(), arr1.end(), 1);
    iota(arr2.begin(), arr2.end(), 1);
    int idx = 0;
    bool flag = false;
    if (M % K == 0) {
        arr1.back() = 1;
        for (int i = 0; i + 1 < K; i++) {
            arr1[i] = i + 2;
        }
        for (int i = 1; i < K; i++) {
            arr2[i] = i + 1;
        }
        for (int i = 0; i < N; i++) {
            flag ^= 1;
            for (int j = 0; j < M; j++) {
                grid[i][j] = flag ? arr1[idx] : arr2[idx];
                idx = (idx + 1) % K;
            }
        }
    } else if (N % K == 0) {
        arr1.back() = 1;
        for (int i = 0; i + 1 < K; i++) {
            arr1[i] = i + 2;
        }
        for (int i = 1; i < K; i++) {
            arr2[i] = i + 1;
        }
        for (int j = 0; j < M; j++) {
            flag ^= 1;
            for (int i = 0; i < N; i++) {
                grid[i][j] = flag ? arr1[idx] : arr2[idx];
                idx = (idx + 1) % K;
            }
        }
    } else {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                grid[i][j] = arr1[idx];
                idx = (idx + 1) % K;
            }
        }
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cout << grid[i][j] << " ";
        }
        cout << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Chimpanzini Bananini

### Solution 1: deque, reverse boolean, summation, precomputation, math

1. The challenge is figuring out how to update the answer with each operation in O(1) time using the current variables of sum and ans and size of array.

```cpp
int Q;

void solve() {
    cin >> Q;
    deque<int64> arr;
    bool rev = false;
    int64 sum = 0, ans = 0;
    while (Q--) {
        int op;
        cin >> op;
        if (op == 1) {
            if (rev) {
                int64 x = arr.front();
                ans = ans + sum - arr.size() * x;
                arr.pop_front();
                arr.emplace_back(x);
            } else {
                int64 x = arr.back();
                ans = ans + sum - arr.size() * x;
                arr.pop_back();
                arr.emplace_front(x);
            }
        } else if (op == 2) {
            rev ^= 1;
            ans = (arr.size() + 1) * sum - ans;
        } else {
            int64 x;
            cin >> x;
            if (rev) arr.emplace_front(x);
            else arr.emplace_back(x);
            sum += x;
            ans += arr.size() * x;
        }
        cout << ans << endl;
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## La Vaca Saturno Saturnita

### Solution 1: number theory, divisors, jumps

```cpp

```

# Codeforces Round 1018 div x

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```