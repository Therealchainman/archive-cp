# Codeforces Round 1000-1049

# Codeforces Round 1000 div 2

## Game with Triangles

### Solution 1:  sorting, prefix sum, convexity, ternary search

1. sum of convex functions is convex, prefix sum from strictly decreasing sequence.

```cpp
int N, M;
vector<int> A, B;
vector<int64> psA, psB;

int64 f(int x, int y) {
    return psA[x] + psB[y - x];
}

void solve() {
    cin >> N >> M;
    A.resize(N);
    B.resize(M);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    for (int i = 0; i < M; i++) {
        cin >> B[i];
    }
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());
    psA.assign(N / 2 + 1, 0);
    psB.assign(M / 2 + 1, 0);
    for (int i = 0; i < N / 2; i++) {
        psA[i + 1] = A.end()[~i] - A[i] + psA[i];
    }
    for (int i = 0; i < M / 2; i++) {
        psB[i + 1] = B.end()[~i] - B[i] + psB[i];
    }
    int K = min({N, M, (N + M) / 3});
    cout << K << endl;
    for (int k = 1; k <= K; k++) {
        int l = max(0, 2 * k - M), r = min(k, N - k);
        while (r - l > 3) {
            int m1 = l + (r - l) / 3;
            int m2 = r - (r - l) / 3;
            int64 f1 = f(m1, k), f2 = f(m2, k);
            if (f1 < f2) l = m1 + 1;
            else r = m2 - 1;
        }
        int64 ans = 0;
        for (int i = l; i <= r; i++) {
            ans = max(ans, f(i, k));
        }
        cout << ans << " ";
    }
    cout << endl;   
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Triangle Tree

### Solution 1: 

```cpp

```

# Codeforces Round 1001 div 1+2

## Cirno and Operations

### Solution 1:  calculate difference arrays, brute force

1. Turns out the reversing just basically is like negating, so just calculate the sum of all the difference arrays, and take the max. 

```cpp
int N;
vector<int64> A;

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    int64 ans = accumulate(A.begin(), A.end(), 0LL);
    while (A.size() > 1) {
        vector<int64> B;
        for (int i = 1; i < A.size(); i++) {
            B.emplace_back(A[i] - A[i - 1]);
        }
        swap(A, B);
        int64 cand = accumulate(A.begin(), A.end(), 0LL);
        ans = max({ans, cand, -cand});
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

### Solution 2:  pascal's triangle, precomputation, loop over all scenarios, math

1. Derive the math, there is a simple relationship between the coefficients and the pascal's triangle
1. In addition you can try each size of polynomials from 1 to N.  
1. Derive on paper the mathematical relationship and code it, the reverse operation, just allows you two possible answers for each size of each element.
1. So I think of when I have combined 2 elements, 3 element, 4 elements and so on with the difference operation. 
1. The reverse operation just switches the signs actually, and can only apply when you have merged at least 2 elements.

```cpp
const int MAXN = 55, INF = 1e18;
int N;
vector<int> A;
int64 pascal[MAXN][MAXN];

void precompute(int N) {
    for (int i = 0; i < N; i++) {
        pascal[i][0] = pascal[i][i] = 1;
        for (int j = 1; j < i; j++) {
            pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]);
        }
    }
}

int64 calc(int idx, int l, int r, int64 m) {
    int64 ans = 0;
    for (int i = 0; i < r - l; i++) {
        ans += A[l + i] * ((i % 2 == 0) ? m : -1 * m) * pascal[idx][i];
    }
    return ans;
}

void solve() {
    cin >> N;
    A.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    int64 ans = -INF;
    for (int i = 1; i <= N; i++) {
        int64 cur1 = 0, cur2 = 0;
        for (int j = 0; j < N - i + 1; j++) {
            cur1 += calc(i - 1, j, j + i, 1);
            if (i > 1) cur2 += calc(i - 1, j, j + i, -1);
        }
        if (i == 1) cur2 = -INF;
        ans = max({ans, cur1, cur2});
    }
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    precompute(MAXN);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## Balanced Tree

### Solution 1: 

```cpp

```

## The Game (Easy Version)

### Solution 1: 

```cpp
int N, timer;
vector<int> values, tin, tout, timerToNode;
vector<vector<int>> adj;

void dfs(int u, int p = -1) {
    tin[u] = ++timer;
    timerToNode[timer] = u;
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
    }
    tout[u] = timer;
}

void solve() {
    cin >> N;
    adj.assign(N, vector<int>());
    values.assign(N, 0);
    for (int i = 0; i < N; i++) {
        cin >> values[i];
    }
    for (int i = 0; i < N - 1; i++) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj[u].emplace_back(v);
        adj[v].emplace_back(u);
    }
    tin.assign(N, 0);
    tout.assign(N, 0);
    timerToNode.assign(N + 1, 0);
    timer = 0;
    dfs(0);
    vector<int> pmax(N + 2, 0), smax(N + 2, 0);
    for (int i = 1; i <= N; ++i) {
        pmax[i] = max(pmax[i - 1], values[timerToNode[i]]);
    }
    for (int i = N; i > 0; --i) {
        smax[i] = max(smax[i + 1], values[timerToNode[i]]);
    }
    int64 ans = 0;
    for (int u = 0; u < N; ++u) {
        int maxAroundSubtree = max(pmax[tin[u] - 1], smax[tout[u] + 1]);
        if (maxAroundSubtree > values[u] && (!ans || values[u] > values[ans])) {
            ans = u;
        }
    }
    if (ans) ++ans;
    cout << ans  << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

# Codeforces Round 1002 div x

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```