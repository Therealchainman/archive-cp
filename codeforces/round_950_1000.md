# Codeforces Round 966 Div 3

## F. Color Rows and Columns

### Solution 1:  dynamic programming, precomputations

```cpp
const int INF = 1e9, MAXN = 1e3 + 5, MAXK = 102;
int n, k, ans;
int cost[MAXN][MAXK];

void calc(int idx, int a, int b) {
    int total = a + b, cur = 0;
    for (int i = 1; i <= min(total, MAXK - 1); i++) {
        if (a > b) swap(a, b);
        cur += a;
        cost[idx][i] = cur;
        b--;
    }

}

void solve() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        fill(cost[i], cost[i] + k + 1, INF);
        calc(i, a, b);
    }
    vector<int> dp(k + 1, INF), ndp;
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
        ndp.assign(k + 1, INF);
        for (int pts = 0; pts <= k; pts++) {
            ndp[pts] = dp[pts];
            for (int j = pts; j >= 0; j--) {
                ndp[pts] = min(ndp[pts], dp[pts - j] + cost[i][j]);
            }
        }
        swap(dp, ndp);
    }
    cout << (dp.back() < INF ? dp.back() : -1) << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}

```

## G. Call During the Journey

### Solution 1:  dijkstra variation, max heap, dynamic programming, undirected weighted graph

```cpp
const int INF = 1e9;
int N, M, t0, t1, t2;
vector<vector<pair<int, int>>> adj1, adj2;
vector<int> dp;
priority_queue<pair<int, int>, vector<pair<int, int>>> maxheap;

void solve() {
    cin >> N >> M;
    cin >> t0 >> t1 >> t2;
    adj1.assign(N, vector<pair<int,int>>()); // bus
    adj2.assign(N, vector<pair<int, int>>()); // street
    for (int i = 0; i < M; i++) {
        int u, v, w1, w2;
        cin >> u >> v >> w1 >> w2;
        u--, v--;
        adj1[u].emplace_back(v, w1);
        adj1[v].emplace_back(u, w1);
        adj2[u].emplace_back(v, w2);
        adj2[v].emplace_back(u, w2);
    }
    dp.assign(N, -INF);
    dp.back() = t0;
    maxheap.push({t0, N - 1});
    while (!maxheap.empty()) {
        auto [d, u] = maxheap.top();
        maxheap.pop();
        if (d < dp[u]) continue;
        for (auto [v, w] : adj1[u]) {
            if ((dp[u] - w < t2 && dp[u] - w >= t1) || (dp[u] - w < t1 && dp[u] >= t1)) {
                if (t1 - w > dp[v]) {
                    dp[v] = t1 - w;
                    maxheap.push({dp[v], v});
                }
                continue;
            }
            if (dp[v] < d - w) {
                dp[v] = d - w;
                maxheap.push({dp[v], v});
            }
        }
        for (auto [v, w] : adj2[u]) {
            if (dp[v] < d - w) {
                dp[v] = d - w;
                maxheap.push({dp[v], v});
            }
        }
    }
    if (dp[0] < 0) cout << -1 << endl;
    else cout << dp[0] << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```

## H. Ksyusha and the Loaded Set

### Solution 1:  

```cpp
const int NEUTRAL = 2e6 + 1;
int N, M;
set<int> dq[NEUTRAL + 1];
set<pair<int,int>> segments;
vector<int> vis;

// min segment tree for point updates and range queries
struct SegmentTree {
    int size;
    vector<int> nodes;

    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, NEUTRAL);
    }

    int func(int x, int y) {
        return min(x, y);
    }

    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }

    void update(int segment_idx, int val) {
        segment_idx += size;
        nodes[segment_idx] = val;
        segment_idx >>= 1;
        ascend(segment_idx);
    }

    int query(int left, int right) {
        left += size, right += size;
        int res = NEUTRAL;
        while (left <= right) {
            if (left & 1) {
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                res = func(res, nodes[right]);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};


SegmentTree seg;

void pair_insert(int x, int y) {
    if (y > 0) {
        vis.push_back(y);
        segments.insert({x, y});
        dq[y].insert(x);
        int s = *dq[y].begin(); // smallest element in the set with size = y
        seg.update(y, s);
    }
}

void remove(int x, int y) {
    if (y > 0) {
        vis.push_back(y);
        segments.erase({x, y});
        dq[y].erase(x);
        if (dq[y].empty()) {
            seg.update(y, NEUTRAL);
        }
        else {
            int s = *dq[y].begin(); // smallest element in the set with size = y
            seg.update(y, s);
        }
    }
}

void erase(int x) {
    auto it = segments.upper_bound({x, NEUTRAL});
    auto [sr, rsz] = *it;
    int sz = 1;
    bool match_right = sr == x + 1;
    if (it != segments.begin()) {
        it--;
        auto [sl, lsz] = *it;
        if (sl + lsz == x) {
            sz += lsz;
            x = sl;
            remove(sl, lsz);
        }
    }
    if (match_right) {
        sz += rsz;
        remove(sr, rsz);
    }
    pair_insert(x, sz);
}



void insert(int x) {
    auto it = segments.upper_bound({x, NEUTRAL});
    it--;
    auto [s, sz] = *it;
    remove(s, sz);
    int lsz = x - s;
    int rsz = sz - lsz - 1;
    pair_insert(s, lsz);
    pair_insert(x + 1, rsz);
}

void solve() {
    cin >> N;
    segments.clear();
    segments.insert({1, NEUTRAL});
    dq[NEUTRAL].insert(1);
    seg.update(NEUTRAL, 1);
    vis.clear();
    vis.push_back(NEUTRAL);
    for (int i = 0; i < N; i++) {
        int x;
        cin >> x;
        insert(x);
    }
    cin >> M;
    for (int i = 0; i < M; i++) {
        char ch;
        int x;
        cin >> ch >> x;
        if (ch == '+') {
            insert(x);
        } else if (ch == '-') {
            erase(x);
        } else {
            int ans = seg.query(x, NEUTRAL);
            cout << ans << " ";
        }
    }
    for (int sz : vis) {
        dq[sz].clear();
        seg.update(sz, NEUTRAL);
    }
    cout << endl;
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    seg.init(NEUTRAL);
    fill(dq, dq + NEUTRAL, set<int>());
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```
