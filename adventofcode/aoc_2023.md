# Advent of Code 2023

## Day 1: Trebuchet?!

### Part 2

```py
from collections import *
from functools import *
from itertools import *
import sys
# sys.stdin = open("input.txt", "r")
sys.stdout = open("output.txt", "w")

digits = {"one": "1", "two": "2", "three": "3", "four": "4", "five": "5", "six": "6", "seven": "7", "eight": "8", "nine": "9"}

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for s in data:
            left, right = 0, len(s) - 1
            left_dig = right_dig = None
            while left < len(s) and left_dig is None:
                if s[left].isdigit(): 
                    left_dig = s[left]
                    break
                for d, v in digits.items():
                    if d in s[:left + 1]:
                        left_dig = v
                left += 1
            while right >= 0 and right_dig is None:
                if s[right].isdigit(): 
                    right_dig = s[right]
                    break
                for d, v in digits.items():
                    if d in s[right:]:
                        right_dig = v
                right -= 1
            res += int(left_dig + right_dig)
        print(res)

if __name__ == '__main__':
    main()
```

## Day 2: 

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for line in data:
            cubes = {"red": 0, "green": 0, "blue": 0}
            # Use regular expression to extract game number and data
            match = re.match(r"Game (\d+): (.+)", line)
            game_number = int(match.group(1))
            game_data_str = match.group(2)
            # Split the game data into individual parts
            parts = game_data_str.split(';')
            # Extract and store data for each part
            flag = True
            for part in parts:
                data = re.findall(r"(\d+) (\w+)", part)
                
                # Extract up to 3 colors (blue, red, green) from each set
                color_values = {'blue': 0, 'red': 0, 'green': 0}
                for count, color in data:
                    if color in color_values:
                        color_values[color] = int(count)
                for color in color_values:
                    cubes[color] = max(cubes[color], color_values[color])
                # if not all(color_values[color] <= cubes[color] for color in color_values):
                #     flag = False
            res += math.prod(cubes.values())
            # if flag:
            #     res += game_number
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 3: 

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        dig = defaultdict(list)
        R, C = len(data), len(data[0])
        for r, line in enumerate(data):
            cur = 0
            start = None
            for c, x in enumerate(line):
                if x.isdigit():
                    if start is None:
                        start = c
                    cur = cur * 10 + int(x)
                else:
                    if start is not None:
                        dig[cur].append((r, start, c - 1))
                    start = None
                    cur = 0
            if start is not None:
                dig[cur].append((r, start, C - 1))
        def check(row, col):
            return data[row][col] == "*"
        gears = defaultdict(list)
        for val, tuples in dig.items():
            for r, c1, c2 in tuples:
                for c in range(max(0, c1 - 1), min(c2 + 2, C)):
                    if check(r, c):
                        gears[(r, c)].append(val)
                    if r > 0 and check(r - 1, c):
                        gears[(r - 1, c)].append(val)
                    if r < R - 1 and check(r + 1, c):
                        gears[(r + 1, c)].append(val) 
        res = sum(math.prod(values) for values in gears.values() if len(values) == 2)
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 4: 

### Part 1

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for i, line in enumerate(data):
            _, after_part = line.split(":")
            before, after = after_part.split("|")
            before_numbers = set(map(int, before.split()))
            after_numbers = list(map(int, after.split()))
            cnt = sum(1 for num in after_numbers if num in before_numbers)
            if cnt == 0: continue
            res += pow(2, cnt - 1)
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 4:

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        cards = [1] * len(data)         
        for card_index, line in enumerate(data):
            _, after_part = line.split(":")
            before, after = after_part.split("|")
            before_numbers = set(map(int, before.split()))
            after_numbers = list(map(int, after.split()))
            cnt = sum(1 for num in after_numbers if num in before_numbers)
            for i in range(card_index + 1, card_index + cnt + 1):
                cards[i] += cards[card_index]
        print(sum(cards))             

if __name__ == '__main__':
    main()
```

## Day 5: 

### Part 1

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        _, seeds = data[0].split(":")
        seeds = list(map(int, seeds.split()))
        ptr = 0
        maps = ["seed-to-soil", "soil-to-fertilizer", "fertilizer-to-water", "water-to-light", "light-to-temperature", "temperature-to-humidity", "humidity-to-location"]
        mappers = [[] for _ in range(len(maps))]
        for line in data[2:]:
            if line == "": 
                ptr += 1
                continue
            if maps[ptr] in line: continue
            dest, source, len_ = map(int, line.split())
            if maps[ptr] == "seed-to-soil":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "soil-to-fertilizer":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "fertilizer-to-water":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "light-to-temperature":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "temperature-to-humidity":
                mappers[ptr].append((source, dest, len_))
            else:
                mappers[ptr].append((source, dest, len_))
        for i in range(len(mappers)):
            mappers[i].sort()
        res = math.inf
        for i in range(0, len(seeds), 2):
            start = seeds[i]
            end = seeds[i] + seeds[i + 1]
            for seed in range(start, end):
                val = seed
                for i in range(len(mappers)):
                    j = bisect.bisect_right(mappers[i], (val, math.inf, math.inf)) - 1
                    if j == -1 or val > mappers[i][j][0] + mappers[i][j][2]: continue
                    else: val = mappers[i][j][1] + (val - mappers[i][j][0])
                res = min(res, val)
        print(res)      

if __name__ == '__main__':
    main()
```

## Day 5: 

### Part 2:  ranges, intersection of ranges, split ranges

```py
def apply_range(ranges, ma):
    ans = []
    for src, dst, len_ in ma:
        src_end = src + len_ # [src, src_end)
        new_ranges = []
        while ranges:
            s, e = ranges.pop()
            left = (s, min(src, e))
            mid = (max(s, src), min(e, src_end))
            right = (max(s, src_end), e)
            if left[1] > left[0]:
                new_ranges.append(left)
            if mid[1] > mid[0]:
                ans.append((dst + mid[0] - src, dst + mid[1] - src))
            if right[1] > right[0]:
                new_ranges.append(right)
        ranges = new_ranges
    ans.extend(ranges)
    return ans
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        _, seeds = data[0].split(":")
        seeds = list(map(int, seeds.split()))
        ptr = 0
        maps = ["seed-to-soil", "soil-to-fertilizer", "fertilizer-to-water", "water-to-light", "light-to-temperature", "temperature-to-humidity", "humidity-to-location"]
        mappers = [[] for _ in range(len(maps))]
        for line in data[2:]:
            if line == "": 
                ptr += 1
                continue
            if maps[ptr] in line: continue
            dest, source, len_ = map(int, line.split())
            if maps[ptr] == "seed-to-soil":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "soil-to-fertilizer":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "fertilizer-to-water":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "light-to-temperature":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "temperature-to-humidity":
                mappers[ptr].append((source, dest, len_))
            else:
                mappers[ptr].append((source, dest, len_))
        res = math.inf
        for i in range(0, len(seeds), 2):
            print("i", i)
            ranges = [(seeds[i], seeds[i] + seeds[i + 1])] # [s, e), length = e - s
            for ma in mappers:
                ranges = apply_range(ranges, ma)
                print("ranges: ", len(ranges))
            for s, _ in ranges:
                res = min(res, s)
        print(res)      

if __name__ == '__main__':
    main()

```

## Day 6: 

### Part 1

```py
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    _, times = data[0].split((":"))
    times = list(map(int, times.split()))
    _, distance = data[1].split(":")
    distance = list(map(int, distance.split()))
    res = 1
    for t, d in zip(times, distance):
        ways = 0
        for spd in range(t + 1):
            if spd * (t - spd) > d: ways += 1
        res *= ways
    print(res)

```

## Day 6:

### Part 2:  binary search, concatenate a list of strings, parabola

```py
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    _, times = data[0].split((":"))
    time = int("".join(times.split()))
    _, distances = data[1].split(":")
    distance = int("".join(distances.split()))
    peak = time // 2
    i = bisect.bisect_left(range(peak),  distance, key = lambda x: x * (time - x))
    j = bisect.bisect_right(range(peak, time + 1), False, key = lambda x: x * (time - x) <= distance) + peak
    print(j - i)
```

## Day 7: 

### Part 1

```py
def get_hand_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'J': 11, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}

    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1

    sorted_counts = sorted(card_counts.values(), reverse=True)

    if sorted_counts == [5]:
        # Five of a kind
        return (7, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [4, 1]:
        # Four of a kind
        return (6, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [3, 2]:
        # Full house
        return (5, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [3, 1, 1]:
        # Three of a kind
        return (4, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [2, 2, 1]:
        # Two pair
        return (3, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [2, 1, 1, 1]:
        # One pair
        return (2, [card_values[hand[i]] for i in range(5)])
    else:
        # High card
        return (1, [card_values[hand[i]] for i in range(5)])

with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    print(data)
    hands = []
    values = {}
    for i, line in enumerate(data):
        hand, val = line.split()
        val = int(val)
        values[i] = val
        hands.append((hand, i))
    
    def order_hands(hands):
        return sorted(hands, key = lambda x: get_hand_rank(x[0]), reverse = True)
    ordered_hands = order_hands(hands)
    res = 0
    rank = 1
    for hand, i in reversed(ordered_hands):
        res += rank * values[i]
        rank += 1
    print(res)
```

## Day 7: 

### Part 2

```py
def get_hand_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2, "J": 1}

    # Count occurrences of each card, including J acting as a wildcard
    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1
    hand_list = list(hand)
    # Use J as a wildcard to generate all possible hands
    cur_hands = [hand_list]
    for i in range(5):
        if hand[i] == "J":
            new_hands = []
            for cur_hand in cur_hands:
                for other_card in card_values.keys():
                    new_hand = cur_hand[:]
                    new_hand[i] = other_card
                    new_hands.append(new_hand)
            cur_hands = new_hands
    for i in range(len(cur_hands)):
        cur_hands[i] = "".join(cur_hands[i])
    # Calculate ranks for all possible hands and choose the best rank
    best_rank = calculate_rank(cur_hands[0]) # Initialize with positive infinity to ensure it gets updated
    best_hand = cur_hands[0]
    for possible_hand in cur_hands[1:]:
        current_rank = calculate_rank(possible_hand)
        if current_rank > best_rank:
            best_hand = possible_hand
            best_rank = current_rank
    return best_rank, [card_values[hand[i]] for i in range(5)]

def calculate_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2, "J": 1}

    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1

    sorted_counts = sorted(card_counts.values(), reverse=True)
    if sorted_counts == [5]:
        # Five of a kind
        return 7
    elif sorted_counts == [4, 1]:
        # Four of a kind
        return 6
    elif sorted_counts == [3, 2]:
        # Full house
        return 5
    elif sorted_counts == [3, 1, 1]:
        # Three of a kind
        return 4
    elif sorted_counts == [2, 2, 1]:
        # Two pair
        return 3
    elif sorted_counts == [2, 1, 1, 1]:
        # One pair
        return 2
    else:
        # High card
        return 1

with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    hands = []
    values = {}
    for i, line in enumerate(data):
        hand, val = line.split()
        val = int(val)
        values[i] = val
        hands.append((hand, i))
    
    def order_hands(hands):
        return sorted(hands, key = lambda x: get_hand_rank(x[0]), reverse = True)
    ordered_hands = order_hands(hands)
    res = 0
    rank = 1
    for hand, i in reversed(ordered_hands):
        res += rank * values[i]
        rank += 1
    print(res)
```

## Day 8: 

### Part 2: least common multiple LCM, number of steps between each Z for each node

```py
D = compile("{} = ({}, {})")
LIM = 1_000_000
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    instructions = data[0]
    n = len(instructions)
    dir = {}
    for line in data[2:]:
        f, L, R = D.parse(line).fixed
        dir[f] = (L, R)
    nodes = list(filter(lambda x: x[-1] == "A", dir.keys()))
    print(nodes)
    deltas = [0] * len(nodes)
    last = [0] * len(nodes)
    for i in range(LIM):
        for j in range(len(nodes)):
            if instructions[i % n] == "L":
                val = dir[nodes[j]][0]
                nodes[j] = val
                if val[-1] == "Z":
                    deltas[j]= i + 1 - last[j]
                    last[j] = i + 1
            else:
                val = dir[nodes[j]][1]
                nodes[j] = val
                if val[-1] == "Z":
                    deltas[j] = i + 1 - last[j]
                    last[j] = i + 1
    print(deltas)
    print(math.lcm(*deltas))
```

## Day 9: 

### Part 2:  math, arithmetic series

```py
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    grid = [list(map(int, line.split())) for line in data]
    res = 0
    for line in map(lambda x: x[::-1], grid):
        last = [line[-1]]
        while True:
            nxt_line = [0] * (len(line) - 1)
            for i in range(1, len(line)):
                nxt_line[i - 1] = line[i] - line[i - 1]
            line = nxt_line
            last.append(line[-1])
            if all(x == 0 for x in line): break
        res += sum(last)
    print(res)
```

### Solution 3:  matplotlib Path object, creates a path from a set of integer coordinates, and then you can determine how many points are inside that enclosed path

```py
connections = {
    (1, 0): "LJ|",
    (-1, 0): "F7|",
    (0, 1): "J7-",
    (0, -1): "FL-"
}
movements = {
        '|': "UD",
        '-': "LR",
        'L': "UR",
        'J': "UL",
        '7': "DL",
        'F': "DR",
        '.': "",
    }
directions = {
    "U": (-1, 0),
    "D": (1, 0),
    "R": (0, 1),
    "L": (0, -1),
}
def find_start(grid):
    R, C = len(grid), len(grid[0])
    for r, c in product(range(R), range(C)):
        if grid[r][c] == "S": return r, c
    return 0, 0
def find_loop(sr, sc, grid, vertices):
    res = 1
    r, c = sr, sc
    dr, dc = directions[movements[grid[sr][sc]][0]]
    pr, pc = sr, sc
    r += dr
    c += dc
    if grid[r][c] not in connections[(dr, dc)]: return -1
    found = True
    while found:
        res += 1
        vertices.append((r, c))
        found = False
        for heading in movements[grid[r][c]]:
            dr, dc = directions[heading]
            nr, nc = r + dr, c + dc
            if grid[nr][nc] not in connections[(dr, dc)]: return -1
            if (nr, nc) == (pr, pc): continue
            if (nr, nc) == (sr, sc): return res
            pr, pc = r, c
            r, c = nr, nc
            found = True
            break
    return -1
def path():
    res = 0
    p = Path(vertices)
    v_set = set(vertices)
    for r, c in product(range(R), range(C)):
        if (r, c) in v_set: continue
        if p.contains_point((r, c)): res += 1
    return res
with open("big.txt", "r") as f:
    data = f.read().splitlines()
    grid = [list(line) for line in data]
    R, C = len(grid), len(grid[0])
    sr, sc = find_start(grid)
    for pipe in "|-LJ7F":
        vertices = [(sr, sc)]
        grid[sr][sc] = pipe # try with this pipe
        num_nodes = find_loop(sr, sc, grid, vertices)
        if num_nodes > 0:
            part_1 = num_nodes // 2
            part_2 = path()
            print("part 1:", part_1)
            print("part 2:", part_2)
            break
```

## Day 10: 

### Solution 1: graph, cycle graph, simple cycle, point in polygon, ray casting, rectilinear polygon

```py
connections = {
    (1, 0): "LJ|",
    (-1, 0): "F7|",
    (0, 1): "J7-",
    (0, -1): "FL-"
}
movements = {
        '|': "UD",
        '-': "LR",
        'L': "UR",
        'J': "UL",
        '7': "DL",
        'F': "DR",
        '.': "",
    }
directions = {
    "U": (-1, 0),
    "D": (1, 0),
    "R": (0, 1),
    "L": (0, -1),
}
def find_start(grid):
    R, C = len(grid), len(grid[0])
    for r, c in product(range(R), range(C)):
        if grid[r][c] == "S": return r, c
    return 0, 0
def find_loop(sr, sc, grid, vis):
    res = 1
    r, c = sr, sc
    dr, dc = directions[movements[grid[sr][sc]][0]]
    pr, pc = sr, sc
    r += dr
    c += dc
    if grid[r][c] not in connections[(dr, dc)]: return -1
    found = True
    while found:
        res += 1
        vis[r][c] = 1
        found = False
        for heading in movements[grid[r][c]]:
            dr, dc = directions[heading]
            nr, nc = r + dr, c + dc
            if grid[nr][nc] not in connections[(dr, dc)]: return -1
            if (nr, nc) == (pr, pc): continue
            if (nr, nc) == (sr, sc): return res
            pr, pc = r, c
            r, c = nr, nc
            found = True
            break
    return -1
def point_in_polygon(grid, vis):
    R, C = len(grid), len(grid[0])
    inside = 0
    for r in range(R):
        up = down = 0
        for c in range(C):
            if not vis[r][c] and up and down:
                inside += 1
            if vis[r][c]:
                for heading in movements[grid[r][c]]:
                    if heading == "U": up ^= 1
                    if heading == "D": down ^= 1
    return inside
def main():
    with open("big.txt", "r") as f:
        data = f.read().splitlines()
        grid = [list(line) for line in data]
        R, C = len(grid), len(grid[0])
        sr, sc = find_start(grid)
        for pipe in "|-LJ7F":
            vis = [[0] * C for _ in range(R)]
            vis[sr][sc] = 1
            grid[sr][sc] = pipe # try with this pipe
            num_nodes = find_loop(sr, sc, grid, vis)
            if num_nodes > 0:
                part_1 = num_nodes // 2
                part_2 = point_in_polygon(grid, vis)
                return part_1, part_2
p1, p2 = main()
print("part 1:", p1)
print("part 2:", p2)
```

### Solution 2:  simple cycle, cycle graph, shoelace formula, pick's theorem, lattice polygon

```py
connections = {
    (1, 0): "LJ|",
    (-1, 0): "F7|",
    (0, 1): "J7-",
    (0, -1): "FL-"
}
movements = {
        '|': "UD",
        '-': "LR",
        'L': "UR",
        'J': "UL",
        '7': "DL",
        'F': "DR",
        '.': "",
    }
directions = {
    "U": (-1, 0),
    "D": (1, 0),
    "R": (0, 1),
    "L": (0, -1),
}
def find_start(grid):
    R, C = len(grid), len(grid[0])
    for r, c in product(range(R), range(C)):
        if grid[r][c] == "S": return r, c
    return 0, 0
def find_loop(sr, sc, grid, vertices):
    res = 1
    r, c = sr, sc
    dr, dc = directions[movements[grid[sr][sc]][0]]
    pr, pc = sr, sc
    r += dr
    c += dc
    if grid[r][c] not in connections[(dr, dc)]: return -1
    found = True
    while found:
        res += 1
        vertices.append((r, c))
        found = False
        for heading in movements[grid[r][c]]:
            dr, dc = directions[heading]
            nr, nc = r + dr, c + dc
            if grid[nr][nc] not in connections[(dr, dc)]: return -1
            if (nr, nc) == (pr, pc): continue
            if (nr, nc) == (sr, sc): return res
            pr, pc = r, c
            r, c = nr, nc
            found = True
            break
    return -1
def shoelace(vertices):
    double_area = 0
    n = len(vertices)
    for i in range(n):
        x1, y1 = vertices[i]
        x2, y2 = vertices[(i + 1) % n]
        double_area += x1 * y2 - x2 * y1
    double_area = abs(double_area)
    return double_area // 2
# find number of interior points
def picks_theorem(A, b):
    return A - b // 2 + 1
def main():
    with open("big.txt", "r") as f:
        data = f.read().splitlines()
        grid = [list(line) for line in data]
        R, C = len(grid), len(grid[0])
        sr, sc = find_start(grid)
        for pipe in "|-LJ7F":
            vertices = [(sr, sc)]
            grid[sr][sc] = pipe # try with this pipe
            num_nodes = find_loop(sr, sc, grid, vertices)
            if num_nodes > 0:
                part_1 = num_nodes // 2
                part_2 = picks_theorem(shoelace(vertices), num_nodes)
                return part_1, part_2
p1, p2 = main()
print("part 1:", p1)
print("part 2:", p2)
```

## Day 11: 

### Part 2, grid, prefix sum, manhattan distance

```py
def solve(m):
    with open("input.txt", "r") as f:
        data = f.read().splitlines()
        R, C = len(data), len(data[0])
        grid = [list(line) for line in data]
        rows = [0] * R
        cols = [0] * C
        prows = [0] * (R + 1)
        pcols = [0] * (C + 1)
        nodes = []
        # mark non empty rows
        for r, c in product(range(R), range(C)):
            if grid[r][c] == "#":
                rows[r] = cols[c] = 1
                nodes.append((r, c))
        # create prefix sum, including the size for the empty rows and columns
        for r in range(R):
            prows[r + 1] = prows[r] + (m - 1) * (rows[r] == 0)
        for c in range(C):
            pcols[c + 1] = pcols[c] + (m - 1) * (cols[c] == 0)
        def calc(x1, x2, psum):
            xmax, xmin = max(x1, x2), min(x1, x2)
            return xmax - xmin + psum[xmax] - psum[xmin]
        res = 0
        # manhattan distance between each pair of galaxy and
        # for rows and colums independently do the following
        # for example with rows it is [rmin, rmax), which will include all the emtpy rows and the count of empty space between
        for i in range(len(nodes)):
            for j in range(i):
                r1, c1 = nodes[i]
                r2, c2 = nodes[j]
                dist_r = calc(r1, r2, prows)
                dist_c = calc(c1, c2, pcols)
                res += dist_r + dist_c
        return res
assert solve(1_000_000) == 791134099634
```

## Day 12: 

### Solution 1:  dynamic programming with bags

```py
def solve(elements, groups):
    # state = (current group size, current group index, last character)
    bags = Counter()
    if elements[0] == "?" or elements[0] == "#":
        bags[(1, 0)] += 1
    if elements[0] == "?" or elements[0] == ".":
        bags[(0, 0)] += 1
    n = len(elements)
    m = len(groups)
    for i in range(1, n):
        new_bags = Counter()
        for (cur, j), cnt in bags.items():
            if elements[i] == ".":
                if cur == 0:
                    new_bags[(0, j)] += cnt
                elif cur == groups[j]:
                    new_bags[(0, j + 1)] += cnt
            elif elements[i] == "#":
                if j < m and cur < groups[j]:
                    new_bags[(cur + 1, j)] += cnt
            else:
                if cur == 0:
                    new_bags[(0, j)] += cnt
                    if j < m:
                        new_bags[(1, j)] += cnt
                elif cur == groups[j]:
                    new_bags[(0, j + 1)] += cnt
                elif cur > 0:
                    new_bags[(cur + 1, j)] += cnt
        bags = new_bags
    return sum(cnt for (_, j), cnt in bags.items() if j == m)
def parts(sz):
    with open("big.txt", "r") as f:
        data = f.read().splitlines()
        res = 0
        for line in data:
            first, second = line.split()
            start = list(map(int, second.split(",")))
            elements = "?".join([first for _ in range(sz)]) + "."
            groups = []
            for _ in range(sz):
                groups.extend(start)
            res += solve(elements, groups)
        return res
print("part 1:", parts(1))
print("part 2:", parts(5))
```

## Day 13: 

### Solution 1: 

```py

```

## Day 14: 

### Solution 1: 

```py

```

## Day 15: 

### Solution 1: 

```py

```

## Day 16: 

### Solution 1: 

```py

```

## Day 17: 

### Solution 1: 

```py

```