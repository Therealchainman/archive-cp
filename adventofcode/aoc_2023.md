# Advent of Code 2023

## Day 1: Trebuchet?!

### Part 2

```py
from collections import *
from functools import *
from itertools import *
import sys
# sys.stdin = open("input.txt", "r")
sys.stdout = open("output.txt", "w")

digits = {"one": "1", "two": "2", "three": "3", "four": "4", "five": "5", "six": "6", "seven": "7", "eight": "8", "nine": "9"}

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for s in data:
            left, right = 0, len(s) - 1
            left_dig = right_dig = None
            while left < len(s) and left_dig is None:
                if s[left].isdigit(): 
                    left_dig = s[left]
                    break
                for d, v in digits.items():
                    if d in s[:left + 1]:
                        left_dig = v
                left += 1
            while right >= 0 and right_dig is None:
                if s[right].isdigit(): 
                    right_dig = s[right]
                    break
                for d, v in digits.items():
                    if d in s[right:]:
                        right_dig = v
                right -= 1
            res += int(left_dig + right_dig)
        print(res)

if __name__ == '__main__':
    main()
```

## Day 2: 

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for line in data:
            cubes = {"red": 0, "green": 0, "blue": 0}
            # Use regular expression to extract game number and data
            match = re.match(r"Game (\d+): (.+)", line)
            game_number = int(match.group(1))
            game_data_str = match.group(2)
            # Split the game data into individual parts
            parts = game_data_str.split(';')
            # Extract and store data for each part
            flag = True
            for part in parts:
                data = re.findall(r"(\d+) (\w+)", part)
                
                # Extract up to 3 colors (blue, red, green) from each set
                color_values = {'blue': 0, 'red': 0, 'green': 0}
                for count, color in data:
                    if color in color_values:
                        color_values[color] = int(count)
                for color in color_values:
                    cubes[color] = max(cubes[color], color_values[color])
                # if not all(color_values[color] <= cubes[color] for color in color_values):
                #     flag = False
            res += math.prod(cubes.values())
            # if flag:
            #     res += game_number
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 3: 

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        dig = defaultdict(list)
        R, C = len(data), len(data[0])
        for r, line in enumerate(data):
            cur = 0
            start = None
            for c, x in enumerate(line):
                if x.isdigit():
                    if start is None:
                        start = c
                    cur = cur * 10 + int(x)
                else:
                    if start is not None:
                        dig[cur].append((r, start, c - 1))
                    start = None
                    cur = 0
            if start is not None:
                dig[cur].append((r, start, C - 1))
        def check(row, col):
            return data[row][col] == "*"
        gears = defaultdict(list)
        for val, tuples in dig.items():
            for r, c1, c2 in tuples:
                for c in range(max(0, c1 - 1), min(c2 + 2, C)):
                    if check(r, c):
                        gears[(r, c)].append(val)
                    if r > 0 and check(r - 1, c):
                        gears[(r - 1, c)].append(val)
                    if r < R - 1 and check(r + 1, c):
                        gears[(r + 1, c)].append(val) 
        res = sum(math.prod(values) for values in gears.values() if len(values) == 2)
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 4: 

### Part 1

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = 0
        for i, line in enumerate(data):
            _, after_part = line.split(":")
            before, after = after_part.split("|")
            before_numbers = set(map(int, before.split()))
            after_numbers = list(map(int, after.split()))
            cnt = sum(1 for num in after_numbers if num in before_numbers)
            if cnt == 0: continue
            res += pow(2, cnt - 1)
        print(res)             

if __name__ == '__main__':
    main()
```

## Day 4:

### Part 2

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        cards = [1] * len(data)         
        for card_index, line in enumerate(data):
            _, after_part = line.split(":")
            before, after = after_part.split("|")
            before_numbers = set(map(int, before.split()))
            after_numbers = list(map(int, after.split()))
            cnt = sum(1 for num in after_numbers if num in before_numbers)
            for i in range(card_index + 1, card_index + cnt + 1):
                cards[i] += cards[card_index]
        print(sum(cards))             

if __name__ == '__main__':
    main()
```

## Day 5: 

### Part 1

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        _, seeds = data[0].split(":")
        seeds = list(map(int, seeds.split()))
        ptr = 0
        maps = ["seed-to-soil", "soil-to-fertilizer", "fertilizer-to-water", "water-to-light", "light-to-temperature", "temperature-to-humidity", "humidity-to-location"]
        mappers = [[] for _ in range(len(maps))]
        for line in data[2:]:
            if line == "": 
                ptr += 1
                continue
            if maps[ptr] in line: continue
            dest, source, len_ = map(int, line.split())
            if maps[ptr] == "seed-to-soil":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "soil-to-fertilizer":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "fertilizer-to-water":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "light-to-temperature":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "temperature-to-humidity":
                mappers[ptr].append((source, dest, len_))
            else:
                mappers[ptr].append((source, dest, len_))
        for i in range(len(mappers)):
            mappers[i].sort()
        res = math.inf
        for i in range(0, len(seeds), 2):
            start = seeds[i]
            end = seeds[i] + seeds[i + 1]
            for seed in range(start, end):
                val = seed
                for i in range(len(mappers)):
                    j = bisect.bisect_right(mappers[i], (val, math.inf, math.inf)) - 1
                    if j == -1 or val > mappers[i][j][0] + mappers[i][j][2]: continue
                    else: val = mappers[i][j][1] + (val - mappers[i][j][0])
                res = min(res, val)
        print(res)      

if __name__ == '__main__':
    main()
```

## Day 5: 

### Part 2:  ranges, intersection of ranges, split ranges

```py
def apply_range(ranges, ma):
    ans = []
    for src, dst, len_ in ma:
        src_end = src + len_ # [src, src_end)
        new_ranges = []
        while ranges:
            s, e = ranges.pop()
            left = (s, min(src, e))
            mid = (max(s, src), min(e, src_end))
            right = (max(s, src_end), e)
            if left[1] > left[0]:
                new_ranges.append(left)
            if mid[1] > mid[0]:
                ans.append((dst + mid[0] - src, dst + mid[1] - src))
            if right[1] > right[0]:
                new_ranges.append(right)
        ranges = new_ranges
    ans.extend(ranges)
    return ans
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        _, seeds = data[0].split(":")
        seeds = list(map(int, seeds.split()))
        ptr = 0
        maps = ["seed-to-soil", "soil-to-fertilizer", "fertilizer-to-water", "water-to-light", "light-to-temperature", "temperature-to-humidity", "humidity-to-location"]
        mappers = [[] for _ in range(len(maps))]
        for line in data[2:]:
            if line == "": 
                ptr += 1
                continue
            if maps[ptr] in line: continue
            dest, source, len_ = map(int, line.split())
            if maps[ptr] == "seed-to-soil":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "soil-to-fertilizer":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "fertilizer-to-water":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "light-to-temperature":
                mappers[ptr].append((source, dest, len_))
            elif maps[ptr] == "temperature-to-humidity":
                mappers[ptr].append((source, dest, len_))
            else:
                mappers[ptr].append((source, dest, len_))
        res = math.inf
        for i in range(0, len(seeds), 2):
            print("i", i)
            ranges = [(seeds[i], seeds[i] + seeds[i + 1])] # [s, e), length = e - s
            for ma in mappers:
                ranges = apply_range(ranges, ma)
                print("ranges: ", len(ranges))
            for s, _ in ranges:
                res = min(res, s)
        print(res)      

if __name__ == '__main__':
    main()

```

## Day 6: 

### Part 1

```py
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    _, times = data[0].split((":"))
    times = list(map(int, times.split()))
    _, distance = data[1].split(":")
    distance = list(map(int, distance.split()))
    res = 1
    for t, d in zip(times, distance):
        ways = 0
        for spd in range(t + 1):
            if spd * (t - spd) > d: ways += 1
        res *= ways
    print(res)

```

## Day 6:

### Part 2:  binary search, concatenate a list of strings, parabola

```py
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    _, times = data[0].split((":"))
    time = int("".join(times.split()))
    _, distances = data[1].split(":")
    distance = int("".join(distances.split()))
    peak = time // 2
    i = bisect.bisect_left(range(peak),  distance, key = lambda x: x * (time - x))
    j = bisect.bisect_right(range(peak, time + 1), False, key = lambda x: x * (time - x) <= distance) + peak
    print(j - i)
```

## Day 7: 

### Part 1

```py
def get_hand_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'J': 11, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}

    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1

    sorted_counts = sorted(card_counts.values(), reverse=True)

    if sorted_counts == [5]:
        # Five of a kind
        return (7, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [4, 1]:
        # Four of a kind
        return (6, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [3, 2]:
        # Full house
        return (5, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [3, 1, 1]:
        # Three of a kind
        return (4, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [2, 2, 1]:
        # Two pair
        return (3, [card_values[hand[i]] for i in range(5)])
    elif sorted_counts == [2, 1, 1, 1]:
        # One pair
        return (2, [card_values[hand[i]] for i in range(5)])
    else:
        # High card
        return (1, [card_values[hand[i]] for i in range(5)])

with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    print(data)
    hands = []
    values = {}
    for i, line in enumerate(data):
        hand, val = line.split()
        val = int(val)
        values[i] = val
        hands.append((hand, i))
    
    def order_hands(hands):
        return sorted(hands, key = lambda x: get_hand_rank(x[0]), reverse = True)
    ordered_hands = order_hands(hands)
    res = 0
    rank = 1
    for hand, i in reversed(ordered_hands):
        res += rank * values[i]
        rank += 1
    print(res)
```

## Day 7: 

### Part 2

```py
def get_hand_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2, "J": 1}

    # Count occurrences of each card, including J acting as a wildcard
    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1
    hand_list = list(hand)
    # Use J as a wildcard to generate all possible hands
    cur_hands = [hand_list]
    for i in range(5):
        if hand[i] == "J":
            new_hands = []
            for cur_hand in cur_hands:
                for other_card in card_values.keys():
                    new_hand = cur_hand[:]
                    new_hand[i] = other_card
                    new_hands.append(new_hand)
            cur_hands = new_hands
    for i in range(len(cur_hands)):
        cur_hands[i] = "".join(cur_hands[i])
    # Calculate ranks for all possible hands and choose the best rank
    best_rank = calculate_rank(cur_hands[0]) # Initialize with positive infinity to ensure it gets updated
    best_hand = cur_hands[0]
    for possible_hand in cur_hands[1:]:
        current_rank = calculate_rank(possible_hand)
        if current_rank > best_rank:
            best_hand = possible_hand
            best_rank = current_rank
    return best_rank, [card_values[hand[i]] for i in range(5)]

def calculate_rank(hand):
    card_counts = {}
    card_values = {'A': 14, 'K': 13, 'Q': 12, 'T': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2, "J": 1}

    for card in hand:
        if card in card_counts:
            card_counts[card] += 1
        else:
            card_counts[card] = 1

    sorted_counts = sorted(card_counts.values(), reverse=True)
    if sorted_counts == [5]:
        # Five of a kind
        return 7
    elif sorted_counts == [4, 1]:
        # Four of a kind
        return 6
    elif sorted_counts == [3, 2]:
        # Full house
        return 5
    elif sorted_counts == [3, 1, 1]:
        # Three of a kind
        return 4
    elif sorted_counts == [2, 2, 1]:
        # Two pair
        return 3
    elif sorted_counts == [2, 1, 1, 1]:
        # One pair
        return 2
    else:
        # High card
        return 1

with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    hands = []
    values = {}
    for i, line in enumerate(data):
        hand, val = line.split()
        val = int(val)
        values[i] = val
        hands.append((hand, i))
    
    def order_hands(hands):
        return sorted(hands, key = lambda x: get_hand_rank(x[0]), reverse = True)
    ordered_hands = order_hands(hands)
    res = 0
    rank = 1
    for hand, i in reversed(ordered_hands):
        res += rank * values[i]
        rank += 1
    print(res)
```

## Day 8: 

### Part 2: least common multiple LCM, number of steps between each Z for each node

```py
D = compile("{} = ({}, {})")
LIM = 1_000_000
with open('input.txt', 'r') as f:
    data = f.read().splitlines()
    instructions = data[0]
    n = len(instructions)
    dir = {}
    for line in data[2:]:
        f, L, R = D.parse(line).fixed
        dir[f] = (L, R)
    nodes = list(filter(lambda x: x[-1] == "A", dir.keys()))
    print(nodes)
    deltas = [0] * len(nodes)
    last = [0] * len(nodes)
    for i in range(LIM):
        for j in range(len(nodes)):
            if instructions[i % n] == "L":
                val = dir[nodes[j]][0]
                nodes[j] = val
                if val[-1] == "Z":
                    deltas[j]= i + 1 - last[j]
                    last[j] = i + 1
            else:
                val = dir[nodes[j]][1]
                nodes[j] = val
                if val[-1] == "Z":
                    deltas[j] = i + 1 - last[j]
                    last[j] = i + 1
    print(deltas)
    print(math.lcm(*deltas))
```

## Day 9: 

### Part 2

```py

```

## Day 10: 

### Part 2

```py

```

## Day 11: 

### Part 2

```py

```