# Advent of Code 2024

## Day 1

### Solution 1:  sorting, counter

```py
A, B = [], []
with open("big.txt", "r") as f:
    for line in f:
        left, right = map(int, line.split()) 
        A.append(left)
        B.append(right)
    A.sort()
    B.sort()
    p1 = 0
    for x, y in zip(A, B):
        p1 += abs(x - y)
    p2 = 0
    a = Counter(A)
    b = Counter(B)
    for v in A:
        p2 += v * b[v]
    print("part 1:", p1)
    print("part 2:", p2)
```

## Day 2

### Solution 1:  strictly increasing array

1. The trick is to just try the original data and reversed, so only need the logic for strictly increasing array.
1. Then encode that and include the logic to allow for one violation, and check if that is removed if it become strictly increasing

```py
from typing import List

def is_valid(row: List[int]) -> bool:
    """
    Check if a row satisfies gradient conditions in original or reversed order.
    """
    return is_gradient(copy.deepcopy(row)) or is_gradient(row[::-1])

def find_marked_indices(data: List[int], difference_max: int = 3) -> List[int]:
    """
    Find indices where the difference between consecutive elements exceeds the threshold.
    """
    return [i for i in range(1, len(data)) if not (1 <= data[i] - data[i - 1] <= difference_max)]

def is_increasing_with_limit(data: List[int], limit: int) -> bool:
    """
    Check if the data is strictly increasing, with differences within the specified limit.
    """
    return all(data[i] > data[i - 1] and data[i] - data[i - 1] <= limit for i in range(1, len(data)))

def remove_and_check(data: List[int], index: int, limit: int) -> bool:
    """
    Remove an element at the specified index, check if the remaining list satisfies conditions,
    and reinsert the element.
    """
    removed_value = data.pop(index)
    is_valid = is_increasing_with_limit(data, limit)
    data.insert(index, removed_value)
    return is_valid

def is_gradient(data: List[int], difference_threshold: int = 3) -> bool:
    """
    Check if the data satisfies gradient conditions, allowing one violation.
    """
    marked_indices = find_marked_indices(data, difference_threshold)
    if not marked_indices: return True
    bad_index = marked_indices[0]
    for i in range(bad_index - 1, bad_index + 1):
        if i < 0: continue
        if remove_and_check(data, i, difference_threshold): return True
    return False

def calculate(filename: str):
    """
    Read a grid from a file and count rows that satisfy the gradient conditions.
    """
    with open(filename, "r") as f:
        grid = [list(map(int, line.split())) for line in f.read().splitlines()]
    ans = sum(1 for row in grid if is_valid(row))
    print(ans)
calculate("small.txt")
calculate("big.txt")
```

## Day 3

### Solution 1:  regex, multiple regex patterns, iteration

```py
import re
def calculate(filename: str):
    """
    Read a grid from a file and count rows that satisfy the gradient conditions.
    """
    with open(filename, "r") as f:
        data = f.read()
        enabled = True
        ans = 0
        mul_pattern = re.compile(r"mul\((\d{1,3}),(\d{1,3})\)")
        do_pattern = re.compile(r"do\(\)")
        dont_pattern = re.compile(r"don't\(\)")
        i = 0
        while i < len(data):
            mul_match = mul_pattern.match(data, i)
            do_match = do_pattern.match(data, i)
            dont_match = dont_pattern.match(data, i)
            if mul_match:
                if enabled:
                    x, y = map(int, mul_match.groups())
                    ans += x * y
                i = mul_match.end()
            elif do_match:
                enabled = True
                i = do_match.end()
            elif dont_match:
                enabled = False 
                i = dont_match.end()
            else:
                i += 1
    print(ans)
calculate("small.txt")
calculate("big.txt")
```

## Day 4

### Solution 1: 

```py

```

## Day 5

### Solution 1: 

```py

```

## Day 6

### Solution 1: 

```py

```