# Advent of Code 2024

## Day 1

### Solution 1:  sorting, counter

```py
A, B = [], []
with open("big.txt", "r") as f:
    for line in f:
        left, right = map(int, line.split()) 
        A.append(left)
        B.append(right)
    A.sort()
    B.sort()
    p1 = 0
    for x, y in zip(A, B):
        p1 += abs(x - y)
    p2 = 0
    a = Counter(A)
    b = Counter(B)
    for v in A:
        p2 += v * b[v]
    print("part 1:", p1)
    print("part 2:", p2)
```

## Day 2

### Solution 1:  strictly increasing array

1. The trick is to just try the original data and reversed, so only need the logic for strictly increasing array.
1. Then encode that and include the logic to allow for one violation, and check if that is removed if it become strictly increasing

```py
from typing import List

def is_valid(row: List[int]) -> bool:
    """
    Check if a row satisfies gradient conditions in original or reversed order.
    """
    return is_gradient(copy.deepcopy(row)) or is_gradient(row[::-1])

def find_marked_indices(data: List[int], difference_max: int = 3) -> List[int]:
    """
    Find indices where the difference between consecutive elements exceeds the threshold.
    """
    return [i for i in range(1, len(data)) if not (1 <= data[i] - data[i - 1] <= difference_max)]

def is_increasing_with_limit(data: List[int], limit: int) -> bool:
    """
    Check if the data is strictly increasing, with differences within the specified limit.
    """
    return all(data[i] > data[i - 1] and data[i] - data[i - 1] <= limit for i in range(1, len(data)))

def remove_and_check(data: List[int], index: int, limit: int) -> bool:
    """
    Remove an element at the specified index, check if the remaining list satisfies conditions,
    and reinsert the element.
    """
    removed_value = data.pop(index)
    is_valid = is_increasing_with_limit(data, limit)
    data.insert(index, removed_value)
    return is_valid

def is_gradient(data: List[int], difference_threshold: int = 3) -> bool:
    """
    Check if the data satisfies gradient conditions, allowing one violation.
    """
    marked_indices = find_marked_indices(data, difference_threshold)
    if not marked_indices: return True
    bad_index = marked_indices[0]
    for i in range(bad_index - 1, bad_index + 1):
        if i < 0: continue
        if remove_and_check(data, i, difference_threshold): return True
    return False

def calculate(filename: str):
    """
    Read a grid from a file and count rows that satisfy the gradient conditions.
    """
    with open(filename, "r") as f:
        grid = [list(map(int, line.split())) for line in f.read().splitlines()]
    ans = sum(1 for row in grid if is_valid(row))
    print(ans)
calculate("small.txt")
calculate("big.txt")
```

## Day 3

### Solution 1:  regex, re finditer, capture groups

1. The things to practice is that re.finditer will find all matches to the pattern.
1. The pattern is designed to match multiple patterns by using the logical or operator | to separate subpatterns so if it matches any it will return a match
1. Then they will be matched in order in the re.finditer, so then just need to check if the match substring with group() is do or don't
1. And then use the capturing groups to get the numbers.

```py
import re
def calculate(filename: str):
    """
    Read a grid from a file and count rows that satisfy the gradient conditions.
    """
    with open(filename, "r") as f:
        data = f.read()
        enabled = 1
        ans = 0
        pattern = r"mul\((\d{1,3}),(\d{1,3})\)|do\(\)|don't\(\)"
        for match in re.finditer(pattern, data):
            if match.group() == "do()":
                enabled |= 1
            elif match.group() == "don't()":
                enabled &= 0
            else:
                if enabled:
                    x, y = map(int, match.groups())
                    ans += x * y
    print(ans)
calculate("small.txt")
calculate("big.txt")
```

## Day 4

### Solution 1:  grid, diagonals in grid

```py
from enum import Enum
from collections import Counter
from typing import List, Generator, Tuple
from itertools import product

class Xmas(Enum):
    """
    Enum representing different symbols in the grid and their corresponding integer values.
    """
    M = 0  # Represents the "M" symbol.
    S = 1  # Represents the "S" symbol.
    A = 2  # Represents the "A" symbol.
    X = 3  # Represents the "X" symbol.

class XmasGrid:
    """
    A class to handle loading, processing, and analyzing a grid for specific patterns.
    """
    
    def __init__(self) -> None:
        """
        Initialize an empty grid with dimensions set to zero.
        """
        self.R: int = 0  # Number of rows in the grid
        self.C: int = 0  # Number of columns in the grid
        self.grid: List[str] = []  # The grid itself, stored as a list of strings
    
    def load(self, filename: str) -> None:
        """
        Load the grid from a file.

        Args:
            filename (str): The name of the file containing the grid.
        """
        with open(filename, "r") as f:
            self.grid = f.read().splitlines()
            self.R = len(self.grid)
            self.C = len(self.grid[0]) if self.R > 0 else 0
    
    def in_bounds(self, r: int, c: int) -> bool:
        """
        Check if a given coordinate is within the bounds of the grid.

        Args:
            r (int): Row index.
            c (int): Column index.

        Returns:
            bool: True if the coordinate is within bounds, False otherwise.
        """
        return 0 <= r < self.R and 0 <= c < self.C
    
    def diagonal_vectors(self, r: int, c: int) -> Generator[Tuple[int, int], None, None]:
        """
        Generate all diagonal vectors (dr, dc) for a given cell.

        Args:
            r (int): Row index.
            c (int): Column index.

        Yields:
            Tuple[int, int]: The change in row and column for diagonal neighbors.
        """
        for dr, dc in product(range(-1, 2), repeat=2):
            if abs(dr) + abs(dc) < 2:  # Skip non-diagonal and the origin
                continue
            yield dr, dc
    
    def diagonal_match(self, r: int, c: int) -> bool:
        """
        Check if the cell at (r, c) satisfies the diagonal match condition.

        Args:
            r (int): Row index.
            c (int): Column index.

        Returns:
            bool: True if the diagonal match condition is met, False otherwise.
        """
        if self.grid[r][c] != "A":
            return False
        
        diagonal_counters: Counter[int] = Counter()
        
        for dr, dc in self.diagonal_vectors(r, c):
            nr, nc = r + dr, c + dc
            if not self.in_bounds(nr, nc):
                return False
            symbol = self.grid[nr][nc]
            if symbol not in Xmas.__members__:
                return False
            diagonal_counters[abs(dr + dc)] += Xmas[symbol].value
        
        # Ensure all diagonal counters have a value of 1
        return all(v == 1 for v in diagonal_counters.values())
    
    def calculate(self, filename: str) -> None:
        """
        Process the grid and count the number of cells that satisfy the diagonal match condition.

        Args:
            filename (str): The name of the file containing the grid.
        """
        ans: int = 0
        self.load(filename)
        for r, c in product(range(self.R), range(self.C)):
            ans += self.diagonal_match(r, c)
        print(ans)

# Example Usage
xmas_grid = XmasGrid()
xmas_grid.calculate("big.txt")
```

## Day 5

### Solution 1: 

```py

```

## Day 6

### Solution 1: 

```py

```

## Day 7

### Solution 1: 

```py

```

## Day 8

### Solution 1: 

```py

```

## Day 9

### Solution 1: 

```py

```

## Day 10

### Solution 1: 

```py

```