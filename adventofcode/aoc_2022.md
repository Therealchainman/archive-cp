# Advent of Code 2022

## Day 1: Calorie Counting

### Part 1

### Solution 1:  max + groupby

```py
from itertools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        return max([sum(list(map(int, values))) for key, values in groupby(data, lambda s: s != '') if key])
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  nlargest + minheap datastructure + groupby

```py
from heapq import *
from itertools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        heapify(minheap := [sum(list(map(int, values))) for key, values in groupby(data, lambda s: s != '') if key])
        return sum(nlargest(3, minheap))
if __name__ == "__main__":
    print(main())
```

## Day 2: Rock Paper Scissors

### Part 1

### Solution 1:  dictionary + sum

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        rock, paper, scissors = 'X', 'Y', 'Z'
        rock_opp, paper_opp, scissors_opp = 'A', 'B', 'C'
        lose_points, draw_points, win_points = 0, 3, 6
        bonus = {rock: 1, paper: 2, scissors: 3}
        points = {rock_opp: {rock: draw_points, paper: win_points, scissors: lose_points}, paper_opp: {rock: lose_points, paper: draw_points, scissors: win_points}, 
        scissors_opp: {rock: win_points, paper: lose_points, scissors: draw_points}}
        score = sum([bonus[you] + points[opp][you] for opp, you in map(lambda play: play.split(), data)])
        return score
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  dictionary + map

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        lose, draw, win = 'X', 'Y', 'Z'
        rock, paper, scissors = 'A', 'B', 'C'
        lose_points, draw_points, win_points = 0, 3, 6
        result_points = {lose: lose_points, draw: draw_points, win: win_points}
        bonus = {rock: 1, paper: 2, scissors: 3}
        play_strat = {rock: {lose: scissors, draw: rock, win: paper}, paper: {lose: rock, draw: paper, win: scissors}, scissors: {lose: paper, draw: scissors, win: rock}}
        score = sum([result_points[strat] + bonus[play_strat[opp][strat]] for opp, strat in map(lambda play: play.split(), data)])
        return score
if __name__ == "__main__":
    print(main())
```

## Day 3: Rucksack Reorganization

### Part 1

### Solution 1: sum + map + set intersection + string.islower

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = sum([ord(ch) - ord('a') + 1 if ch.islower() else ord(ch) - ord('A') + 27 for ch in map(lambda rucksack: next(iter(set(rucksack[:len(rucksack)//2]) & set(rucksack[len(rucksack)//2:]))), data)])
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  sum + ord + set intersection + map + 3 consecutive elements in an array

```py
from functools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = sum([ord(ch) - ord('a') + 1 if ch.islower() else ord(ch) - ord('A') + 27 for ch in map(lambda i: next(iter(reduce(lambda x, y: x & y, map(set, [data[i-2], data[i-1], data[i]])))) ,range(2, len(data), 3))])
        return res
if __name__ == "__main__":
    print(main())
```

## Day 4: Camp Cleanup

### Part 1

### Solution 1:  sum + coverage

```py
class Assignment:
    def __init__(self, sections: str):
        elf1, elf2 = sections.split(',')
        self.s1, self.e1 = map(int, elf1.split('-'))
        self.s2, self.e2 = map(int, elf2.split('-'))
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = sum([1 for work in map(Assignment, data) if (work.s1 >= work.s2 and work.e1 <= work.e2) or (work.s2 >= work.s1 and work.e2 <= work.e1)])
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  string parsing + sum + inclusive overlap

```py
class Assignment:
    def __init__(self, sections: str):
        elf1, elf2 = sections.split(',')
        self.s1, self.e1 = map(int, elf1.split('-'))
        self.s2, self.e2 = map(int, elf2.split('-'))
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        res = sum([1 for work in map(Assignment, data) if min(work.e1, work.e2) - max(work.s1, work.s2) >= 0])
        return res
if __name__ == "__main__":
    print(main())
```

## Day 5: Supply Stacks 

### Part 1

### Solution 1:  dictionary + stack

```py
from collections import *
import string
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        data_stacks = data[:9]
        index = {}
        for i, ch in enumerate(data_stacks[-1]):
            if ch in string.digits:
                index[i] = int(ch)
        stacks = defaultdict(list)
        for row in reversed(data_stacks[:-1]):
            for i, ch in enumerate(row):
                if i in index and ch != ' ':
                    stacks[index[i]].append(ch)
        move_data = data[10:]
        for move in map(lambda x: x.split(), move_data):
            amt, src, dst = int(move[1]), int(move[3]), int(move[5])
            for _ in range(amt):
                stacks[dst].append(stacks[src].pop())
        res = ''.join([stacks[i][-1] for i in range(1, len(stacks)+1)])
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  dictionary + extend to move multiple

```py
from collections import *
import string
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        data_stacks = data[:9]
        index = {}
        for i, ch in enumerate(data_stacks[-1]):
            if ch in string.digits:
                index[i] = int(ch)
        stacks = defaultdict(list)
        for row in reversed(data_stacks[:-1]):
            for i, ch in enumerate(row):
                if i in index and ch != ' ':
                    stacks[index[i]].append(ch)
        move_data = data[10:]
        for move in map(lambda x: x.split(), move_data):
            amt, src, dst = int(move[1]), int(move[3]), int(move[5])
            moving_crates = stacks[src][-amt:]
            stacks[src] = stacks[src][:-amt]
            stacks[dst].extend(moving_crates)
        res = ''.join([stacks[i][-1] for i in range(1, len(stacks)+1)])
        return res
if __name__ == "__main__":
    print(main())
```

## Day 6: Tuning Trouble

### Part 1

### Solution 1:  sliding window + count of distinct characters in a fixed window size + fixed sliding window size

```py
from collections import Counter
def main():
    with open('input.txt', 'r') as f:
        data = f.read()
        seen = Counter()
        over = 0
        for i, ch in enumerate(data, start = 1):
            seen[ch] += 1
            if seen[ch] == 2:
                over += 1
            if i >= 4:
                if over == 0:
                    return i
                prev_ch = data[i - 4]
                seen[prev_ch] -= 1
                if seen[prev_ch] == 1:
                    over -= 1
        return -1
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1: sliding window + count of distinct characters in a fixed window size + fixed sliding window size + counter + O(n) time

```py
from collections import Counter
def main():
    with open('input.txt', 'r') as f:
        data = f.read()
        seen = Counter()
        over = 0
        for i, ch in enumerate(data, start = 1):
            seen[ch] += 1
            if seen[ch] == 2:
                over += 1
            if i >= 14:
                if over == 0:
                    return i
                prev_ch = data[i - 14]
                seen[prev_ch] -= 1
                if seen[prev_ch] == 1:
                    over -= 1
        return -1
if __name__ == "__main__":
    print(main())
```

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read()
        for i in range(14, len(data)):
            if len(substring := data[i-14:i]) == len(set(substring)): return i
        return -1
if __name__ == "__main__":
    print(main())
```

```py
from itertools import dropwhile
def main():
    with open('input.txt', 'r') as f:
        data = f.read()
        return next(dropwhile(lambda i: len(set(data[i-14:i])) != len(data[i-14:i]), (i for i in range(14, len(data)))))
if __name__ == "__main__":
    print(main())
```

## Day 7: No Space Left On Device

### Part 1

### Solution 1:  dictionary + string to represent folders and files + brute force

```py
from collections import Counter
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        file_sizes = Counter()
        folders = set([''])
        curDir = []
        for line in data: # O(len(data))
            if line.startswith('$'): # user command in terminal
                if line == '$ cd ..': # go up one directory
                    if len(curDir) > 0:
                        curDir.pop()
                elif line == '$ cd /': # root directory
                    curDir = []
                elif 'cd' in line: # go to child directory
                    directory = line.split()[-1]
                    curDir.append(directory)
                    folders.add('/'.join(curDir)) # O(number of characters in curDir) can get bad if folders are really really long
            else:
                file_size, file_name = line.split()
                if file_size == 'dir': continue
                file_size = int(file_size)
                # O(number of characters in curDir and file_name)
                file_sizes['/'.join(curDir + [file_name])] = file_size # assign file size to file
        res = 0
        threshold = 100000 # threshold for file sizes in a folder
        # O(number_of_folders*number_of_files)
        for folder in folders:
            # size of all the files under this folder
            folder_size = sum([fsize for file, fsize in file_sizes.items() if file.startswith(folder)]) # is this file under this folder?
            if folder_size <= threshold:
                res += folder_size
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1: dictionary + string to represent folders and files + brute force

```py
from collections import Counter
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        file_sizes = Counter()
        folders = set([''])
        curPath = []
        for line in data:
            if line.startswith('$'):
                if line == '$ cd ..':
                    if len(curPath) > 0:
                        curPath.pop()
                elif line == '$ cd /':
                    curPath = []
                elif 'cd' in line:
                    directory = line.split()[-1]
                    curPath.append(directory)
                    folders.add('/'.join(curPath))
            else:
                file_size, file_name = line.split()
                if file_size == 'dir': continue
                file_size = int(file_size)
                file_sizes['/'.join(curPath + [file_name])] = file_size
        disk_space = 70000000
        required_unused_space = 30000000
        root = ''
        folder_sizes = Counter()
        for folder in folders:
            folder_size = sum([fsize for file, fsize in file_sizes.items() if file.startswith(folder)])
            folder_sizes[folder] = folder_size
        used_space_by_fs = folder_sizes[root] 
        unused_space = disk_space - used_space_by_fs
        needed_space_to_free = required_unused_space - unused_space
        return min([size for size in folder_sizes.values() if size >= needed_space_to_free])
if __name__ == "__main__":
    print(main())
```

## Day 8: Treetop Tree House

### Part 1

### Solution 1:  set + find if greater than max value in all four directions, left to right, right to left, top to bottom, bottom to top

```py
from math import inf
def main():
    with open('input.txt', 'r') as f:
        data = []
        lines = f.read().splitlines()
        for line in lines:
            data.append([int(x) for x in line])
        n = len(data)
        visible = set()
        for r in range(n):
            maxVal = -inf
            for c in range(n):
                if data[r][c] > maxVal:
                    visible.add((r, c))
                    maxVal = data[r][c]
            maxVal = -inf
            for c in reversed(range(n)):
                if data[r][c] > maxVal:
                    visible.add((r, c))
                    maxVal = data[r][c]
        for c in range(n):
            maxVal = -inf
            for r in range(n):
                if data[r][c] > maxVal:
                    visible.add((r, c))
                    maxVal = data[r][c]
            maxVal = -inf
            for r in reversed(range(n)):
                if data[r][c] > maxVal:
                    visible.add((r, c))
                    maxVal = data[r][c]
        return len(visible)
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1: stack + counter

```py
from collections import Counter
from itertools import product
def main():        data = []
        lines = f.read().splitlines()
    with open('input.txt', 'r') as f:
        data = []
        lines = f.read().splitlines()
        for line in lines:
            data.append([int(x) for x in line])
        n = len(data)
        leftVis, rightVis, aboveVis, belowVis = Counter(), Counter(), Counter(), Counter()
        for r in range(n):
            stack = []
            for c in range(n):
                while stack and data[r][c] >= data[r][stack[-1]]:
                    prev = stack.pop()
                    rightVis[(r, prev)] = c - prev
                stack.append(c)
            while stack:
                prev = stack.pop()
                rightVis[(r, prev)] = n - prev - 1
            stack = []
            for c in reversed(range(n)):
                while stack and data[r][c] >= data[r][stack[-1]]:
                    prev = stack.pop()
                    leftVis[(r, prev)] = prev - c
                stack.append(c)
            while stack:
                prev = stack.pop()
                leftVis[(r, prev)] = prev 
        for c in range(n):
            stack = []
            for r in range(n):
                while stack and data[r][c] >= data[stack[-1]][c]:
                    prev = stack.pop()
                    belowVis[(prev, c)] = r - prev
                stack.append(r)
            while stack:
                prev = stack.pop()
                belowVis[(prev, c)] = n - prev - 1
            stack = []
            for r in reversed(range(n)):
                while stack and data[r][c] >= data[stack[-1]][c]:
                    prev = stack.pop()
                    aboveVis[(prev, c)] = prev - r
                stack.append(r)
            while stack:
                prev = stack.pop()
                aboveVis[(prev, c)] = prev
        return max(leftVis[(r, c)] * rightVis[(r, c)] * belowVis[(r, c)] * aboveVis[(r, c)] for r, c in product(range(n), repeat = 2))
if __name__ == "__main__":
    print(main())
```

## Day 9: Rope Bridge

### Part 1

### Solution 1:  simulation + tuple + set

```py
from collections import *
import math
from itertools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        seen = set()
        head = [0,0]
        tail = [0,0]
        seen.add(tuple(tail))
        neighborhood = lambda x, y: [(x-1, y-1), (x-1, y), (x-1, y+1), (x, y-1), (x, y+1), (x+1, y-1), (x+1, y), (x+1, y+1), (x, y)]
        for line in data:
            dir_, x = line.split()
            x = int(x)
            if dir_ == 'R':
                for i in range(x):
                    head[0] += 1
                    if tuple(tail) in neighborhood(*head): continue
                    tail[0] += 1
                    if tail[1] > head[1]:
                        tail[1] -= 1
                    elif tail[1] < head[1]:
                        tail[1] += 1
                    seen.add(tuple(tail))
            elif dir_ == 'L':
                for i in range(x):
                    head[0] -= 1
                    if tuple(tail) in neighborhood(*head): continue
                    tail[0] -= 1
                    if tail[1] > head[1]:
                        tail[1] -= 1
                    elif tail[1] < head[1]:
                        tail[1] += 1
                    seen.add(tuple(tail))
            elif dir_ == 'U':
                for i in range(x):
                    head[1] += 1
                    if tuple(tail) in neighborhood(*head): continue
                    tail[1] += 1
                    if tail[0] > head[0]:
                        tail[0] -= 1
                    elif tail[0] < head[0]:
                        tail[0] += 1
                    seen.add(tuple(tail))
            else:
                for i in range(x):
                    head[1] -= 1
                    if tuple(tail) in neighborhood(*head): continue
                    tail[1] -= 1
                    if tail[0] > head[0]:
                        tail[0] -= 1
                    elif tail[0] < head[0]:
                        tail[0] += 1
                    seen.add(tuple(tail))
        return len(seen)
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  simulation + represent orderd knots in sequence + apply logic to every single knot as the head moves, following the rules.  

```py
from collections import *
import math
from itertools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        seen = set([(0, 0)])
        knots = [[0]*2 for _ in range(10)]
        neighborhood = lambda x, y: [(x-1, y-1), (x-1, y), (x-1, y+1), (x, y-1), (x, y+1), (x+1, y-1), (x+1, y), (x+1, y+1), (x, y)]
        for line in data:
            dir_, x = line.split()
            x = int(x)
            if dir_ == 'R':
                for _ in range(x):
                    knots[0][0] += 1
                    for i in range(1, 10):
                        if tuple(knots[i]) in neighborhood(*knots[i-1]): continue
                        if knots[i][0] > knots[i-1][0]:
                            knots[i][0] -= 1
                        if knots[i][0] < knots[i-1][0]:
                            knots[i][0] += 1
                        if knots[i][1] > knots[i-1][1]:
                            knots[i][1] -= 1
                        if knots[i][1] < knots[i-1][1]:
                            knots[i][1] += 1
                    seen.add(tuple(knots[-1]))
            elif dir_ == 'L':
                for j in range(x):
                    knots[0][0] -= 1
                    for i in range(1, 10):
                        if tuple(knots[i]) in neighborhood(*knots[i-1]): continue
                        if knots[i][0] > knots[i-1][0]:
                            knots[i][0] -= 1
                        if knots[i][0] < knots[i-1][0]:
                            knots[i][0] += 1
                        if knots[i][1] > knots[i-1][1]:
                            knots[i][1] -= 1
                        if knots[i][1] < knots[i-1][1]:
                            knots[i][1] += 1
                    seen.add(tuple(knots[-1]))
            elif dir_ == 'U':
                for _ in range(x):
                    knots[0][1] -= 1
                    for i in range(1, 10):
                        if tuple(knots[i]) in neighborhood(*knots[i-1]): continue
                        if knots[i][0] > knots[i-1][0]:
                            knots[i][0] -= 1
                        if knots[i][0] < knots[i-1][0]:
                            knots[i][0] += 1
                        if knots[i][1] > knots[i-1][1]:
                            knots[i][1] -= 1
                        if knots[i][1] < knots[i-1][1]:
                            knots[i][1] += 1
                    seen.add(tuple(knots[-1]))
            else:
                for _ in range(x):
                    knots[0][1] += 1
                    for i in range(1, 10):
                        if tuple(knots[i]) in neighborhood(*knots[i-1]): continue
                        if knots[i][0] > knots[i-1][0]:
                            knots[i][0] -= 1
                        if knots[i][0] < knots[i-1][0]:
                            knots[i][0] += 1
                        if knots[i][1] > knots[i-1][1]:
                            knots[i][1] -= 1
                        if knots[i][1] < knots[i-1][1]:
                            knots[i][1] += 1
                    seen.add(tuple(knots[-1]))
        return len(seen)
if __name__ == "__main__":
    print(main())
```

## Day 10: Cathode-Ray Tube

### Part 1

### Solution 1:  loop

```py
from collections import *
from itertools import *
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        arr = (20, 60, 100, 140, 180, 220)
        cycle = val = 1
        res = 0
        for ins in data:
            if ins == 'noop':
                cycle += 1
                if cycle in arr:
                    res += cycle*val
            else:
                _, delta = ins.split()
                delta = int(delta)
                cycle += 1
                if cycle in arr:
                    res += cycle*val
                cycle += 1
                val += delta
                if cycle in arr:
                    res += cycle*val
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  modular arithmetic + matrix

```py
from collections import *
from itertools import *

"""
if sprit_pos = 4
sprite position: ...xxx....
sprite size as 3
"""

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        screen_len = 40
        grid = [['.' for _ in range(screen_len)] for y in range(6)]
        cycle, sprite_pos = 0, 1
        neighborhood = lambda i: (i-1, i, i+1)
        row = lambda i: i//screen_len
        col = lambda i: i%screen_len
        def update_grid():
            c = col(cycle)
            if c in neighborhood(sprite_pos):
                grid[row(cycle)][c] = '#'
        for ins in data:
            if ins == 'noop':
                update_grid()
                cycle += 1
            else:
                _, delta = ins.split()
                delta = int(delta)
                update_grid()
                cycle += 1
                update_grid()
                cycle += 1
                sprite_pos += delta
        return "\n".join(["".join(row) for row in grid])
if __name__ == "__main__":
    print(main())
```

## Day 11:

### Part 1

### Solution 1:  parsing input

```py
import operator
import functools

class Monkey:
    def __init__(self, items, ops, div, if_true, if_false):
        self.items = items
        self.ops = ops
        self.div = div
        self.if_true = if_true
        self.if_false = if_false

    # determines what monkey to throw the item to
    def throw(self, val: int) -> int:
        return self.if_true if val%self.div == 0 else self.if_false

    def apply_ops(self, val: int) -> int:
        op, operand = self.ops
        if op == '+':
            return val + int(operand)
        elif operand == 'old':
            return val*val
        return val*int(operand)

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        monkeys = []
        divisors = set()
        for i in range(7, len(data)+8, 7):
            monk = data[i-7:i]
            items = list(map(int, monk[1].replace(',', '').split()[2:]))
            ops = monk[2].split()[-2:]
            div = int(monk[3].strip().split()[-1])
            divisors.add(div)
            if_true = int(monk[4].strip().split()[-1])
            if_false = int(monk[5].strip().split()[-1])
            monkeys.append(Monkey(items, ops, div, if_true, if_false))
        inspect = [0]*8
        num_rounds = 10000
        for _ in range(num_rounds):
            for i, m in enumerate(monkeys):
                while m.items:
                    val = m.items.pop()
                    val = m.apply_ops(val)//3
                    monkeys[m.throw(val)].items.append(val)
                    inspect[i] += 1
        inspect.sort(reverse = True)
        return functools.reduce(operator.mul, inspect[:2])
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  modular arithmetic + math + dealing with large number but need to find if it is divisible by a small list of integers + Use the LCM of the list of integers and mod the large number by that

```py
import math
import operator
import functools

class Monkey:
    def __init__(self, items, ops, div, if_true, if_false):
        self.items = items
        self.ops = ops
        self.div = div
        self.if_true = if_true
        self.if_false = if_false

    # determines what monkey to throw the item to
    def throw(self, val: int) -> int:
        return self.if_true if val%self.div == 0 else self.if_false

    def apply_ops(self, val: int) -> int:
        op, operand = self.ops
        if op == '+':
            return val + int(operand)
        elif operand == 'old':
            return val*val
        return val*int(operand)

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        monkeys = []
        divisors = set()
        for i in range(7, len(data)+8, 7):
            monk = data[i-7:i]
            items = list(map(int, monk[1].replace(',', '').split()[2:]))
            ops = monk[2].split()[-2:]
            div = int(monk[3].strip().split()[-1])
            divisors.add(div)
            if_true = int(monk[4].strip().split()[-1])
            if_false = int(monk[5].strip().split()[-1])
            monkeys.append(Monkey(items, ops, div, if_true, if_false))
        inspect = [0]*8
        num_rounds = 10000
        lcm_ = math.lcm(*divisors)
        for _ in range(num_rounds):
            for i, m in enumerate(monkeys):
                while m.items:
                    val = m.items.pop()
                    val = m.apply_ops(val)%lcm_
                    monkeys[m.throw(val)].items.append(val)
                    inspect[i] += 1
        inspect.sort(reverse = True)
        return functools.reduce(operator.mul, inspect[:2])
if __name__ == "__main__":
    print(main())
```

## Day 12: Hill Climbing Algorithm

### Part 1

### Solution 1:  bfs + queue + memoization

```py
from collections import deque
import itertools

def main():
    with open('input.txt', 'r') as f:
        data = []
        lines = f.read().splitlines()
        for line in lines:
            data.append([x for x in line])
        R, C = len(data), len(data[0])
        start = 'S'
        end = 'E'
        queue = deque()
        target = None
        vis = set()
        for r, c in itertools.product(range(R), range(C)):
            if data[r][c] == start:
                data[r][c] = 'a'
                queue.append((r, c))
                vis.add((r, c))
            if data[r][c] == end:
                data[r][c] = 'z'
                target = (r, c)
        neighborhood = lambda r, c: ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1))
        in_bounds = lambda r, c: 0 <= r < R and 0 <= c < C
        steps = 0
        while queue:
            sz = len(queue)
            for _ in range(sz):
                r, c = queue.popleft()
                if (r, c) == target: return steps
                for nr, nc in neighborhood(r, c):
                    if not in_bounds(nr, nc) or (nr, nc) in vis: continue
                    cur_elv = chr(ord(data[r][c])+1)
                    if data[nr][nc] <= cur_elv: # next elevation can be at most one higher
                        vis.add((nr, nc))
                        queue.append((nr, nc))
            steps += 1
        return -1

if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  multisource bfs + queue + memoization

```py

from collections import deque
import itertools

def main():
    with open('input.txt', 'r') as f:
        data = []
        lines = f.read().splitlines()
        for line in lines:
            data.append([x for x in line])
        R, C = len(data), len(data[0])
        start = 'S'
        end = 'E'
        queue = deque()
        target = None
        vis = set()
        for r, c in itertools.product(range(R), range(C)):
            if data[r][c] == start or data[r][c] == 'a':
                data[r][c] = 'a'
                queue.append((r, c))
                vis.add((r, c))
            if data[r][c] == end:
                data[r][c] = 'z'
                target = (r, c)
        neighborhood = lambda r, c: ((r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1))
        in_bounds = lambda r, c: 0 <= r < R and 0 <= c < C
        steps = 0
        while queue:
            sz = len(queue)
            for _ in range(sz):
                r, c = queue.popleft()
                if (r, c) == target: return steps
                for nr, nc in neighborhood(r, c):
                    if not in_bounds(nr, nc) or (nr, nc) in vis: continue
                    cur_elv = chr(ord(data[r][c])+1)
                    if data[nr][nc] <= cur_elv:
                        vis.add((nr, nc))
                        queue.append((nr, nc))
            steps += 1
        return -1

if __name__ == "__main__":
    print(main())
```

## Day 13: Distress Signal

### Part 1

### Solution 1:  eval + recursive compare function + logic for passing and None + visualize it as a recursive tree to see why it only returns True or False when it finds a condition + that then will get propagated all the way to the root. For None it just continues checking

```py
def compare(leftArr, rightArr):
    for arr1, arr2 in zip(leftArr, rightArr):
        if isinstance(arr1, int) and isinstance(arr2, int):
            if arr1 < arr2: return True
            elif arr1 > arr2: return False
        elif isinstance(arr1, list) and isinstance(arr2, list):
            output = compare(arr1, arr2)
            if output is not None: return output
        elif isinstance(arr1, list):
            output = compare(arr1, [arr2])
            if output is not None: return output
        elif isinstance(arr2, list):
            output = compare([arr1], arr2)
            if output is not None: return output
    return True if len(leftArr) < len(rightArr) else False if len(leftArr) > len(rightArr) else None

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        n = len(data)
        res = 0
        for i, j in enumerate(range(2,n+1,3), start = 1):
            leftArr = data[j-2]
            rightArr = data[j-1]
            leftArr = eval(leftArr)
            rightArr = eval(rightArr)
            if compare(leftArr, rightArr):
                res += i
        return res

if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1: relative ordering with comparison function + convert comparison function to key function for sort + eval function + nested list class to create nested lists recursively + complex compare function

```py
import string
import functools
class NestedList:
    def __init__(self, arr):
        self.arr = arr
        self.idx = 1
        self.lst = self.getList()

    def getList(self):
        lst = []
        while self.idx < len(self.arr) and self.arr[self.idx] != ']':
            if self.arr[self.idx] == ',': 
                self.idx += 1
                continue
            if self.arr[self.idx] == '[':
                self.idx += 1
                lst.append(self.getList())
            else:
                num = ''
                while self.arr[self.idx] in string.digits:
                    num += self.arr[self.idx]
                    self.idx += 1
                lst.append(int(num))
        self.idx += 1
        return lst

def compare(leftArr, rightArr):
    for arr1, arr2 in zip(leftArr, rightArr):
        if isinstance(arr1, int) and isinstance(arr2, int):
            if arr1 < arr2: return True
            elif arr1 > arr2: return False
        elif isinstance(arr1, list) and isinstance(arr2, list):
            output = compare(arr1, arr2)
            if output == True or output == False: return output
        elif isinstance(arr1, list):
            output = compare(arr1, [arr2])
            if output == True or output == False: return output
        elif isinstance(arr2, list):
            output = compare([arr1], arr2)
            if output == True or output == False: return output
    if len(leftArr) < len(rightArr):
        return True
    elif len(leftArr) > len(rightArr):
        return False
    return None
    
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        n = len(data)
        packets = []
        for j in range(2,n+3,3):
            leftArr = data[j-2]
            rightArr = data[j-1]
            leftArr = eval(leftArr)
            rightArr = eval(rightArr)
            packets.extend([leftArr, rightArr])
            # leftArr = NestedList(leftArr).lst
            # rightArr = NestedList(rightArr).lst
        packets.extend([[[2]], [[6]]])
        cmp = functools.cmp_to_key(lambda x, y: -1 if compare(x, y) else 1) # -1 means less than 1 means greater than
        packets.sort(key = cmp)
        return (packets.index([[2]]) + 1)*(packets.index([[6]]) + 1)

if __name__ == "__main__":
    print(main())
```

## Day 14: Regolith Reservoir

### Part 1

### Solution 1:  set to store the blocked path + simulate each sand falling from initial location by storing the max row and find when the sand reaches the max row, or the bottom, that means that it will continue passing into infinity cause no obstacle beneath that. 

```py
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        grid = set()
        paths = []
        maxRow = 0
        for line in map(lambda x: x.split(' -> '), data):
            paths.append([])
            for c, r in map(lambda x: x.split(','), line):
                paths[-1].append((int(r), int(c)))
        for path in paths:
            for i in range(len(path) - 1):
                r1, c1 = path[i]
                r2, c2 = path[i + 1]
                if r1 == r2:
                    for c in range(min(c1, c2), max(c1, c2) + 1):
                        grid.add((r1, c))
                else:
                    for r in range(min(r1, r2), max(r1, r2) + 1):
                        grid.add((r, c1))
                maxRow = max(maxRow, r1, r2)
        sand = r = 0
        while r < maxRow:
            r, c = 0, 500
            for r in range(maxRow + 1):
                if (r+1, c) not in grid:
                    pass
                elif (r+1, c-1) not in grid:
                    c -= 1
                elif (r+1, c+1) not in grid:
                    c += 1
                else:
                    grid.add((r, c))
                    break
            sand += (r < maxRow)
        return sand
if __name__ == "__main__":
    print(main())
```

### Solution 2:  Represent in complex number + easy to represent falling down or diagonally to left or right in complex number

```py
import itertools
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        grid = set()
        paths = []
        abyss = 0
        for line in map(lambda x: x.split(' -> '), data):
            paths.append([])
            for c, r in map(lambda x: x.split(','), line):
                paths[-1].append((int(r), int(c)))
        for path in paths:
            for i in range(len(path) - 1):
                r1, c1 = path[i]
                r2, c2 = path[i + 1]
                if r1 == r2:
                    for c in range(min(c1, c2), max(c1, c2) + 1):
                        grid.add(c + r1 * 1j)
                else:
                    for r in range(min(r1, r2), max(r1, r2) + 1):
                        grid.add(c1 + r * 1j)
                abyss = max(abyss, r1, r2)
        sand = depth = 0
        while depth < abyss:
            z = 500
            for depth in range(abyss + 1):
                if z + 1j not in grid:
                    z += 1j
                elif z - 1 + 1j not in grid:
                    z = z - 1 + 1j
                elif z + 1 + 1j not in grid:
                    z = z + 1 + 1j
                else:
                    grid.add(z)
                    break
            sand += (depth < abyss)
        return sand
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  let the sand fall two spots beneath and settle at that location + no longer can pass to infinity + go until sand stops at the initial location

```py
import itertools
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        grid = set()
        paths = []
        maxRow = 0
        for line in map(lambda x: x.split(' -> '), data):
            paths.append([])
            for c, r in map(lambda x: x.split(','), line):
                paths[-1].append((int(r), int(c)))
        for path in paths:
            for i in range(len(path) - 1):
                r1, c1 = path[i]
                r2, c2 = path[i + 1]
                if r1 == r2:
                    for c in range(min(c1, c2), max(c1, c2) + 1):
                        grid.add((r1, c))
                else:
                    for r in range(min(r1, r2), max(r1, r2) + 1):
                        grid.add((r, c1))
                maxRow = max(maxRow, r1, r2)
        sand = 0
        while r != 0:
            r, c = 0, 500
            for r in range(maxRow+2):
                if (r+1, c) not in grid:
                    pass
                elif (r+1, c-1) not in grid:
                    c -= 1
                elif (r+1, c+1) not in grid:
                    c += 1
                else:
                    break
            grid.add((r, c))
            sand += 1
        return sand
if __name__ == "__main__":
    print(main())
```

### Solution 2:  complex numbers

```py
import itertools
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        grid = set()
        paths = []
        abyss = 0
        for line in map(lambda x: x.split(' -> '), data):
            paths.append([])
            for c, r in map(lambda x: x.split(','), line):
                paths[-1].append((int(r), int(c)))
        for path in paths:
            for i in range(len(path) - 1):
                r1, c1 = path[i]
                r2, c2 = path[i + 1]
                if r1 == r2:
                    for c in range(min(c1, c2), max(c1, c2) + 1):
                        grid.add(c + r1 * 1j)
                else:
                    for r in range(min(r1, r2), max(r1, r2) + 1):
                        grid.add(c1 + r * 1j)
                abyss = max(abyss, r1, r2)
        sand = 0
        depth = 1
        while depth != 0:
            z = 500
            for depth in range(abyss+1):
                if z + 1j not in grid:
                    z += 1j
                elif z - 1 + 1j not in grid:
                    z = z - 1 + 1j
                elif z + 1 + 1j not in grid:
                    z = z + 1 + 1j
                else:
                    break
            grid.add(z)
            sand += 1
        return sand
if __name__ == "__main__":
    print(main())
```

## Day 15: Beacon Exclusion Zone

### Part 1

### Solution 1: for each row perform a range query + range query to find the length of the ranges of where beacons cannot be + implemented with a python dictionary with increments and decrements to indicate start and end of ranges + use the diamond shape and the size of the diamond and width at a row dependent on location of the beacon. + account for the beacons along the row

```py
import re
from collections import defaultdict
import math
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        sensors = []
        beacons = []
        y = 2000000
        rowBeacons = set()
        manhattan = lambda x1, y1, x2, y2: abs(x1 - x2) + abs(y1 - y2)
        process = lambda s: int(re.findall(r'-?\d+', s)[0])
        for line in map(lambda x: x.split(), data):
            x1, y1 = map(lambda x: process(x), [line[2], line[3]])
            x2, y2 = map(lambda x: process(x), [line[8], line[9]])
            sensors.append((x1, y1))
            beacons.append((x2, y2))
            if y2 == y:
                rowBeacons.add(x2)
        ranges = defaultdict(int)
        for (x1, y1), (x2, y2) in zip(sensors, beacons):
            highest = manhattan(x1, y1, x2, y2) - manhattan(x1, y1, x1, y)
            if highest < 0: continue
            left = x1-highest
            right = x1+highest
            ranges[left] += 1
            ranges[right+1] -= 1
        rowBeacons = sorted(list(rowBeacons))
        delta = res = beacon_ptr = 0
        start = math.inf
        for key in sorted(ranges.keys()):
            if delta == 0:
                start = key
            delta += ranges[key]
            if delta == 0:
                res += key - start
                while beacon_ptr < len(rowBeacons) and rowBeacons[beacon_ptr] < key:
                    res -= (beacon_ptr >= start)
                    beacon_ptr += 1
        return res
if __name__ == "__main__":
    print(main())
```

### Part 2

### Solution 1:  Using Z3 Solver and SMT and SAT + Adding the constraints to to have it solve for x and y + Using the Manhattan distance to find the closest beacon

```py
import re
from z3.z3 import If, Int, Solver

def z3abs(x):
    return If(x >= 0, x, -x)

def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        sensors = []
        beacons = []
        manhattan = lambda x1, y1, x2, y2: abs(x1 - x2) + abs(y1 - y2)
        process = lambda s: int(re.findall(r'-?\d+', s)[0])
        for line in map(lambda x: x.split(), data):
            x1, y1 = map(lambda x: process(x), [line[2], line[3]])
            x2, y2 = map(lambda x: process(x), [line[8], line[9]])
            sensors.append((x1, y1))
            beacons.append((x2, y2))
        s = Solver()
        x = Int('x')
        y = Int('y')
        s.add(x >= 0)
        s.add(x <= 4000000)
        s.add(y >= 0)
        s.add(y <= 4000000)
        for (x1, y1), (x2, y2) in zip(sensors, beacons):
            dist = manhattan(x1, y1, x2, y2)
            s.add(z3abs(x - x1) + z3abs(y - y1) > dist)
        s.check()
        model = s.model()
        return model[x].as_long()*4000000 + model[y].as_long()
if __name__ == "__main__":
    print(main())
```

### Solution 2: 

```py
from collections import defaultdict
import re
def main():
    with open('input.txt', 'r') as f:
        data = f.read().splitlines()
        sensors = []
        beacons = []
        manhattan = lambda x1, y1, x2, y2: abs(x1 - x2) + abs(y1 - y2)
        process = lambda s: int(re.findall(r'-?\d+', s)[0])
        for line in map(lambda x: x.split(), data):
            x1, y1 = map(lambda x: process(x), [line[2], line[3]])
            x2, y2 = map(lambda x: process(x), [line[8], line[9]])
            sensors.append((x1, y1))
            beacons.append((x2, y2))
        limit = 4000000
        for y in range(0, limit):
            ranges = defaultdict(int)
            ranges[0] = 0
            for (x1, y1), (x2, y2) in zip(sensors, beacons):
                highest = manhattan(x1, y1, x2, y2) - manhattan(x1, y1, x1, y)
                if highest < 0: continue
                left = max(0, x1-highest)
                right = min(limit, x1+highest)
                ranges[left] += 1
                ranges[right+1] -= 1
            cur = 0
            for key in sorted(ranges.keys()):
                cur += ranges[key]
                if cur == 0 and key != limit+1:
                    return key*4000000+y
        return -1
if __name__ == "__main__":
    print(main())
```

## Day 16: Proboscidea Volcanium

### Part 1

### Solution 1:  dynamic programming + bitmask + observation that flow_rate > 0 is sparse + m valves with flow_rate > 0, t minutes, n valves + O(t * n * 2^m) time + works because m <= 15

```py
from parse import compile
from collections import defaultdict

def main():
    with open("input.txt", 'r') as f:
        data = f.read().splitlines()
        pat1 = compile("Valve {} has flow rate={:d}; tunnels lead to valves {}")
        pat2 = compile("Valve {} has flow rate={:d}; tunnel leads to valve {}")
        adj_list = defaultdict(list)
        valve_mask = {}
        flow_rates = {}
        for line in data:
            valve, flow, neighbors = pat1.parse(line) if not isinstance(pat1.parse(line), type(None)) else pat2.parse(line)
            neighbors = map(lambda x: x.strip(','), neighbors.split())
            valve_mask[valve] = 1 << len(valve_mask) # key: valve string name, value: integer representation (2^i) 
            flow_rates[valve_mask[valve]] = flow
            adj_list[valve_mask[valve]].extend(neighbors)
        total_time = 30
        memo = {}
        states = [(valve_mask['AA'], 0, 0)] # (valve_num, opened_mask, pressure)
        for t in range(1, total_time+1):
            new_states = []
            for valve_num, opened_mask, pressure in states:
                key = (valve_num, opened_mask)
                if key in memo and pressure <= memo[key]:
                    continue
                memo[key] = pressure
                flow_rate = flow_rates[valve_num]
                if valve_num & opened_mask == 0 and flow_rate > 0:
                    new_states.append((valve_num, opened_mask | valve_num, pressure + flow_rate * (total_time - t)))
                for nei_node in adj_list[valve_num]:
                    new_states.append((valve_mask[nei_node], opened_mask, pressure))
            states = new_states
        return max(pressure for _, _, pressure in states)

if __name__ == '__main__':
    print(main())
```

### Part 2

### Solution 1: O(n * 2^n * t * num_players) + 30 seconds runtime on full dataset + only works because n = 16, n is the number of nonzero flow rate valves and the start position + compute the all-pairs shortest path problem using bfs + This uses assumption that you always want to travel to a valve to open it, and you will always take the shortest path + You can reset from time = 0, but keep current history of opened and pressure and compute what the elephant could have done in parallel with your work to speed up the maximum pressure. 

```py
from parse import compile
from collections import defaultdict, deque
import time
from typing import List, Dict

def bfs(src: int, dst: int, adj_list: Dict[int, List[int]]) -> int:
    dist = 0
    queue = deque([src])
    vis = set([src])
    while queue:
        sz = len(queue)
        for _ in range(sz):
            node = queue.popleft()
            if node == dst: return dist
            for nei in adj_list[node]:
                if nei in vis: continue
                queue.append(nei)
                vis.add(nei)
        dist += 1
    return -1

def main():
    with open("input.txt", 'r') as f:
        data = f.read().splitlines()
        pat1 = compile("Valve {} has flow rate={:d}; tunnels lead to valves {}")
        pat2 = compile("Valve {} has flow rate={:d}; tunnel leads to valve {}")
        adj_list = defaultdict(list)
        valve_mask = {}
        flow_rates = {}
        for line in data:
            valve, flow, neighbors = pat1.parse(line) if not isinstance(pat1.parse(line), type(None)) else pat2.parse(line)
            neighbors = map(lambda x: x.strip(','), neighbors.split())
            valve_mask[valve] = 1 << len(valve_mask) # key: valve string name, value: integer representation (2^i) 
            flow_rates[valve] = flow
            adj_list[valve].extend(neighbors)
        valves_nonzero_flow = [k for k, v in flow_rates.items() if v]
        minDist = {}
        for src in ['AA'] + valves_nonzero_flow:
            for dst in valves_nonzero_flow:
                if src == dst: continue
                minDist[(src, dst)] = bfs(src, dst, adj_list)
        total_time = 26
        memo = {}
        res = 0
        states = deque([('AA', 0, 0, 0, False)]) # (valve, opened, pressure, time, elephants_turn)
        while states:
            pos, opened, pressure, time, elephants_turn = states.popleft()
            res = max(res, pressure)
            if not elephants_turn:
                states.append(('AA', opened, pressure, 0, True))
            if time == total_time: continue
            for dst in valves_nonzero_flow:
                mask = valve_mask[dst]
                if (opened & mask) != 0: continue
                dist = minDist[(pos, dst)]
                if total_time-dist-1-time < 0: continue
                next_pressure = pressure + flow_rates[dst]*(total_time-dist-1-time)
                key = (mask, opened|mask, time, elephants_turn) # O(n * 2^n * t * num_players)
                if key in memo and next_pressure <= memo[key]: continue
                memo[key] = next_pressure
                states.append((dst, opened|mask, next_pressure, time+dist+1, elephants_turn))
        return res

if __name__ == '__main__':
    start_time = time.perf_counter()
    print(main())
    end_time = time.perf_counter()
    print(f'Time Elapsed: {end_time - start_time:,} seconds')
```

## Day 17:

### Part 1

### Solution 1: 

```py

```

### Part 2

### Solution 1:

```py

```

## Day 18:

### Part 1

### Solution 1: 

```py

```

### Part 2

### Solution 1:

```py

```
