# Leetcode Weekly Contest 400 - 449

# Leetcode Weekly Contest 400

## 3169. Count Days Without Meetings

### Solution 1: sorting, line sweep algorithm

```cpp
class Solution {
public:
    int countDays(int days, vector<vector<int>>& meetings) {
        vector<pair<int, int>> events;
        for (const vector<int>& meet : meetings) {
            int l = meet[0], r = meet[1];
            events.emplace_back(l, 1);
            events.emplace_back(r + 1, -1);
        }
        events.emplace_back(days + 1, 1);
        sort(events.begin(), events.end());
        int ans = 0, last = 1, cnt = 0;
        for (const auto &[i, d] : events) {
            if (cnt == 0) {
                ans += i - last;
            }
            cnt += d;
            if (cnt == 0) {
                last = i;
            }
        }
        return ans;
    }
};
```

## 3171. Find Subarray With Bitwise AND Closest to K

### Solution 1:  bitwise and range queries, static array, sparse table, binary search

```py
class ST_And:
    def __init__(self, nums):
        self.nums = nums
        self.n = len(nums)
        self.LOG = 18 # 10,000
        self.build()

    def op(self, x, y):
        return x & y

    def build(self):
        self.lg = [0] * (self.n + 1)
        for i in range(2, self.n + 1):
            self.lg[i] = self.lg[i // 2] + 1
        self.st = [[0] * self.n for _ in range(self.LOG)]
        for i in range(self.n): 
            self.st[0][i] = self.nums[i]
        # CONSTRUCT SPARSE TABLE
        for i in range(1, self.LOG):
            j = 0
            while (j + (1 << (i - 1))) < self.n:
                self.st[i][j] = self.op(self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))])
                j += 1

    def query(self, l, r):
        length = r - l + 1
        i = self.lg[length]
        return self.op(self.st[i][l], self.st[i][r - (1 << i) + 1])
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = math.inf
        st = ST_And(nums)
        def possible(src, dst):
            v = st.query(src, dst)
            return v >= k
        def bsearch(start):
            lo, hi = start, n - 1
            while lo < hi:
                mid = (lo + hi + 1) >> 1
                if possible(start, mid):
                    lo = mid
                else:
                    hi = mid - 1
            return lo
        for i in range(n):
            j = bsearch(i)
            v = st.query(i, j)
            ans = min(ans, abs(v - k))
            j += 1
            if j < n:
                v = st.query(i, j)
                ans = min(ans, abs(v - k))
        return ans
```

# Leetcode Weekly Contest 401

## 3181. Maximum Total Reward Using Operations II

### Solution 1:  bit manipulation, bitsets, dynamic programming, reachability, sorting

```cpp
class Solution {
public:
    int maxTotalReward(vector<int>& rewards) {
        const int MAXN = 1e5;
        int N = rewards.size();
        sort(rewards.begin(), rewards.end());
        bitset<MAXN> dp, mask;
        dp.set(0);
        int x = 0;
        for (int v : rewards) {
            while (x < v) {
                mask.set(x++);
            }
            dp |= (dp & mask) << v;
        }
        for (int x = MAXN - 1; x >= 0; x--) {
            if (dp.test(x)) return x;
        }
        return 0;
    }
};
```

```py
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        MAXN = int(1e5)
        x = mask = 0
        dp = 1
        for r in sorted(rewardValues):
            while x < r:
                mask |= (1 << x)
                x += 1
            dp |= (dp & mask) << r
        for i in reversed(range(MAXN)):
            if (dp >> i) & 1: return i
```

# Leetcode Weekly Contest 402

## Count Pairs That Form a Complete Day II

### Solution 1:  counter, modulo

```py
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        n = len(hours)
        counts = Counter()
        ans = 0
        for h in map(lambda x: x % 24, hours):
            ans += counts[(24 - h) % 24]
            counts[h] += 1
        return ans
```

## Maximum Total Damage With Spell Casting

### Solution 1:  dp, coordinate compression, frequency array

```py
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        n = len(power)
        freq = Counter(power)
        power = sorted(set(power))
        compressed = set()
        for p in power:
            for i in range(-3, 3):
                compressed.add(p + i)
        compressed = sorted(compressed)
        N = len(compressed)
        dp = [0] * N
        for p in range(3, N):
            dp[p] = max(dp[p - 2], dp[p - 1], dp[p - 3] + compressed[p] * freq[compressed[p]])
        return dp[-1]
```

## 3187. Peaks in Array

### Solution 1: fenwick tree, point updates, range count queries

```py
class FenwickTree:
    def __init__(self, N):
        self.sums = [0 for _ in range(N+1)]

    def update(self, i, delta):
        while i < len(self.sums):
            self.sums[i] += delta
            i += i & (-i)

    def query(self, i):
        res = 0
        while i > 0:
            res += self.sums[i]
            i -= i & (-i)
        return res

    def query_range(self, i, j):
        return self.query(j) - self.query(i - 1) if j >= i else 0

    def __repr__(self):
        return f"array: {self.sums}"
class Solution:
    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n, m = len(nums), len(queries)
        peaks = [0] * n
        for i in range(1, n - 1):
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                peaks[i] = 1
        ans = []
        ft = FenwickTree(n)
        for i in range(n):
            if peaks[i]: ft.update(i + 1, 1)
        for t, l, r in queries:
            if t == 1:
                res = ft.query_range(l + 2, r)
                ans.append(res)
            else:
                nums[l] = r
                # update index peak
                if l > 0 and l + 1 < n:
                    if nums[l] > nums[l - 1] and nums[l] > nums[l + 1]:
                        if not peaks[l]:
                            peaks[l] = 1
                            ft.update(l + 1, 1)
                    else:
                        if peaks[l]:
                            peaks[l] = 0
                            ft.update(l + 1, -1)
                # update index + 1 peak
                if l + 2 < n:
                    if nums[l + 1] > nums[l] and nums[l + 1] > nums[l + 2]:
                        if not peaks[l + 1]:
                            peaks[l + 1] = 1
                            ft.update(l + 2, 1)
                    else:
                        if peaks[l + 1]:
                            peaks[l + 1] = 0
                            ft.update(l + 2, -1)
                # update index - 1 peak
                if l > 1:
                    if nums[l - 1] > nums[l - 2] and nums[l - 1] > nums[l]:
                        if not peaks[l - 1]:
                            peaks[l - 1] = 1
                            ft.update(l, 1)
                    else:
                        if peaks[l - 1]:
                            peaks[l - 1] = 0
                            ft.update(l, -1)
        return ans
```

# Leetcode Weekly Contest 403

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

# Leetcode Weekly Contest 404

## Find the Maximum Length of Valid Subsequence I

### Solution 1:  dynammic programming, binary, base 2

```py
class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        n = len(nums)
        nums = [x % 2 for x in nums]
        dp = [[0] * 2 for _ in range(2)] # (last, rem)
        for i in range(2):
            dp[nums[0]][i] = 1
        for num in nums[1:]:
            ndp = dp[:]
            for rem in range(2): # rem
                ndp[num][rem] = max(ndp[num][rem], dp[rem ^ num][rem] + 1)
            dp = ndp
        return max(max(row) for row in dp)
```

## Find the Maximum Length of Valid Subsequence II

### Solution 1:  dynamic programming

```py
class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)] # dp[n][k]
        ans = 0
        for i in range(1, n):
            for j in range(i):
                val = (nums[i] + nums[j]) % k
                dp[i][val] = max(dp[i][val], dp[j][val] + 1, 2)
                ans = max(ans, dp[i][val])
        return ans
```

## 3203. Find Minimum Diameter After Merging Two Trees

### Solution 1:  tree rerooting dp, dfs, tree diameter

```py
class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        n, m = len(edges1) + 1, len(edges2) + 1
        ans = 0
        def calc(edges):
            nonlocal ans
            n = len(edges) + 1
            adj = [[] for _ in range(n + 1)]
            st1 = [0] * (n + 1)
            st2 = [0] * (n + 1)
            n1 = [-1] * (n + 1)
            n2 = [-1] * (n + 1)
            par = [0] * (n + 1)
            diam = 0
            res = math.inf
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            def dfs1(u, p):
                for v in adj[u]:
                    if v == p: continue
                    dfs1(v, u)
                    # update dp[u]
                    if st1[v] + 1 > st1[u]:
                        n2[u] = n1[u]
                        n1[u] = v
                        st2[u] = st1[u]
                        st1[u] = st1[v] + 1
                    elif st1[v] + 1 > st2[u]:
                        st2[u] = st1[v] + 1
                        n2[u] = v
            def dfs2(u, p):
                nonlocal res, diam
                # get answer based on new subtree and subtree of u
                res = min(res, max(par[u], st1[u]))
                diam = max(diam, par[u] + st1[u])
                for v in adj[u]:
                    if v == p: continue
                    # update par[v] based on par[u] and other children
                    par[v] = par[u] + 1
                    if n1[u] != v: par[v] = max(par[v], st1[u] + 1)
                    if n2[u] != v: par[v] = max(par[v], st2[u] + 1)
                    dfs2(v, u)
            dfs1(0, -1)
            dfs2(0, -1)
            ans = max(ans, diam)
            return res
        merged_tree = calc(edges1) + calc(edges2) + 1
        ans = max(ans, merged_tree)
        return ans
```

# Leetcode Weekly Contest 405

## 3213. Construct String with Minimum Cost

### Solution 1:  Aho-Corasick data structure, dynamic programming, bfs, trie, output links

```cpp
const int INF = 1e9, K = 26;
struct Vertex {
    bool is_leaf = false;
    int cost = INF;
    int output_link = 0;
    int suffix_link = 0;
    int depth = 0;
    int transition[K];
    void init() {
        fill(begin(transition), end(transition), 0);
    }
};
vector<Vertex> trie;
void add_string(const string& s, const int cost) {
    int cur = 0, depth = 0;
    for (char ch : s) {
        int c = ch - 'a';
        depth++;
        if (trie[cur].transition[c] == 0) {
            trie[cur].transition[c] = trie.size();
            Vertex v;
            v.init();
            v.depth = depth;
            trie.push_back(v);
        }
        cur = trie[cur].transition[c];
    }
    trie[cur].is_leaf = true;
    trie[cur].cost = min(trie[cur].cost, cost);
}
void push_links() {
    int queue[trie.size()];
    queue[0] = 0;
    int state = 0, next_state = 1;
    while (state < trie.size()) {
        int v = queue[state++];
        int u = trie[v].suffix_link;
        if (trie[u].is_leaf) trie[v].output_link = u;
        else trie[v].output_link = trie[u].output_link;
        for (int c = 0; c < K; c++) {
            if (trie[v].transition[c] != 0) {
                trie[trie[v].transition[c]].suffix_link = v ? trie[u].transition[c] : 0;
                queue[next_state++] = trie[v].transition[c];
            } else {
                trie[v].transition[c] = trie[u].transition[c];
            }
        }
    }
}
class Solution {
public:
    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        int m = words.size(), n = target.size();
        trie.resize(1);
        trie[0].init();
        for (int i = 0; i < m; i++) {
            add_string(words[i], costs[i]);
        }
        push_links();
        int cur = 0;
        vector<int> dp(n + 1, INF);
        dp[0] = 0;
        cur = 0;
        for (int i = 1; i <= n; i++) {
            cur = trie[cur].transition[target[i - 1] - 'a'];
            if (trie[cur].is_leaf) {
                dp[i] = min(dp[i], dp[i - trie[cur].depth] + trie[cur].cost);
            }
            int output = trie[cur].output_link;
            while (output) {
                dp[i] = min(dp[i], dp[i - trie[output].depth] + trie[output].cost);
                output = trie[output].output_link;
            }
        }
        return dp[n] < INF ? dp[n] : -1;
    }
};
```

# Leetcode Weekly Contest 406

## Minimum Cost for Cutting Cake II

### Solution 1:  greedy, sorting

```cpp
class Solution {
public:
    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        long long vcount = 1, hcount = 1, ans = 0;
        vector<pair<long long, int>> queries;
        for (int x : horizontalCut) {
            queries.emplace_back(x, 0);
        }
        for (int x : verticalCut) {
            queries.emplace_back(x, 1);
        }
        sort(queries.begin(), queries.end());
        reverse(queries.begin(), queries.end());
        for (auto [cost, t] : queries) {
            if (t == 0) {
                ans += vcount * cost;
                hcount++;
            } else {    
                ans += hcount * cost;
                vcount++;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 407

## Minimum Operations to Make Array Equal to Target

### Solution 1:  count increments and decrements, difference array

```cpp
class Solution {
public:
    long long minimumOperations(vector<int>& nums, vector<int>& target) {
        int N = nums.size();
        vector<int> diff(N);
        for (int i = 0; i < N; i++) {
            diff[i] = target[i] - nums[i];
        }
        long long ans = 0;
        int cur = 0;
        for (int d : diff) {
            if (d > 0) {
                cur = max(0, cur);
                int delta = max()
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 408

## 3233. Find the Count of Numbers Which Are Not Special

### Solution 1:  prime sieve, primes, squared integers

```cpp
// nloglog(n)
vector<long long> sieve(int N) {
    int spf[N];
    for (int i = 0; i < N; i++) {
        spf[i] = i;
    }
    vector<long long> primes;
    for (int i = 2; i < N; i++) {
        if (spf[i] != i) continue;
        primes.push_back(i);
        for (int j = i * i; j < N; j += i) {
            if (spf[j] != j) continue;
            spf[j] = i;
        }
    }
    return primes;
}
class Solution {
public:
    int nonSpecialCount(int l, int r) {
        int upper = (int)sqrt(r) + 1;
        vector<long long> primes = sieve(upper);
        int ans = 0;
        for (long long p : primes) {
            if (p * p >= l && p * p <= r) ans++;
        }
        return r - l + 1 - ans;
    }
};
```

## 3234. Count the Number of Substrings With Dominant Ones

### Solution 1:  square root trick, fix the sliding window, deque

```cpp
class Solution {
public:
    int calc(const string& s, int cnt) {
        int ans = 0, N = s.size();
        deque<int> dq;
        for (int i = 0, j = 0; i < N; i++) {
            if (s[i] == '0') dq.push_back(i);
            if (dq.size() > cnt) {
                j = dq.front() + 1;
                dq.pop_front();
            }
            if (dq.size() == cnt) {
                int pcount = dq.empty() ? i - j + 1 : dq.front() - j + 1;
                int count_ones = i - j + 1 - cnt;
                int extra_ones = max(0, count_ones - cnt * cnt + 1);
                ans += min(pcount, extra_ones);
            }
        }
        return ans;
    }
    int numberOfSubstrings(string s) {
        int N = s.size(), ans = 0;
        for (int i = 0; i * i <= N; i++) ans += calc(s, i);
        return ans;
    }
};
```

## 3235. Check if the Rectangle Corner Is Reachable

### Solution 1:  

```cpp
struct UnionFind {
    vector<int> parents, size;
    void init(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};
bool intersection(long long x1, long long y1, long long x2, long long y2, int r1, int r2) {
    double d = sqrt((x1 - x2) * (x1 - x2)+ (y1 - y2) * (y1 - y2));
    if (d <= r1 - r2 || d <= r2 - r1 || d < r1 + r2 || d == r1 + r2) return true;
    return false;
}
class Solution {
public:
    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {
        int N = circles.size();
        UnionFind dsu;
        dsu.init(N + 2);
        for (int i = 0; i < N; i++) {
            int x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];
            if (r1 >= x1 || r1 >= Y - y1) dsu.same(i, N);
            if (r1 >= y1 || r1 >= X - x1) dsu.same(i, N + 1);
            for (int j = 0; j < i; j++) {
                int x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];
                if (intersection(x1, y1, x2, y2, r1, r2)) {
                    dsu.same(i, j);
                }
            }
        }
        return !dsu.same(N, N + 1);
    }
};
```

# Leetcode Weekly Contest 409

## 3244. Shortest Distance After Road Addition Queries II

### Solution 1:  doubly ended linked list, next and previous array, 

```cpp
class Solution {
public:
    vector<int> nxt, prv;
    int START, END;
    void erase(int x) {
        prv[nxt[x]] = prv[x];
        nxt[prv[x]] = nxt[x];
        prv[x] = START;
        nxt[x] = END;
    }
    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        // 0 and 6 will be,  1, 2, 3, 4, 5, 
        // 0,1,2,3,...,n
        nxt.assign(n + 2, n + 1);
        prv.assign(n + 2, 0);
        START = 0;
        END = n + 1;
        for (int i = 1; i <= n; i++) {
            nxt[i] = i + 1;
            prv[i] = i - 1;
        }
        int q = queries.size();
        int dist = n - 1;
        vector<int> ans(q);
        for (int i = 0; i < q; i++) {
            int u = queries[i][0], v = queries[i][1];
            u++; v++;
            u = nxt[u];
            while (u < v) {
                int nxt_u = nxt[u];
                erase(u);
                dist--;
                u = nxt_u;
            }
            ans[i] = dist;
        }
        return ans;
    }
};
```

## Alternating Groups III

### Solution 1:  lazy segment tree, circular, point queries, assignment, frequency array

```cpp
struct LazySegmentTree {
    vector<int> values;
    vector<int> operations;
    int size, noop = -1;
    // assignment of non-negative integers

    void init(int n) {
        size = 1;
        while (size < n) size *= 2;
        values.assign(2 * size, noop);
    }

    bool is_leaf(int segment_right_bound, int segment_left_bound) {
        return segment_right_bound - segment_left_bound == 1;
    }

    void propagate(int segment_idx, int segment_left_bound, int segment_right_bound) {
        if (is_leaf(segment_right_bound, segment_left_bound) || values[segment_idx] == noop) return;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        values[left_segment_idx] = values[segment_idx];
        values[right_segment_idx] = values[segment_idx];
        values[segment_idx] = noop;
    }
    void update(int left, int right, int val) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        vector<int> segments;
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (segment_left_bound >= right || segment_right_bound <= left) continue;
            // COMPLETE OVERLAP
            if (segment_left_bound >= left && segment_right_bound <= right) {
                values[segment_idx] = val;
                continue;
            }
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
    }
    int query(int i) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (i < segment_left_bound || i >= segment_right_bound) continue;
            // COMPLETE OVERLAP
            if (is_leaf(segment_right_bound, segment_left_bound)) return values[segment_idx];
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
        return -1;
    }
};
class Solution {
public:
    map<int, int> freq;
    int N, Q;
    bool flag;
    LazySegmentTree seg;
    int length(int l, int r) {
        if (r > l) return r - l;
        return N - l + r;
    }
    void increment(int v) {
        if (freq.find(v) == freq.end()) freq[v] = 0;
        freq[v]++;
    }
    void decrement(int v) {
        freq[v]--;
        if (freq[v] == 0) freq.erase(v);
    }
    void update(int l, int r, int c) {
        if (r > l) {
            seg.update(l, r, c);
        } else {
            seg.update(0, r, c);
            seg.update(l, N, c);
        }
    }
    vector<pair<int, int>> ranges(int l, int r, int i) {
        vector<pair<int, int>> res;
        if (length(l, r) == N && flag) {
            res.emplace_back((i + 1) % N, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
        } else {
            res.emplace_back(l, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
            res.emplace_back((i + 1) % N, r);
        }
        return res;
    }
    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {
        N = colors.size(), Q = queries.size();
        seg.init(N);
        int comp_id = 0, start = 0;
        flag = false;
        vector<pair<int, int>> comp_ranges; // ranges [L, R)
        for (int i = 1; i < N; i++) {
            if (colors[i] == colors[i - 1]) {
                increment(length(start, i));
                comp_ranges.emplace_back(start, i);
                update(start, i, comp_id++);
                start = i;
            }
        }
        if (colors[0] != colors.back() && comp_id > 0) {
            auto [l, r] = comp_ranges[0];
            decrement(length(l, r));
            comp_ranges[0] = {start, r};
            increment(length(start, r));
            update(start, N, 0);
        } else {
            if (length(start, N) == N && colors[0] != colors.back()) flag = true;
            increment(length(start, N));
            comp_ranges.emplace_back(start, N);
            update(start, N, comp_id++);
        }
        vector<int> ans;
        for (const vector<int> &vec : queries) {
            if (vec[0] == 1) {
                int sz = vec[1];
                int res = 0;
                int cnt = 0;
                for (const auto &[k, v] : freq) {
                    res += max(0, (k - sz + 1) * v);
                    cnt += v;
                }
                if (cnt == 1 && flag) ans.push_back(N);
                else ans.push_back(res);
            } else {
                int i = vec[1], col = vec[2];
                if (colors[i] == col) continue; // no 
                colors[i] = col;
                int cur_comp_id = seg.query(i);
                auto [l, r] = comp_ranges[cur_comp_id];
                if (length(l, r) == 1) { // merging Cr and Cl
                    int Cl = seg.query((l - 1 + N) % N);
                    int Cr = seg.query(r % N);
                    auto [ll, lr] = comp_ranges[Cl];
                    auto [rl, rr] = comp_ranges[Cr];
                    decrement(length(ll, lr));
                    if (Cl != Cr) decrement(length(rl, rr));
                    if (Cl == Cr) rr = rr < N ? rr + 1 : 1;
                    decrement(length(l, r));
                    increment(length(ll, rr));
                    if (length(ll, rr) == N && colors[ll] != colors[rr - 1]) {
                        flag = true;
                    }
                    comp_ranges.emplace_back(ll, rr);
                    update(ll, rr, comp_id++);
                } else if (length(l, r) == N && flag) {
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                } else if (i == l) { // start point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].first = (l + 1) % N;
                        increment(length(comp_ranges[cur_comp_id].first, r));
                    }
                    int left_comp = seg.query((i - 1 + N) % N);
                    auto [nl, nr] = comp_ranges[left_comp];
                    decrement(length(nl, nr));
                    nr = i + 1;
                    increment(length(nl, nr));
                    comp_ranges[left_comp] = {nl, nr};
                    update(nl, nr, left_comp);
                } else if (i == r - 1) { // end point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].second = r != 1 ? r - 1 : N;
                        increment(length(l, comp_ranges[cur_comp_id].second));
                    }
                    int right_comp = seg.query((i + 1) % N);
                    auto [nl, nr] = comp_ranges[right_comp];
                    decrement(length(nl, nr));
                    nl = i;
                    increment(length(nl, nr));
                    comp_ranges[right_comp] = {nl, nr};
                    update(nl, nr, right_comp);
                } else { // intermediate point
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 410

## Find the Count of Monotonic Pairs II

### Solution 1: dynamic programming, counting, prefix sums

```cpp
class Solution {
public:
    const int M = 1e9 + 7, MAXN = 1e3 + 3;
    int countOfPairs(vector<int>& nums) {
        int N = nums.size();
        vector<long long> dp(MAXN, 0), ndp(MAXN, 0);
        for (int i = 0; i <= nums[0]; i++) {
            dp[i] = 1;
        }
        for (int i = 1; i < N; i++) {
            ndp.assign(MAXN, 0);
            int delta = max(nums[i] - nums[i - 1], 0);
            long long psum = 0;
            for (int j = delta; j <= nums[i]; j++) {
                psum = (psum + dp[j - delta]) % M;
                ndp[j] = psum;
            }
            swap(dp, ndp);
        }
        long long ans = 0;
        for (long long x : dp) {
            ans = (ans + x) % M;
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 411

## Find the Largest Palindrome Divisible by K

### Solution 1:  recursive dp, digit dp, tracking digits picked in each dp state

```cpp
class Solution {
public:
    vector<vector<int>> dp;
    vector<vector<int>> track;
    vector<int> powers;
    int N, K, mid;
    int recurse(int i, int rem) {
        if (i > mid) return rem == 0;
        if (dp[i][rem] != -1) return dp[i][rem];
        for (int dig = 9; dig >= 0; dig--) {
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            if (recurse(i + 1, (rem + add) % K)) {
                track[i][rem] = dig;
                return dp[i][rem] = true;
            }
        }
        return dp[i][rem] = false;
    }
    string largestPalindrome(int n, int k) {
        N = n;
        K = k;
        mid = (N - 1) / 2;
        dp.assign(mid + 1, vector<int>(K, -1));
        track.assign(mid + 1, vector<int>(K, -1));
        powers.resize(N);
        powers[0] = 1;
        for (int i = 1; i < N; i++) {
            powers[i] = (powers[i - 1] * 10) % K;
        }
        recurse(0, 0);
        string ans = "";
        for (int i = 0, rem = 0; i <= mid; i++) {
            ans += track[i][rem] + '0';
            int dig = track[i][rem];
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            rem = (rem + add) % K;
        }
        string s = ans.substr(0, N / 2);
        reverse(s.begin(), s.end());
        ans += s;
        return ans;
    }
};
```

## Count Substrings That Satisfy K-Constraint II

### Solution 1:  fenwick tree, prefix sums, precomputation of last index, binary search

```cpp
#include <bits/stdc++.h>
using namespace std;

long long neutral = 0;
struct FenwickTree {
    vector<long long> nodes;
    
    void init(int n) {
        nodes.assign(n + 1, neutral);
    }

    void update(int idx, int val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }

    long long query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : 0;
    }

    long long query(int idx) {
        long long result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }
};

class Solution {
public:
    int binary_search(vector<int>& arr, int lo, int hi, int target) {
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (arr[mid] <= target) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
        int N = s.size();
        vector<int> last_index(N + 1);
        int c0 = 0, c1 = 0, last = 0;
        FenwickTree ft, ft2;
        ft.init(N);
        ft2.init(N);
        for (int i = 0; i < N; i++) {
            if (s[i] == '0') {
                c0++;
            } else {
                c1++;
            }
            while (c0 > k && c1 > k) {
                if (s[last] == '0') {
                    c0--;
                } else {
                    c1--;
                }
                last++;
            }
            last_index[i] = last;
            ft.update(i + 1, i - last + 1);
            ft2.update(i + 1, last);
        }
        vector<long long> ans;
        for (auto &query : queries) {
            int l = query[0], r = query[1];
            int i = binary_search(last_index, l, r, l);  // lower bound
            long long segment_len = i - l + 1;
            long long delta = l * segment_len - ft2.query(l + 1, i + 1);
            long long res = ft.query(l + 1, r + 1) - delta;
            ans.push_back(res);
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 412

## 3266. Final Array State After K Multiplication Operations II

### Solution 1: exponentiation, min heap, greedy, m = 2, it will grow fast to reach max value of only 10^5
it will grow really fast to reach the mx value of 10^9, with m = 2, it can happen in at most 60 operations, so you have 60 * N log(60 * N)
Now you have an array where all the values if multiplied by the multiplier m would exceed the largest value in the array.
You will evenly distribute the remainder operations between each element in the array, why does this work, because every time you multiplied by multiplier
the value will become the next max, if you have it sorted from smallest to largest.  The smallest will take lead, then the second smallest takes lead and so on. 
Then in the next iteration it will be back in original order with same maximum as previously.  So you just need to figure out how many times you will perform operation on entire array given remaining k operations.  Then you will maybe have some remainder where you will perform k + 1 operations on the prefix of the array and k on the rest of the array. 


```cpp
long long exponentiation(long long b, long long p, long long m) {
    long long res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    const int M = 1e9 + 7;
    vector<int> getFinalState(vector<int>& nums, int k, int m) {
        if (m == 1) return nums; // trivial case
        int N = nums.size();
        long long mx = *max_element(nums.begin(), nums.end());
        // minheap
        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> minheap;
        for (int i = 0; i < N; i++) {
            minheap.emplace(nums[i], i);
        }
        vector<pair<long long, int>> res;
        while (!minheap.empty() && k > 0) {
            auto [val, i] = minheap.top();
            minheap.pop();
            // do something
            if (val * m <= mx) {
                minheap.emplace(val * m, i);
                k--;
            } else {
                res.emplace_back(val, i);
            }
        }
        while (!minheap.empty()) {
            auto [val, i] = minheap.top();
            minheap.pop();
            res.emplace_back(val, i);
        }
        sort(res.begin(), res.end());
        vector<int> ans(N);
        if (k == 0) {
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first % M;
            }
        } else {
            int rem = k % N;
            int div = k / N;
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first * exponentiation(m, div, M) % M;
            }
            for (int i = 0; i < rem; i++) {
                ans[res[i].second] = ((long long)ans[res[i].second] * m) % M;
            }                

        }
        return ans;
    }
};

```

## 3267. Count Almost Equal Pairs II

### Solution 1:  frequency map, set, try every single swap, need optimizations
This one is tricky, it only passes if you include the s[i] = s[j] skipping parts.  So you need some optimizations in your code to remove unnecessary looping.

```cpp
class Solution {
public:
    int M;
    unordered_set<int> get(string s) {
        unordered_set<int> res;
        res.insert(stoi(s));
        for (int i = 0; i < M; i++) {
            for (int j = i + 1; j < M; j++) {
                if (s[i] == s[j]) continue;
                swap(s[i], s[j]);
                res.insert(stoi(s));
                for (int k = 0; k < M; k++) {
                    for (int l = 0; l < M; l++) {
                        if (s[k] == s[l]) continue;
                        swap(s[k], s[l]);
                        res.insert(stoi(s));
                        swap(s[k], s[l]);
                    }
                }
                swap(s[i], s[j]);
            }
        }
        return res;
    }
    int countPairs(vector<int>& nums) {
        M = to_string(*max_element(nums.begin(), nums.end())).size();
        unordered_map<int, int> freq;
        int N = nums.size();
        int ans = 0;
        for (int i = 0; i < N; i++) {
            string s = to_string(nums[i]);
            s = string(M - s.size(), '0') + s;
            unordered_set<int> candidates = get(s);
            for (const int &cand : candidates) {
                ans += freq[cand];
            }
            freq[nums[i]]++;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 413

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 414

## 3281. Maximize Score of Numbers in Ranges

### Solution 1:  binary search, greedy, sort

```cpp
class Solution {
public:
    const long long INF = 1e12;
    bool possible(const vector<int>& start, long long d, long long target) {
        long long last = -INF;
        for (int s : start) {
            long long best = last + target;
            last = max(best, (long long)s);
            if (last > s + d) return false;
        }
        return true;
    }
    int maxPossibleScore(vector<int>& start, int d) {
        sort(start.begin(), start.end());
        long long lo = 0, hi = INF;
        while (lo < hi) {
            long long mid = lo + (hi - lo + 1) / 2;
            if (possible(start, d, mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
};
```

## 3282. Reach End of Array With Max Score

### Solution 1:  monotonic stack, dynamic programming, greedy

1. just need to greedily pick the pmax at each step.

```cpp
class Solution {
public:
    long long findMaximumScore(vector<int>& nums) {
        long long ans = 0, pmax = 0;
        for (int x : nums) {
            ans += pmax;
            pmax = max((long long)x, pmax);
        }
        return ans;
    }
};
```

## 3283. Maximum Number of Moves to Kill All Pawns

### Solution 1: bitmask dp, minimax algorithm, graph, precompute min knight distances, bfs

1. For it to be fast enough it has to precompute the min distance from each pawn and include the knight as a pawn. 
2. Then it just needs to compute the best option for dp state (idx, mask, ismax)

```cpp
#define x first
#define y second
const int M = 50, INF = 1e9, P = 15;
const vector<pair<int, int>> MOVES = {{-2, 1}, {-2, -1}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {1, 2}, {-1, 2}};
int N, end_mask;
vector<pair<int, int>> pos;
int dist[M][M][M][M], dp[P + 1][1 << P][2];
bool in_bounds(int x, int y) {
    return x >= 0 && x < M && y >= 0 && y < M;
}
void bfs(int kx, int ky) {
    queue<pair<int, int>> q;
    q.emplace(kx, ky);
    dist[kx][ky][kx][ky] = 0;
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        for (auto [dx, dy] : MOVES) {
            int nx = x + dx, ny = y + dy;
            if (in_bounds(nx, ny) && dist[kx][ky][nx][ny] == -1) {
                dist[kx][ky][nx][ny] = dist[kx][ky][x][y] + 1;
                q.emplace(nx, ny);
            }
        }
    }
}
int minimax(int idx, int mask, bool ismax) {
    auto [x, y] = pos[idx];
    if (mask == end_mask) return 0;
    if (dp[idx][mask][ismax] != -1) return dp[idx][mask][ismax];
    int ans = ismax ? 0 : INF;
    for (int i = 0; i < N; i++) {
        if ((mask >> i) & 1) continue;
        if (ismax) {
            ans = max(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        } else {
            ans = min(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        }
    }
    return dp[idx][mask][ismax] = ans;
}
class Solution {
public:
    int maxMoves(int kx, int ky, vector<vector<int>>& poss) {
        N = poss.size();
        pos.resize(N);
        for (int i = 0; i < N; i++) {
            pos[i].x = poss[i][0], pos[i].y = poss[i][1];
        }
        pos.emplace_back(kx, ky);
        memset(dist, -1, sizeof(dist));
        for (const auto &[x, y] : pos) {
            bfs(x, y);
        }
        memset(dp, -1, sizeof(dp));
        end_mask = (1 << N) - 1;
        return minimax(N, 0, true); // (idx, mask, ismax)
    }
};
```

# Leetcode Weekly Contest 415

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 416

## Minimum Number of Seconds to Make Mountain Height Zero

### Solution 1:  greedy, binary search, quadratic formula, math

1. Binary search for how many seconds it will take for the workers to reach the target height. 
2. For each fixed t seconds, it will calculate how much height each worker will reduce.
3. So in binary search you will get FFFTTTTT, that is the first T is the minimum time it takes to reduce the height to 0.  So just binary search for that. 
4. In order to compute how much height each worker reduces it is related to a quadratic equation.  So you can determine how much height each reduce the mountain by.


```cpp
class Solution {
public:
    long long calc(long long worker, long long target) {
        if (worker == 0) return 0;
        long long discriminant = 1 + 8LL * target / worker;
        long long sqrt_discriminant = (long long)sqrt(discriminant);
        long long ans = (sqrt_discriminant - 1) / 2;
        return ans;
    }
    vector<long long> workers;
    int H, N;
    bool possible(long long target) {
        long long total = 0;
        for (int i = 0; i < N; i++) {
            total += calc(workers[i], target);
            if (total >= H) return true;
        }
        return false;
    }
    long long minNumberOfSeconds(int height, vector<int>& workerTimes) {
        N = workerTimes.size();
        H = height;
        workers = vector<long long>(workerTimes.begin(), workerTimes.end());
        long long lo = 0, hi = 1e16;
        while (lo < hi) {
            long long mid = lo + (hi - lo) / 2;
            if (possible(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }
};
```

## Count Substrings That Can Be Rearranged to Contain a String II

### Solution 1:  sliding window, frequency, two pointers

```cpp
class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int N = word1.size();
        vector<long long> freq(26, 0);
        long long need = 0;
        for (char c : word2) {
            if (freq[c - 'a'] == 0) {
                need++;
            }
            freq[c - 'a']++;
        }
        long long ans = 0;
        for (int l = 0, r = 0; r < N; r++) {
            int v = word1[r] - 'a';
            freq[v]--;
            if (freq[v] == 0) {
                need--;
            }
            while (need == 0) {
                int u = word1[l] - 'a';
                if (freq[u] == 0) break;
                freq[u]++;
                l++;
            }
            if (need == 0) {
                ans += l + 1;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 417

## 3306. Count of Substrings Containing Every Vowel and K Consonants II

### Solution 1:  sliding window, string, frequency array, prefix sum

1. A window is valid whenever the number of consonants is less than or equal to k and all vowels are contained. 
1. You track number of vowels needed with `need` variable, and also track number of consonants with `cnt` variable.
1. If it ever exceeds the count you need to move left pointer until you get it back to being equal.  
1. And you also track how many vowels are needed in this new windows.

```cpp
class Solution {
public:
    const string VOWELS = "aeiou";
    int coefficient(char ch) {
        return ch - 'a';
    }
    bool isVowel(char ch) {
        return VOWELS.find(ch) != string::npos;
    }
    long long countOfSubstrings(string word, int k) {
        int N = word.size();
        vector<long long> freq(26, 0);
        int need = 5, cnt = 0;
        vector<long long> psum(N + 1, 0);
        for (int i = 0; i < N; i++) {
            psum[i + 1] = psum[i];
            if (!isVowel(word[i])) {
                psum[i + 1]++;
            }
        }
        long long ans = 0;
        for (int l = 0, r = 0; r < N; r++) {
            int c = coefficient(word[r]);
            freq[c]++;
            if (!isVowel(word[r])) {
                cnt++;
            } else if (isVowel(word[r]) && freq[c] == 1) {
                need--;
            }
            while (cnt > k) {
                int coef = coefficient(word[l]);
                freq[coef]--;
                if (isVowel(word[l])) {
                    if (freq[coef] == 0) need++;
                } else {
                    cnt--;
                }
                l++;
            }
            if (need > 0) continue;
            while (true) {
                int v = coefficient(word[l]);
                if (!isVowel(word[l])) cnt--;
                if (isVowel(word[l]) && freq[v] == 1) break;
                freq[v]--;
                l++;
            }
            if (psum[r + 1] < k) continue;
            int ub = lower_bound(psum.begin(), psum.end(), psum[r + 1] - k + 1) - psum.begin();
            ub = min(ub, l + 1);
            int lb = lower_bound(psum.begin(), psum.end(), psum[r + 1] - k) - psum.begin();
            ans += ub - lb;
        }
        return ans;
    }
};
```

### Solution 2: sliding window, different, at least k consonants.

create a function that counts the number of substrings where count of consonants is greater than or equal to k.

f(k) - f(k + 1)

```cpp
class Solution {
public:
    const string VOWELS = "aeiou";
    int coefficient(char ch) {
        return ch - 'a';
    }
    bool isVowel(char ch) {
        return VOWELS.find(ch) != string::npos;
    }
    long long countGreaterThanK(string word, int k) {
        int N = word.size();
        vector<long long> freq(26, 0);
        int need = 5, cnt = 0;
        long long ans = 0;
        for (int l = 0, r = 0; l < N; l++) {
            while (r < N && (need > 0 || cnt < k)) {
                int v = coefficient(word[r]);
                freq[v]++;
                if (!isVowel(word[r])) {
                    cnt++;
                } else if (freq[v] == 1) {
                    need--;
                }
                r++;
            }
            if (need == 0 && cnt >= k) ans += N - r + 1;
            int v = coefficient(word[l]);
            freq[v]--;
            if (!isVowel(word[l])) {
                cnt--;
            } else if (freq[v] == 0) {
                need++;
            }
        }
        return ans;
    }
    long long countOfSubstrings(string word, int k) {
        return countGreaterThanK(word, k) - countGreaterThanK(word, k + 1);
    }
};
```

## 3307. Find the K-th Character in String Game II

### Solution 1: bit manipulation, recursive, powers of two

```cpp
class Solution {
public:
    char kthCharacter(long long k, vector<int>& operations) {
        int i = log2(k);
        int cnt = 0;
        while (k > 1) {
            if (k > (1LL << i)) {
                cnt += operations[i];
                k -= (1LL << i);
            }
            i--;
        }
        return 'a' + (cnt % 26);
    }
};
```

# Leetcode Weekly Contest 418

## 3310. Remove Methods From Project

### Solution 1:  dfs, directed graph

```cpp
class Solution {
public:
    vector<bool> sus;
    vector<vector<int>> adj;
    void dfs(int u) {
        if (sus[u]) return;
        sus[u] = true;
        for (int v : adj[u]) {
            dfs(v);
        }
    }
    vector<int> remainingMethods(int n, int k, vector<vector<int>>& invocations) {
        adj.assign(n, vector<int>());
        for (const auto &e : invocations) {
            int u = e[0], v = e[1];
            adj[u].push_back(v);
        }
        sus.assign(n, false);
        dfs(k);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if (sus[i]) continue;
            for (int j : adj[i]) {
                if (sus[j]) {
                    ans.resize(n);
                    iota(ans.begin(), ans.end(), 0);
                    return ans;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (sus[i]) continue;
            ans.push_back(i);
        }
        return ans;
    }
};
```

## 3311. Construct 2D Grid Matching Graph Layout

### Solution 1:  construction, undirected graph

```cpp
class Solution {
public:
    vector<vector<int>> constructGridLayout(int n, vector<vector<int>>& edges) {
        int N = edges.size();
        vector<int> deg(n, 0);
        vector<unordered_set<int>> adj(n, unordered_set<int>());
        for (const auto &e : edges) {
            int u = e[0], v = e[1];
            deg[u]++;
            deg[v]++;
            adj[u].insert(v);
            adj[v].insert(u);
        }
        int mindeg = *min_element(deg.begin(), deg.end());
        int u;
        for (int i = 0; i < n; i++) {
            if (deg[i] == mindeg) {
                u = i;
                break;
            }
        }
        int r = 0, c = 0, R = 0, C = 0;
        vector<vector<int>> grid;
        while (n--) {
            if (r == grid.size()) grid.push_back({});
            grid[r].push_back(u);
            deg[u] = 0;
            bool corner = false;
            bool stuck = true;
            for (int v : adj[u]) {
                if (deg[v] != mindeg) continue;
                if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                u = v;
                corner = true;
                stuck = false;
                break;
            }
            if (!corner) {
                for (int v : adj[u]) {
                    if (deg[v] != mindeg + 1) continue;
                    if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                    u = v;
                    stuck = false;
                }
            }
            if (stuck) {
                for (int v : adj[u]) {
                    if (!deg[v]) continue;
                    if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                    u = v;
                    stuck = false;
                }
            }
            c++;
            if (r == 0) C = c + 1;
            if (corner || (r > 0 && c + 1 == C)) {
                deg[u] = 0;
                grid[r].push_back(u);
                n--;
                r++;
                c = 0;
                u = grid[r - 1][c];
                for (int v : adj[u]) {
                    if (!deg[v]) continue;
                    u = v;
                    break;
                }
            }
        }
        return grid;
    }
};
```

## 3312. Sorted GCD Pair Queries

### Solution 1:  inclusion-exclusion principle, gcd, counting divisors, prefix sums, binary search

```cpp
const int MAXN = 50'001;
long long divcount[MAXN], gcdcount[MAXN];

long long choose(long long n) {
    return n * (n - 1) / 2;
}
class Solution {
private:
    static vector<int> divisors[MAXN];
    static bool precomputed;
    static void precompute() {
        if (precomputed) return;
        for (int x = 1; x < MAXN; x++) {
            for (int y = x; y < MAXN; y += x) {
                divisors[y].push_back(x);
            }
        }
        precomputed = true;
    }
public:
    vector<int> gcdValues(vector<int>& nums, vector<long long>& queries) {
        precompute();
        int N = nums.size(), M = queries.size();
        int MX = *max_element(nums.begin(), nums.end());
        memset(divcount, 0, sizeof(divcount));
        memset(gcdcount, 0, sizeof(gcdcount));
        unordered_map<int, int> freq;
        for (int x : nums) {
            freq[x]++;
        }
        for (const auto &[k, v] : freq) {
            for (int d : divisors[k]) {
                divcount[d] += v;
            }
        }
        vector<int> gcdvals;
        for (int g = MX; g >= 0; g--) {
            if (divcount[g] <= 1) continue;
            gcdcount[g] = choose(divcount[g]);
            for (int gg = 2 * g; gg <= MX; gg += g) {
                gcdcount[g] -= gcdcount[gg];
            }
            gcdvals.push_back(g);
        }
        reverse(gcdvals.begin(), gcdvals.end());
        vector<long long> psum(gcdvals.size(), 0);
        for (int i = 0; i < gcdvals.size(); i++) {
            psum[i] = gcdcount[gcdvals[i]];
            if (i > 0) psum[i] += psum[i - 1];
        }
        vector<int> ans(M, 0);
        for (int i = 0; i < M; i++) {
            int idx = lower_bound(psum.begin(), psum.end(), queries[i] + 1) - psum.begin();
            ans[i] = gcdvals[idx];
        }
        return ans;
    }
};
vector<int> Solution::divisors[MAXN];
bool Solution::precomputed = false;
```

# Leetcode Weekly Contest 419

## 3319. K-th Largest Perfect Subtree Size in Binary Tree

### Solution 1:  postorder dfs, perfect binary tree, sorting

```cpp
class Solution {
public:
    vector<int> sizes;
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;
        int left = dfs(root -> left), right = dfs(root -> right);
        if (left == -1 || right == -1 || left != right) return -1;
        sizes.push_back(left + right + 1);
        return left + right + 1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sizes.rbegin(), sizes.rend());
        return k <= sizes.size() ? sizes[k - 1] : -1;
    }
};
```

## 3320. Count The Number of Winning Sequences

### Solution 1:  recursive dynamic programming, counting

```cpp
const long long MOD = 1e9 + 7;
const string CHARS = "FWE";
class Solution {
public:
    int N;
    string S;
    vector<vector<long long>> dp[4];
    // score of a compared to b
    bool score(char a, char b) {
        if (a == 'F' && b =='E') return true;
        if (a == 'E' && b == 'W') return true;
        if (a == 'W' && b == 'F') return true;
        return false;
    }
    long long dfs(int idx, int pts, int last) {
        if (idx == N) {
            return pts > N ? 1 : 0;
        }
        if (dp[last][idx][pts] != -1) return dp[last][idx][pts];
        long long ans = 0;
        // pick characters for bob
        for (int i = 0; i < 3; i++) {
            if (i == last) continue;
            if (score(CHARS[i], S[idx])) {
                ans = (ans + dfs(idx + 1, pts + 1, i)) % MOD;
            } else if (score(S[idx], CHARS[i])) {
                ans = (ans + dfs(idx + 1, pts - 1, i)) % MOD;
            } else {
                ans = (ans + dfs(idx + 1, pts, i)) % MOD;
            }
        }
        return dp[last][idx][pts] = ans;
    }
    int countWinningSequences(string s) {
        N = s.size();
        for (int i = 0; i < 4; i++) {
            dp[i].assign(N, vector<long long>(2 * N + 1, -1));
        }
        S = s;
        return dfs(0, N, 3);
    }
};
```

## 3321. Find X-Sum of All K-Long Subarrays II

### Solution 1:  fixed sized window, minheap, maxheap, frequency map, set

```cpp
class Solution {
public:
    priority_queue<pair<long long, long long>> maxheap;
    priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> minheap;
    unordered_set<long long> window;
    unordered_map<long long, long long> freq;
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        long long wsum = 0;
        int N = nums.size();
        vector<long long> ans(N - k + 1);
        for (int i = 0; i < N; i++) {
            long long v = nums[i];
            freq[v]++;
            if (window.size() < x || window.count(nums[i])) {
                wsum += v;
                window.insert(v);
                minheap.emplace(freq[v], v);
            } else {
                while (!minheap.empty() && (freq[minheap.top().second] != minheap.top().first || !window.count(minheap.top().second))) minheap.pop();
                if (!minheap.empty() && (freq[v] > minheap.top().first || (freq[v] == minheap.top().first && v > minheap.top().second))) {
                    auto [f, p] = minheap.top();
                    // removal from window
                    minheap.pop();
                    wsum -= p * f;
                    window.erase(p);
                    maxheap.emplace(f, p);
                    // add the new element into the window
                    wsum += v * freq[v];
                    window.insert(v);
                    minheap.emplace(freq[v], v);
                } else {
                    maxheap.emplace(freq[v], v);
                }
            }
            if (i >= k - 1) {
                ans[i - k + 1] = wsum;
                v = nums[i - k + 1];
                freq[v]--;
                if (window.count(v)) {
                    wsum -= v;
                    while (!maxheap.empty() && (freq[maxheap.top().second] != maxheap.top().first || window.count(maxheap.top().second))) maxheap.pop();
                    if (!maxheap.empty() && (freq[v] < maxheap.top().first || (freq[v] == maxheap.top().first && v < maxheap.top().second))) {
                        // remove value from window
                        window.erase(v);
                        wsum -= freq[v] * v;
                        if (freq[v] > 0) maxheap.emplace(freq[v], v);
                        // add old value into window
                        auto [f, p] = maxheap.top();
                        maxheap.pop();
                        window.insert(p);
                        wsum += f * p;
                        minheap.emplace(f, p);
                    } else if (freq[v] == 0) {
                        window.erase(v);
                    } else {
                        minheap.emplace(freq[v], v);
                    }
                } else {
                    maxheap.emplace(freq[v], v);
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 420

## 3325. Count Substrings With K-Frequency Characters I

### Solution 1:  sliding window, frequency array

```cpp
class Solution {
public:
    int unicode(char ch) {
        return ch - 'a';
    }
    int freq[26];
    int numberOfSubstrings(string s, int k) {
        int N = s.size();
        bool found = false;
        int ans = 0;
        for (int i = 0, j = 0; i < N; i++) {
            int c = unicode(s[i]);
            freq[c]++;
            found |= (freq[c] == k);
            while (freq[c] == k) {
                freq[unicode(s[j])]--;
                j++;
            }
            if (found) ans += j;
        }
        return ans;
    }
};
```

## 3326. Minimum Division Operations to Make Array Non Decreasing

### Solution 1:  static precomputation, prime sieve to get smallest prime factor, greedy

```cpp
class Solution {
private:
    static bool precomputed;
    static const int MAXN = 1e6 + 5;
    static int spf[MAXN];
    // nloglog(n)
    static void sieve(int n) {
        if (precomputed) return;
        for (int i = 0; i < n; i++) {
            spf[i] = i;
        }
        for (int i = 2; i < n; i++) {
            if (spf[i] != i) continue;
            for (long long j = (long long)i * i; j < n; j += i) {
                if (spf[j] != j) continue;
                spf[j] = i;
            }
        }
        precomputed = true;
    }
public:
    int minOperations(vector<int>& nums) {
        sieve(MAXN);
        int thres = MAXN;
        int ans = 0;
        reverse(nums.begin(), nums.end());
        for (int x : nums) {
            if (x > thres && spf[x] > thres) return -1;
            if (x > thres) {
                ans++;
                x = spf[x];
            }
            thres = min(thres, x);
        }
        return ans;
    }
};
int Solution::spf[MAXN];
bool Solution::precomputed = false;
```

## 3327. Check if DFS Strings Are Palindromes

### Solution 1:  post order traversal, tree, dfs, tree counter, manacher's algorithm, palindromic range queries

1. Important to get the string in the post order traversal of the tree.
1. That way you can query the ranges based on the post order traversal of the tree.
1. perform palindromic range queries using precomputation by manacher's algorithm.

```cpp
class Solution {
public:
    vector<vector<int>> adj;
    int counter;
    vector<bool> ans;
    vector<int> marr, remap;
    vector<int> manacher(const string& s) {
        string t = "#";
        for (char ch : s) {
            t += ch;
            t += "#";
        }
        vector<int> parr = manacher_odd(t);
        return parr;
    }
    vector<int> manacher_odd(string& s) {
        int N = s.size();
        s = "$" + s + "^";
        vector<int> P(N + 2, 0);
        int l = 1, r = 1;
        for (int i = 1; i <= N; i++) {
            P[i] = max(0, min(r - i, P[l + (r - i)]));
            while (s[i - P[i]] == s[i + P[i]]) {
                P[i]++;
            }
            if (i + P[i] > r) {
                l = i - P[i];
                r = i + P[i];
            }
        }
        return vector<int>(P.begin() + 1, P.end() - 1);
    }
    // [l, r)
    bool query(int l, int r) {
        return marr[l + r] > r - l;
    }
    void dfs1(int u) {
        for (int v : adj[u]) {
            dfs1(v);
        }
        remap[counter] = u;
        counter++;
    }
    void dfs(int u) {
        int start = counter;
        for (int v : adj[u]) {
            dfs(v);
        }
        counter++;
        ans[u] = query(start, counter);
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int N = s.size();
        adj.assign(N, vector<int>());
        for (int i = 1; i < N; i++) {
            adj[parent[i]].emplace_back(i);
        }
        counter = 0;
        remap.assign(N, 0);
        dfs1(0);
        string t = "";
        for (int i : remap) {
            t += s[i];
        }
        marr = manacher(t);
        counter = 0;
        ans.assign(N, false);
        dfs(0);
        return ans;
    }
};
```

# Leetcode Weekly Contest 421

## 3334. Find the Maximum Factor Score of Array

### Solution 1: 

```cpp
class Solution {
public:
    int N;
    long long gcd_array(const vector<int>& arr, int i) {
        long long g = 0;
        for (int j = 0; j < N; j++) {
            if (i == j) continue;
            g = gcd(g, arr[j]);
        }
        return g;
    }
    long long lcm_array(const vector<int>& arr, int i) {
        long long l = 1;
        for (int j = 0; j < N; j++) {
            if (i == j) continue;
            l = lcm(l, arr[j]);
        }
        return l;
    }
    long long factorScore(const vector<int>& arr, int i) {
        return gcd_array(arr, i) * lcm_array(arr, i);
    }
    long long maxScore(vector<int>& nums) {
        N = nums.size();
        long long ans = factorScore(nums, -1);
        if (N == 1) return ans;
        for (int i = 0; i < N; i++) {
            ans = max(ans, factorScore(nums, i));
        }
        return ans;
    }
};
```

## 3335. Total Characters in String After Transformations I

### Solution 1: 

```cpp
class Solution {
private:
    const int MAXN = 1e5 + 30;
    const long long MOD = 1e9 + 7;
    static bool precomputed;
    static vector<long long> dp;
    void precompute() {
        if (precomputed) return;
        dp.assign(MAXN, 0);
        for (int i = 0; i < MAXN; i++) {
            if (i < 26) dp[i] = 1;
            else dp[i] = (dp[i - 26] + dp[i - 26 + 1]) % MOD;
        }
        precomputed = true;
    }
public:
    int lengthAfterTransformations(string s, int t) {
        precompute();
        long long ans = 0;
        for (const char& ch : s) {
            int delta = ch - 'a';
            ans = (ans + dp[t + delta]) % MOD;
        }
        return ans;
    }
};
vector<long long> Solution::dp;
bool Solution::precomputed = false;
```

## 3336. Find the Number of Subsequences With Equal GCD

### Solution 1:  dynamic programming, gcd, counting subsequences

1. Similar to knapsack problem, you either include it in bag 1 or bag 2 or neither.

```cpp
#define int64 long long
const int MAXN = 205;
const int64 MOD = 1e9 + 7;

class Solution {
private:
    int N;
    int64 dp[MAXN][MAXN][MAXN];
    vector<int> arr;
    int64 dfs(int i, int g1, int g2) {
        if (i == N) return g1 > 0 && g1 == g2;
        if (dp[i][g1][g2] != -1) return dp[i][g1][g2];
        int ng1 = g1 != 0 ? gcd(g1, arr[i]) : arr[i];
        int ng2 = g2 != 0 ? gcd(g2, arr[i]) : arr[i];
        int64 ans = dfs(i + 1, g1, g2) + dfs(i + 1, ng1, g2) + dfs(i + 1, g1, ng2);
        return dp[i][g1][g2] = ans % MOD;
    }
public:
    int subsequencePairCount(vector<int>& nums) {
        N = nums.size();
        arr = vector<int>(nums.begin(), nums.end());
        int M = *max_element(nums.begin(), nums.end());
        for (int i = 0; i <= N; i++) {
            for (int j = 0; j <= M; j++) {
                for (int k = 0; k <= M; k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        return dfs(0, 0, 0);
    }
};
```

## 3337. Total Characters in String After Transformations II

### Solution 1: matrix exponentiation, linear algebra, matrix multiplication

1. Map out the transitions and good to go T^pB = A, gives the result, just need to know how to represent transition matrix really. 

```cpp
using int64 = long long;
const int MOD = 1e9 + 7;

class Solution {
private:
    int decode(char ch) {
        return ch - 'a';
    }
    vector<vector<int64>> matMul(const vector<vector<int64>>& mat1, const vector<vector<int64>>& mat2) {
        int rows1 = mat1.size(), cols1 = mat1[0].size();
        int rows2 = mat2.size(), cols2 = mat2[0].size();
        vector<vector<int64>> resultMatrix(rows1, vector<int64>(cols2, 0));
        for (int i = 0; i < rows1; i++) {
            for (int j = 0; j < cols2; j++) {
                for (int k = 0; k < cols1; k++) {
                    resultMatrix[i][j] = (resultMatrix[i][j] + mat1[i][k] * mat2[k][j]) % MOD;
                }
            }
        }
        return resultMatrix;
    }

    vector<vector<int64>> matPow(const vector<vector<int64>>& matrix, int power) {
        if (power <= 0) {
            cout << "n must be non-negative integer" << endl;
            return {};
        }
        if (power == 1) return matrix;
        if (power == 2) return matMul(matrix, matrix);

        vector<vector<int64>> t1 = matPow(matrix, power / 2);
        if (power % 2 == 0) {
            return matMul(t1, t1);
        }
        return matMul(t1, matMul(matrix, t1));
    }
public:
    int lengthAfterTransformations(string s, int t, vector<int>& nums) {
        vector<vector<int64>> baseMatrix(26, vector<int64>(1, 0)), transitionMatrix(26, vector<int64>(26, 0));
        for (char ch : s) {
            baseMatrix[decode(ch)][0]++;
        }
        for (int i = 0; i < 26; i++) {
            for (int j = i, cnt = nums[i]; cnt > 0; cnt--) {
                j = (j + 1) % 26;
                transitionMatrix[j][i] = 1;
            }
        }
        vector<vector<int64>> exponentiatedMatrix = matPow(transitionMatrix, t);
        vector<vector<int64>> solutionMatrix = matMul(exponentiatedMatrix, baseMatrix);
        int ans = 0;
        for (int i = 0; i < 26; i++) {
            ans = (ans + solutionMatrix[i][0]) % MOD;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 422

## 3341. Find Minimum Time to Reach Last Room I

### Solution 1:  minheap, greedy

```cpp
struct Position {
    int t, r, c;
    Position() {}
    Position(int t, int r, int c) : t(t), r(r), c(c) {}
    bool operator<(const Position& other) const {
        return t > other.t;
    }
};
class Solution {
private:
    const int INF = 1e9;
    int R, C;
    bool in_bounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    vector<pair<int, int>> neighborhood(int r, int c) {
        return {{r + 1, c}, {r - 1, c}, {r, c + 1}, {r, c - 1}};
    }
public:
    
    int minTimeToReach(vector<vector<int>>& grid) {
        R = grid.size(), C = grid[0].size();
        vector<vector<int>> dist(R, vector<int>(C));
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                dist[i][j] = 0;
            }
        }
        priority_queue<Position> minheap;
        minheap.emplace(0, 0, 0);
        while (!minheap.empty()) {
            Position pos = minheap.top();
            minheap.pop();
            if (pos.r == R - 1 && pos.c == C - 1) return pos.t;
            for (const auto &[nr, nc] : neighborhood(pos.r, pos.c)) {
                if (!in_bounds(nr, nc)) continue;
                int ntime = max(pos.t + 1, grid[nr][nc] + 1);
                if (dist[nr][nc] > 0 && ntime >= dist[nr][nc]) continue;
                minheap.emplace(ntime, nr, nc);
                dist[nr][nc] = ntime;
            }
        }
        return -1;
    }
};
```

## 3342. Find Minimum Time to Reach Last Room II

### Solution 1:  minheap, greedy

```cpp
struct Position {
    int t, r, c, step;
    Position() {}
    Position(int t, int r, int c, int step) : t(t), r(r), c(c), step(step) {}
    bool operator<(const Position& other) const {
        return t > other.t;
    }
};
class Solution {
private:
    int R, C;
    bool in_bounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    vector<pair<int, int>> neighborhood(int r, int c) {
        return {{r + 1, c}, {r - 1, c}, {r, c + 1}, {r, c - 1}};
    }
public:
    
    int minTimeToReach(vector<vector<int>>& grid) {
        R = grid.size(), C = grid[0].size();
        vector<vector<int>> dist(R, vector<int>(C));
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                dist[i][j] = 0;
            }
        }
        priority_queue<Position> minheap;
        minheap.emplace(0, 0, 0, 1);
        while (!minheap.empty()) {
            Position pos = minheap.top();
            minheap.pop();
            if (pos.r == R - 1 && pos.c == C - 1) return pos.t;
            for (const auto &[nr, nc] : neighborhood(pos.r, pos.c)) {
                if (!in_bounds(nr, nc)) continue;
                int ntime = max(pos.t + pos.step, grid[nr][nc] + pos.step);
                if (dist[nr][nc] > 0 && ntime >= dist[nr][nc]) continue;
                minheap.emplace(ntime, nr, nc, 3 - pos.step);
                dist[nr][nc] = ntime;
            }
        }
        return -1;
    }
};
```

## 3343. Count Number of Balanced Permutations

### Solution 1:  dynamic programming, combinatorics, counting, frequency, prefix sum

1. Observe that the sum of the even and odd digits must be equal and thus equal to have the sum of all the digits.  This also means the the sum must be even.
1. Consider you are looping over the digits you can take, which is bounded by the total frequency of each digit, just do it in ascending order because why not?  It is easy.  so 0,1,2,3,4,...,9.
1. At each digit, iterate over how many you take for the even index element, up the the total frequency of that digit.
1. In the dp state track the digit, sum of the even digits, and the count of the digits taken.  
1. Based on this information you can infer how many digits have been taken for the odd index elements. 
1. When you are picking n of digit d, You can count the number of combinations based on how many remaining spots are still available for even index.  Because you can pick any of those remaining spots for the n of digit d, so it is like comb(remaining spots for even index, n). But if you pick n of them for even, then the rest of them are used for the odd index, so you need to know remaining spots for odd index as well.  comb(remaining spots for odd index, freq(i) - n).
1. Now it turns out you know the remaining spots for even index based on total number of digits assigned to even index so far.  And also you can infer from that how many remain for odd index as well. So you can just do dp(i + 1, s + nd, c + n) comb(remaining spots for even index, n) * comb(remaining spots for odd index, freq(i) - n) * dp(i, s, c), where c = remaining spots for even index, and s = sum of even digits so far.

```cpp
#define int64 long long
class Solution {
private:
    const int64 MOD = 1e9 + 7;
    int64 sum, C, N, C2;
    vector<vector<vector<int64>>> dp;
    int64 freq[10], pre[11];
    int64 ceil(int64 x, int64 y) {
        return (x + y - 1) / y;
    }
    int64 inv(int64 i, int64 m) {
      return i <= 1 ? i : m - (int64)(m/i) * inv(m % i, m) % m;
    }
    vector<int64> fact, inv_fact;
    void factorials(int64 n, int64 m) {
        fact.assign(n + 1, 1);
        inv_fact.assign(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % m;
        }
        inv_fact.end()[-1] = inv(fact.end()[-1], m);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
        }
    }
    int64 choose(int64 n, int64 r, int64 m) {
        if (n < r) return 0;
        return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
    }
    int64 dfs(int64 i, int j, int k) {
        if (i == 10 && j == sum && k == C) return 1;
        if (i == 10 || j > sum || k > C) return 0;
        if (dp[i][j][k] != -1) return dp[i][j][k];
        int64 ans = 0, psum = 0;
        for (int64 take = 0; take <= freq[i]; take++) {
            int64 x = choose(C - k, take, MOD) * choose(C2 - (pre[i] - k), freq[i] - take, MOD) % MOD;
            int64 y = x * dfs(i + 1, j + psum, k + take) % MOD;
            ans = (ans + y) % MOD;
            psum += i;
        }
        return dp[i][j][k] = ans;
    }
public:
    int countBalancedPermutations(string num) {
        N = num.size();
        factorials(N, MOD);
        C = ceil(N, 2);
        C2 = N / 2;
        sum = 0;
        for (char ch : num) {
            sum += ch - '0';
            freq[ch - '0']++;
        }
        for (int i = 0; i < 10; i++) {
            pre[i + 1] += pre[i] + freq[i];
        }
        if (sum & 1) return 0;
        sum /= 2;
        dp.assign(10, vector<vector<int64>>(sum + 1, vector<int64>(C + 1, -1)));
        return dfs(0, 0, 0);
    }
};
```

# Leetcode Weekly Contest 423

## 3350. Adjacent Increasing Subarrays Detection II

### Solution 1:  greedy, construction

```cpp
class Solution {
public:
    const int INF = 1e9 + 5;
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> arr;
        int cnt = 0, prv = -INF;
        for (int x : nums) {
            if (x <= prv) {
                arr.emplace_back(cnt);
                cnt = 0;
            }
            cnt++;
            prv = x;
        }
        arr.emplace_back(cnt);
        int ans = arr[0] / 2;
        for (int i = 1; i < arr.size(); i++) {
            ans = max(ans, min(arr[i - 1], arr[i]));
            ans = max(ans, arr[i] / 2);
        }
        return ans;
    }
};
```

## 3351. Sum of Good Subsequences

### Solution 1:  dynamic programming, counting

```cpp
#define int64 long long
class Solution {
private:
    const int MOD = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int M = *max_element(nums.begin(), nums.end());
        vector<int64> dp(M + 2, 0), cnt(M + 2, 0);
        for (int i : nums) {
            int64 c = cnt[i + 1] + 1;
            if (i > 0) c = (c + cnt[i - 1]) % MOD;
            dp[i] = (dp[i] + dp[i + 1] + c * i % MOD) % MOD;
            if (i > 0) dp[i] = (dp[i] + dp[i - 1]) % MOD;
            cnt[i] = (cnt[i] + c) % MOD;
        }
        int64 ans = 0;
        for (int v : dp) {
            ans = (ans + v) % MOD;
        }
        return ans;
    }
};
```

## 3352. Count K-Reducible Numbers Less Than N

### Solution 1: 

```cpp
#define int64 long long
class Solution {
private:
    vector<vector<int64>> pascal;
    vector<int64> pre;
    int N;
    const int MOD = 1e9 + 7;
public:
    int countKReducibleNumbers(string s, int k) {
        N = s.size();
        pascal.assign(N + 1, vector<int64>(N + 1, 0));
        pre.assign(N + 1, 0);
        pre[0] = 1;
        for (int x = 1; x <= N; x++) {
            int c = __builtin_popcount(x);
            pre[x] = pre[c] + 1;
        }
        for (int i = 0; i < N; i++) {
            pascal[i][0] = pascal[i][i] = 1;
            for (int j = 1; j < i; j++) {
                pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]) % MOD;
            }
        }
        vector<int> ones;
        for (int i = 0; i < N; i++) {
            if (s[i] == '1') {
                ones.emplace_back(N - i);
            }
        }
        int64 psum = 0, ans = 0;
        for (int x : ones) {
            psum++;
            for (int i = 0; i < x - 1; i++) {
                for (int j = 0; j <= i; j++) {
                    if (pre[psum + j] <= k) {
                        ans = (ans + pascal[i][j]) % MOD;
                    }
                }
            }
            if (pre[psum] <= k) ans = (ans + 1) % MOD;
        }
        if (pre[ones.size()] <= k) ans = (ans - 1 + MOD) % MOD;
        return ans;
    }
};
```

# Leetcode Weekly Contest 424

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 425

## 3365. Rearrange K Substrings to Form Target String

### Solution 1:  sorting, substring

```cpp
class Solution {
private:
    vector<string> splitString(const string& s, int n) {
        vector<string> res;
        for (int i = 0; i < s.size(); i += n) {
            res.emplace_back(s.substr(i, n));
        }
        return res;
    }
public:
    bool isPossibleToRearrange(string s, string t, int k) {
        int N = s.size() / k;
        vector<string> A = splitString(s, N), B = splitString(t, N);
        sort(A.begin(), A.end());
        sort(B.begin(), B.end());
        for (int i = 0; i < k; i++) {
            if (A[i] != B[i]) return false;
        }
        return true;
    }
};
```

## 3366. Minimum Array Sum

### Solution 1:  recursive dynamic programming

1. O(N^3) time complexity

```cpp
class Solution {
private:
    int ceil(int x, int y) {
        return (x + y - 1) / 2;
    }
    int N, K;
    vector<int> A;
    vector<vector<vector<int>>> dp;
    int recurse(int i, int op1, int op2) {
        if (i == N) return 0;
        if (dp[i][op1][op2] != -1) return dp[i][op1][op2];
        int ans = recurse(i + 1, op1, op2);
        if (op1) {
            ans = max(ans, recurse(i + 1, op1 - 1, op2) + A[i] / 2);
        }
        if (op2 && A[i] >= K) {
            ans = max(ans, recurse(i + 1, op1, op2 - 1) + K);
        }
        if (op1 && op2 && A[i] >= K) {
            if (ceil(A[i], 2) >= K) {
                ans = max(ans, recurse(i + 1, op1 - 1, op2 - 1) + A[i] / 2 + K);
            } else {
                ans = max(ans, recurse(i + 1, op1 - 1, op2 - 1) + K + (A[i] - K) / 2);
            }
        }
        return dp[i][op1][op2] = ans;
    }
public:
    int minArraySum(vector<int>& nums, int k, int op1, int op2) {
        N = nums.size();
        A = vector<int>(nums.begin(), nums.end());
        K = k;
        dp.assign(N, vector<vector<int>>(op1 + 1, vector<int>(op2 + 1, -1)));
        int ans = accumulate(nums.begin(), nums.end(), 0) - recurse(0, op1, op2);
        return ans;
    }
};
```

## 3367. Maximize Sum of Weights after Edge Removals

### Solution 1:  dynamic programming on tree, tree, sorting, greedy, postorder tree traversal

1. The key is to quantify the gain of taking an edge (u, v) over an edge that was connected to v. 
1. And then pick the edges with the best gain of upgrading the edge to get yourself to at most k edges attached to node u. 
1. It surprisingly localizes the problem to just a node and it's children. 

```cpp
#define int64 long long
class Solution {
private:
    int N, K;
    vector<vector<pair<int, int>>> adj;
    vector<int64> dp[2]; // 0 represents at most k - 1 edges from node u, 1 represents at most k edges from node u
    void dfs(int u, int p = -1) {
        vector<int> upgradeDeltas;
        int64 base = 0;
        for (const auto& [v, w] : adj[u]) {
            if (v == p) continue;
            dfs(v, u);
            base += dp[1][v];
            int64 removeEdgeDelta = dp[1][v] - dp[0][v];
            upgradeDeltas.emplace_back(w - removeEdgeDelta);
        }
        dp[0][u] += base;
        dp[1][u] += base;
        sort(upgradeDeltas.rbegin(), upgradeDeltas.rend());
        for (int i = 0; i < min(K, (int)upgradeDeltas.size()); i++) {
            if (upgradeDeltas[i] <= 0) break;
            if (i < K - 1) dp[0][u] += upgradeDeltas[i];
            dp[1][u] += upgradeDeltas[i];
        }
    }
public:
    int64 maximizeSumOfWeights(vector<vector<int>>& edges, int k) {
        N = edges.size() + 1;
        K = k;
        adj.assign(N, vector<pair<int, int>>());
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            adj[u].emplace_back(v, w);
            adj[v].emplace_back(u, w);
        }
        for (int i = 0; i < 2; i++) {
            dp[i].assign(N, 0);
        }
        dfs(0);
        return dp[1][0];
    }
};
```

# Leetcode Weekly Contest 426

## Identify the Largest Outlier in an Array

### Solution 1:  set, summation, frequency

```cpp
class Solution {
public:
    int getLargestOutlier(vector<int>& nums) {
        int ans = -1e4;
        int N = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        unordered_map<int, int> freq;
        for (int x : nums) {
            freq[x]++;
        }
        for (int i = 0; i < N; i++) {
            sum -= nums[i];
            freq[nums[i]]--;
            if (sum % 2 == 0 && freq[sum / 2] > 0) {
                ans = max(ans, nums[i]);
            }
            sum += nums[i];
            freq[nums[i]]++;
        }
        return ans;
    }
};
```

## Maximize the Number of Target Nodes After Connecting Trees I

### Solution 1:  tree, dfs, tree depth

```cpp
class Solution {
private:
    vector<vector<int>> adj1, adj2;
    void build(vector<vector<int>> &adj, const vector<vector<int>> & edges) {
        int n = edges.size() + 1;
        adj.assign(n, vector<int>());
        for (const auto &edge: edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
    }
    int expand(const vector<vector<int>> &adj, int u, int k, int p = -1) {
        if (k < 0) return 0;
        int ans = 1;
        for (int v : adj[u]) {
            if (v == p) continue;
            ans += expand(adj, v, k - 1, u);
        }
        return ans;
    }
public:
    vector<int> maxTargetNodes(vector<vector<int>>& edges1, vector<vector<int>>& edges2, int k) {
        int N = edges1.size() + 1, M = edges2.size() + 1;
        build(adj1, edges1);
        build(adj2, edges2);
        int val = 0;
        for (int i = 0; i < M; i++) {
            val = max(val, expand(adj2, i, k - 1));
        }
        vector<int> ans(N, val);
        for (int i = 0; i < N; i++) {
            ans[i] += expand(adj1, i, k);
        }
        return ans;
    }
};
```

## Maximize the Number of Target Nodes After Connecting Trees II

### Solution 1:  dp on tree, dfs, reroot tree dp, parity count

```cpp
class Solution {
private:
    vector<vector<int>> adj1, adj2;
    vector<int> even, odd, ans;
    void build(vector<vector<int>> &adj, const vector<vector<int>> & edges) {
        int n = edges.size() + 1;
        adj.assign(n, vector<int>());
        for (const auto &edge: edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
    }
    void dfs1(const vector<vector<int>> &adj, int u, int p = -1) {
        even[u] = 1;
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs1(adj, v, u);
            even[u] += odd[v];
            odd[u] += even[v];
        }
    }
    void dfs2(const vector<vector<int>> &adj, int u, int p = -1, int peven = 0, int podd = 0) {
        ans[u] += even[u] + peven;
        for (int v : adj[u]) {
            if (v == p) continue;
            int oddDelta = odd[u] - even[v];
            int evenDelta = even[u] - odd[v];
            dfs2(adj, v, u, podd + oddDelta, peven + evenDelta);
        }
    }
public:
    vector<int> maxTargetNodes(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {
        int N = edges1.size() + 1, M = edges2.size() + 1;
        build(adj1, edges1);
        build(adj2, edges2);
        even.assign(M, 0);
        odd.assign(M, 0);
        ans.assign(M, 0);
        dfs1(adj2, 0);
        dfs2(adj2, 0);
        int val = *max_element(ans.begin(), ans.end());
        even.assign(N, 0);
        odd.assign(N, 0);
        ans.assign(N, val);
        dfs1(adj1, 0);
        dfs2(adj1, 0);
        return ans;
    }
};
```

### Solution 2:  two coloring algorithm, bipartite graph

1. The solution above with tree dp does work, but it is not necessary, there is a simpler solution.
1. You only need to know if you are red or blue colored node.  Cause all blue colored nodes will be even distance from each other and same for red.

```cpp
class Solution {
private:
    vector<int> nodeColor;
    int color[2];
    void build(vector<vector<int>> &adj, const vector<vector<int>> & edges) {
        int n = edges.size() + 1;
        adj.assign(n, vector<int>());
        for (const auto &edge: edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
    }
    void dfs(const vector<vector<int>> &adj, int u, int p = -1, int col = 0) {
        color[col]++;
        nodeColor[u] = col;
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs(adj, v, u, col ^ 1);
        }
    }
public:
    vector<int> maxTargetNodes(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {
        int N = edges1.size() + 1, M = edges2.size() + 1;
        vector<vector<int>> adj1, adj2;
        build(adj1, edges1);
        build(adj2, edges2);
        nodeColor.assign(M, 0);
        dfs(adj2, 0);
        int val = *max_element(color, color + 2);
        memset(color, 0, sizeof(color));
        nodeColor.assign(N, 0);
        dfs(adj1, 0);
        vector<int> ans(N, val);
        for (int i = 0; i < N; i++) {
            ans[i] += color[nodeColor[i]];
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 427

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 428

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 429

## 3397. Maximum Number of Distinct Elements After Operations

### Solution 1:  sorting, greedy

```cpp

const int INF = 1e9 + 5;
class Solution {
public:
    int maxDistinctElements(vector<int>& nums, int k) {
        int N = nums.size();
        sort(nums.begin(), nums.end());
        int prv = -INF, ans = 0;
        for (int num : nums) {
            int take = max(-k, prv + 1 - num);
            if (take <= k) {
                ans++;
                prv = num + take;
            }
        }
        return ans;
    }
};
```

## 3399. Smallest Substring With Identical Characters II

### Solution 1:  dynamic programming, modulo pattern, greedy, binary search

```cpp
const int INF = 1e9 + 5;
class Solution {
private:
    int N;
    string S;
    int floor(int x, int y) {
        return x / y;
    }
    int calculate(int target) {
        if (target == 1) {
            vector<vector<int>> dp(N + 1, vector<int>(2, 0));
            for (int i = 0; i < N; i++) {
                int v = S[i] - '0';
                dp[i + 1][v] = dp[i][v ^ 1];
                dp[i + 1][v ^ 1] = dp[i][v] + 1;
            }
            int ans = min(dp[N][0], dp[N][1]);
            return ans;
        }
        int ans = 0;
        int cur = 1;
        char prv = S[0];
        for (int i = 1; i < N; i++) {
            if (S[i] != prv) {
                ans += floor(cur, target + 1);
                prv = S[i];
                cur = 0;
            }
            cur++;
        }
        if (cur > 0) ans += floor(cur, target + 1);
        return ans;
    }
public:
    int minLength(string s, int numOps) {
        N = s.size();
        S = s;
        int lo = 1, hi = N;
        while (lo < hi) {
            int mi = lo + (hi - lo) / 2;
            if (calculate(mi) > numOps) lo = mi + 1;
            else hi = mi;
        }
        return lo;
    }
};
```

# Leetcode Weekly Contest 430

## 3403. Find the Lexicographically Largest String From the Box I

### Solution 1:  string, comparison, max

1. The largest lexicographical string will always be one of the longest strings you can make.  It is only limited by the number of friends.  The best case is to give all your friends a string of length 1 and give one of them the longest string you can make.  So split into string of length N - numFriends + 1, and the other strings into length of 1. 

```cpp
class Solution {
public:
    string answerString(string word, int numFriends) {
        if (numFriends == 1) return word;
        int N = word.size(), M = N - numFriends + 1;
        string ans = "";
        for (int i = 0; i < N; i++) {
            ans = max(ans, word.substr(i, M));
        }
        return ans;
    }
};
```

## 3404. Count Special Subsequences

### Solution 1:  gcd, reduced form of fractions, hash table, frequency

Using GCD to store ratios.  If you try to store a ratio using floating-point diivision, you can lose precision.  Two mathematically equal ratios might end up slightly different in floating-point form.  

Store each ratio in reduced fraction form as a pair of integers. 

g = gcd(x, y) and reduced ratio is (x / g, q / g)

two ratios such as a/b = c/d only if both the reduced forms match.  

REDUCED FRACTION FORM

Take the reduced form for the numerator and denominator represented in a pair<int, int> and store it in a map that tracks the count of that value. 

```cpp
#define int64 long long
class Solution {
public:
    int64 numberOfSubsequences(vector<int>& nums) {
        int N = nums.size();
        int64 ans = 0;
        map<pair<int, int>, int> freq;
        for (int r = 4; r < N; r++) {
            int q = r - 2;
            for (int p = q - 2; p >= 0; p--) {
                int g = gcd(nums[p], nums[q]);
                pair<int, int> reducedForm = {nums[p] / g, nums[q] / g};
                freq[reducedForm]++;
            }
            for (int s = r + 2; s < N; s++) {
                int g = gcd(nums[r], nums[s]);
                pair<int, int> reducedForm = {nums[s] / g, nums[r] / g};
                ans += freq[reducedForm];
            }
        }
        return ans;
    }
};
```

## 3405. Count the Number of Arrays with K Matching Adjacent Elements

### Solution 1:  combinatorics, counting, modular inverse, binomial coefficients

1. If you think about the problem in terms of counting you can derive an equation ans = m * (m - 1)^(n - k - 1) * $\binom{n - 1}{k}$
1. cause you have m options for your first, then you will have n - k - 1 splits remaining and m - 1 options for those. 
1. Then you have the binomial to count number of ways you can split the k. 

```cpp
#define int64 long long
class Solution {
private:
    const int64 MOD = 1e9 + 7;
    int64 inv(int64 i, int64 m) {
      return i <= 1 ? i : m - (m/i) * inv(m % i, m) % m;
    }
public:
    int countGoodArrays(int n, int m, int k) {
        int64 ans = m;
        for (int i = 0; i < n - k - 1; i++) {
            ans = ans * (m - 1) % MOD;
        }
        for (int i = 1; i < n; i++) {
            ans = ans * i % MOD;
        }
        for (int i = 1; i <= k; i++) {
            ans = ans * inv(i, MOD) % MOD;
        }
        for (int i = 1; i < n - k; i++) {
            ans = ans * inv(i, MOD) % MOD;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 431

## 3412. Find Mirror Score of a String

### Solution 1:  stack, string

```cpp
#define int64 long long
class Solution {
private:
    int decode(char ch) {
        return ch - 'a';
    }
public:
    int64 calculateScore(string s) {
        int N = s.size();
        int64 ans = 0;
        vector<vector<int>> charIndex(26, vector<int>());
        for (int i = 0; i < N; i++) {
            int v = decode(s[i]);
            int u = 25 - v;
            if (!charIndex[u].empty()) {
                int j = charIndex[u].back();
                ans += i - j;
                charIndex[u].pop_back();
            } else {
                charIndex[v].emplace_back(i);
            }
        }
        return ans;
    }
};
```

## 3413. Maximum Coins From K Consecutive Bags

### Solution 1:  sliding window, queue, intervals

1. Fill in the gaps
1. Use two scenarios for the inclusion of each interval into the sliding window

```cpp
#define int64 long long
class Solution {
private:
    int64 length(int l, int r) {
        return r - l + 1;
    }
public:
    int64 maximumCoins(vector<vector<int>>& coins, int k) {
        int N = coins.size();
        sort(coins.begin(), coins.end());
        for (int i = 1; i < N; i++) {
            if (length(coins[i - 1][1], coins[i][0]) > 2) {
                coins.push_back({coins[i - 1][1] + 1, coins[i][0] - 1, 0});
            }
        }
        N = coins.size();
        sort(coins.begin(), coins.end());
        int64 sum = 0, ans = 0, curSize = 0;
        queue<int> q;
        for (int i = 0; i < N; i++) {
            int l = coins[i][0], r = coins[i][1], c = coins[i][2];
            int64 len = length(l, r);
            int64 take = min(len, (int64)k - curSize);
            sum += take * c;
            curSize += take;
            ans = max(ans, sum);
            curSize -= take;
            sum -= take * c;
            curSize += len;
            sum += len * c;
            q.emplace(i);
            while (curSize > k) {
                int idx = q.front();
                int l1 = coins[idx][0], r1 = coins[idx][1], c1 = coins[idx][2];
                int64 len2 = length(l1, r1);
                int64 rem2 = min(len2, (int64)curSize - k);
                sum -= rem2 * c1;
                coins[idx][0] += rem2;
                if (coins[idx][0] > coins[idx][1]) q.pop();
                curSize -= rem2;
                ans = max(ans, sum - (int64)(curSize - k) * c);
            }
            ans = max(ans, sum);
        }
        return ans;
    }
};
```

## 3414. Maximum Score of Non-overlapping Intervals

### Solution 1:  dynamic programming, map, condition, binary search, increasing values in dp

1. The real trick is that one each update you need to maintain an invariant that the values in dp and index need to be increasing when iterating over it in sorted order of the key values.

```cpp
#define int64 long long
class Solution {
private:
    map<int, int64> dp[5];
    map<int, vector<int>> indices[5];
    bool check(int64 cur, int64 prv, const vector<int> &curArr, const vector<int> &prvArr) {
        return cur > prv || (cur == prv && curArr < prvArr);
    }
public:
    vector<int> maximumWeight(vector<vector<int>>& A) {
        int N = A.size();
        for (int i = 0; i < N; i++) {
            A[i].emplace_back(i);
        }
        sort(A.begin(), A.end());
        for (const auto &event : A) {
            int l = event[0], r = event[1], w = event[2], idx = event[3];
            for (int i = 1; i <= 4; i++) {
                auto itVal = dp[i - 1].lower_bound(l);
                auto itIndex = indices[i - 1].lower_bound(l);
                if (i > 1 && itVal == dp[i - 1].begin()) continue;
                int64 candWeight = i > 1 ? prev(itVal) -> second + w : w;
                vector<int> candIndex = i > 1 ? prev(itIndex) -> second : vector<int>();
                candIndex.emplace_back(idx);
                sort(candIndex.begin(), candIndex.end());
                vector<int> keysToRemove;
                if (check(candWeight, dp[i][r], candIndex, indices[i][r])) {
                    dp[i][r] = candWeight;
                    indices[i][r] = candIndex;
                }
                auto itNextVal = dp[i].find(r);
                auto itNextIndex = indices[i].find(r);
                if (itNextVal != dp[i].begin()) {
                    itNextVal--; itNextIndex--;
                    if (check(itNextVal -> second, dp[i][r], itNextIndex -> second, indices[i][r])) {
                        keysToRemove.emplace_back(r);
                    }
                }
                for (auto it = dp[i].upper_bound(r); it != dp[i].end(); it++) {
                    int k = it -> first;
                    int64 weight = it -> second;
                    if (!check(candWeight, weight, candIndex, indices[i][k])) break;
                    keysToRemove.emplace_back(k);
                }
                for (int k : keysToRemove) {
                    dp[i].erase(k);
                    indices[i].erase(k);
                }
            }
        }
        int64 maxWeight = 0;
        vector<int> ans;
        for (int i = 1; i <= 4; i++) {
            for (const auto &[k, weight] : dp[i]) {
                if (check(weight, maxWeight, indices[i][k], ans)) {
                    maxWeight = dp[i][k];
                    ans = indices[i][k];
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 432

## 3418. Maximum Amount of Money Robot Can Earn

### Solution 1:  dynamic programming, grid, 3D dp

```cpp
const int INF = 1e9;
class Solution {
public:
    int maximumAmount(vector<vector<int>>& coins) {
        int R = coins.size(), C = coins[0].size();
        vector<vector<vector<int>>> dp(R, vector<vector<int>>(C, vector<int>(3, -INF)));
        dp[0][0][0] = coins[0][0];
        dp[0][0][1] = 0;
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                for (int k = 0; k < 3; k++) {
                    if (c > 0) {
                        dp[r][c][k] = max(dp[r][c][k], dp[r][c - 1][k] + coins[r][c]);
                        if (k > 0) dp[r][c][k] = max(dp[r][c][k], dp[r][c - 1][k - 1]);
                    }
                    if (r > 0) {
                        dp[r][c][k] = max(dp[r][c][k], dp[r - 1][c][k] + coins[r][c]);
                        if (k > 0) dp[r][c][k] = max(dp[r][c][k], dp[r - 1][c][k - 1]);
                    }
                }
            }
        }
        return *max_element(dp[R - 1][C - 1].begin(), dp[R - 1][C - 1].end());
    }
};
```

## 3419. Minimize the Maximum Edge Weight of Graph

### Solution 1:  invert graph, binary search, bfs, directed tree from root node 

```cpp
const int INF = 1e9;
class Solution {
private:
    vector<vector<pair<int, int>>> adj;
    int N;
    bool bfs(int target) {
        vector<bool> vis(N, false);
        queue<int> q;
        q.emplace(0);
        vis[0] = true;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (const auto &[v, w] : adj[u]) {
                if (vis[v] || w > target) continue;
                vis[v] = true;
                q.emplace(v);
            }
        }
        return all_of(vis.begin(), vis.end(), [](bool x) { return x; });
    }
public:
    int minMaxWeight(int n, vector<vector<int>>& edges, int threshold) {
        int M = edges.size();
        N = n;
        adj.assign(n, vector<pair<int, int>>());
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            adj[v].emplace_back(u, w); // inverted graph
        }
        int lo = 1, hi = INF;
        while (lo < hi) {
            int mi = lo + (hi - lo) / 2;
            if (bfs(mi)) hi = mi;
            else lo = mi + 1; 
        }
        return lo < INF ? lo : -1;
    }
};
```

## 3420. Count Non-Decreasing Subarrays After K Operations

### Solution 1:  stack, binary search, sparse table, binary jump, prefix sum

1. Parts that I found fascinating was the method to use binary jumping to precompute the 

```cpp
#define int64 long long
const int BITS = 25;
class Solution {
private:
    int N;
    vector<int> stNextGreater[BITS];
    vector<int64> stMinOperations[BITS];
    vector<int64> psum;
    vector<int> nums;
    vector<int> calcNextGreater(const vector<int>& A) {
        vector<int> ans(N, N);
        stack<int> stk;
        for (int i = N - 1; i >= 0; i--) {
            while (!stk.empty() && A[i] >= A[stk.top()]) {
                stk.pop();
            }
            if (!stk.empty()) ans[i] = stk.top();
            stk.push(i);
        }
        return ans;
    }
    int64 rangeSum(int l, int r) {
        if (l > r) return 0;
        int64 ans = psum[r];
        if (l > 0) ans -= psum[l - 1];
        return ans;
    }
    int64 query(int l, int r) {
        int64 res = 0;
        int idx = l;
        for (int i = BITS - 1; i >= 0; i--) {
            int candIdx = stNextGreater[i][idx];
            if (candIdx <= r) {
                res += stMinOperations[i][idx];
                idx = candIdx;
            }
        }
        if (idx <= r) {
            int segmentLen = r - idx + 1;
            res += (int64)nums[idx] * segmentLen;
        }
        res -= rangeSum(l, r);
        return res;
    }
    int64 length(int l, int r) {
        return r - l + 1;
    }
public:
    int64 countNonDecreasingSubarrays(vector<int>& A, int k) {
        nums = A;
        N = nums.size();
        vector<int> nextGreater = calcNextGreater(nums);
        psum.assign(N, 0);
        int64 ans = 0;
        for (int i = 0; i < BITS; i++) {
            stNextGreater[i].assign(N, N);
            stMinOperations[i].assign(N, 0);
        }
        for (int i = 0; i < N; i++) {
            psum[i] = nums[i];
            if (i > 0) psum[i] += psum[i - 1];
            stNextGreater[0][i] = nextGreater[i];
            stMinOperations[0][i] = (int64)nums[i] * (nextGreater[i] - i);
        }
        for (int i = 1; i < BITS; i++) {
            for (int j = 0; j < N; j++) {
                int mid = stNextGreater[i - 1][j];
                if (mid >= N) {
                    stNextGreater[i][j] = mid;
                    stMinOperations[i][j] = stMinOperations[i - 1][j];
                } else {
                    stNextGreater[i][j] = stNextGreater[i - 1][mid];
                    stMinOperations[i][j] = stMinOperations[i - 1][j] + stMinOperations[i - 1][mid];
                }
            }
        }
        for (int i = 0; i < N; i++) {
            int lo = i, hi = N - 1;
            while (lo < hi) {
                int mid = lo + (hi - lo + 1) / 2;
                if (query(i, mid) <= k) lo = mid;
                else hi = mid - 1;
            }
            if (query(i, lo) <= k) ans += length(i, lo);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 433

## 3428. Maximum and Minimum Sums of at Most Size K Subsequences

### Solution 1:  dynamic programming, combinatorics, precomputation, factorials, modular inverse, sorting, subsequences, counting

```cpp
#define int64 long long

const int64 MOD = 1e9 + 7, MAXN = 1e5 + 5;
class Solution {
private: 
    static int64 inv(int64 i, int64 m) {
        return i <= 1 ? i : m - static_cast<int64>(m) / i * inv(m % i, m) % m;
    }
    static vector<int64> fact, inv_fact;
    static vector<vector<int64>> dp;
    static bool precomputed;
    static int64 choose(int n, int r, int m) {
        if (n < r) return 0;
        return (fact[n] * inv_fact[r] % m) * inv_fact[n - r] % m;
    }
    static void precompute(int64 n, int k, int64 m) {
        if (precomputed) return;
        fact.assign(n + 1, 1);
        inv_fact.assign(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % m;
        }
        inv_fact.end()[-1] = inv(fact.end()[-1], m);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % m;
        }
        dp.assign(n, vector<int64>(k, 0));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < k; j++) {
                dp[i][j] = choose(i, j, MOD);
                if (j > 0) dp[i][j] = (dp[i][j] + dp[i][j - 1]) % MOD;
            }
        }
        precomputed = true;
    }

public:
    int minMaxSums(vector<int>& nums, int k) {
        int N = nums.size();
        precompute(MAXN, 70, MOD);
        int64 ans = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < N; ++i) {
            int64 val = nums[i] * dp[i][min(i, k - 1)] % MOD;
            ans = (ans + val) % MOD;
        }
        sort(nums.rbegin(), nums.rend());
        for (int i = 0; i < N; ++i) {
            int64 val = nums[i] * dp[i][min(i, k - 1)] % MOD;
            ans = (ans + val) % MOD;
        }
        return ans;
    }
};

bool Solution::precomputed = false;
vector<vector<int64>> Solution::dp;
vector<int64> Solution::fact, Solution::inv_fact;
```

## 3429. Paint House IV

### Solution 1:  dynamic programming, iterative, minimum cost

1. The hard part is the tricky transition state, because it depends on the house at index i and house at index n - i - 1.  
2. recursive dp is simpler here. 
3. consider painting the first house with color j and the last house with color k, a constraint is that j != k, then if you try all l and r, which are the color of previous houses for first and last house, you need to make sure first house l != j and last house r != k.  Easy method is to enumerate all of the impossible transitions in this case.

```cpp
#define int64 long long
const int64 INF = 1e18;
class Solution {
private:
    vector<int64> dp[3][3]; // prefix house, suffix house color picked, cost up to that one. 
public:
    int64 minCost(int n, vector<vector<int>>& cost) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                dp[i][j].assign(n / 2 + 1, INF);
                dp[i][j][0] = 0;
            }
        }
        for (int i = 0; i < n / 2; i++) {
            int idx = n - i - 1;
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) { // paint house 1 j, paint house 2 k
                    if (j == k) continue;
                    int64 prvMin = INF;
                    for (int l = 0; l < 3; l++) {
                        if (l == j) continue;
                        for (int r = 0; r < 3; r++) {
                            if (r == k) continue;
                            prvMin = min(prvMin, dp[l][r][i]);
                        }
                    }
                    dp[j][k][i + 1] = prvMin + cost[i][j] + cost[idx][k];
                }
            }
        }
        int64 ans = INF;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                ans = min(ans, dp[i][j][n / 2]);
            }
        }
        return ans;
    }
};
```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 434

## 3433. Count Mentions Per User

### Solution 1:  data structures, and implementation

1. do for implementation practice

```cpp

```

## 3434. Maximum Frequency After Subarray Operation

### Solution 1:  dynamic programming, kadane's algorithm

1. Try kadane's algorithm for each of the 50 values, cause you want to find like a sliding window with the maximum sum of the sliding window.  And you can do this for each of the 50 values.
2. Whenever you see a k it decrements, because if you are setting v to k, that k will no longer equal. So you are losing one, goal is to gain, so negatives should be set to 0, you should begin the sliding window again.

```cpp
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k) {
        int ans = 0;
        int freqK = accumulate(nums.begin(), nums.end(), 0, [&k](int accum, int x) {
            return accum + (x == k);
        });
        for (int v = 1; v < 51; v++) {
            int cur = 0, mx = 0;
            for (int num : nums) {
                if (num == k) cur--;
                else if (num == v) cur++;
                cur = max(0, cur);
                mx = max(mx, cur);
            }
            ans = max(ans, mx);
        }
        return ans + freqK;
    }
};
```

## 3435. Frequencies of Shortest Supersequences

### Solution 1:  directed graph, topological sort, bitmask, bfs

1. Observe that you will have between 1 or 2 of each of the at most 16 characters appearing in the words array.
2. And also that if you have a remove the edges going to nodes that you have appear 2 times, then you should have a DAG, if so it is a valid topological sort.

```cpp
class Solution {
private:
    vector<vector<int>> adj;
    bool vis[26];
    int indegrees[26], indeg[26];
    vector<int> freq;
    int decode(const char ch) {
        return ch - 'a';
    }
    bool isSet(int mask, int i) {
        return (mask >> i) & 1;
    }
    bool bfs(int threshold, deque<int>& dq) {
        int cnt = 0;
        while (!dq.empty()) {
            int u = dq.front();
            dq.pop_front();
            cnt++;
            for (int v : adj[u]) {
                indeg[v]--;
                if (indeg[v] == 0) {
                    dq.emplace_back(v);
                }
            }
        }
        return cnt == threshold;
    }
public:
    vector<vector<int>> supersequences(vector<string>& words) {
        vector<vector<int>> ans;
        string alphabet = "";
        adj.assign(26, vector<int>());
        memset(indegrees, 0, sizeof(indegrees));
        for (const string& word : words) {
            alphabet += word[0];
            alphabet += word[1];
            adj[decode(word[0])].emplace_back(decode(word[1]));
            indegrees[decode(word[1])]++;
        }
        sort(alphabet.begin(), alphabet.end());
        alphabet.erase(unique(alphabet.begin(), alphabet.end()), alphabet.end());
        int N = alphabet.size(), sz = 100;
        for (int mask = 0; mask < (1 << N); mask++) {
            freq.assign(26, 0);
            memset(indeg, 0, sizeof(indeg));
            memset(vis, false, sizeof(vis));
            int cur = N;
            deque<int> dq;
            for (int i = 0; i < N; i++) {
                int idx = decode(alphabet[i]);
                freq[idx]++;
                indeg[idx] = indegrees[idx];
                if (isSet(mask, i)) {
                    cur++;
                    freq[idx]++;
                    indeg[idx] = 0;
                }
                if (indeg[idx] == 0) dq.emplace_back(idx);
            }
            if (!bfs(N, dq)) continue;
            if (cur < sz) {
                ans.clear();
                sz = cur;
            }
            if (cur == sz) {
                ans.emplace_back(freq);
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 435

## 3443. Maximum Manhattan Distance After K Changes

### Solution 1:  manhattan distance, greedy

```cpp
class Solution {
public:
    int maxDistance(string s, int k) {
        int cntN = 0, cntS = 0, cntW = 0, cntE = 0, N = s.size();
        int ans = 0;
        for (char ch : s) {
            if (ch == 'N') {
                ++cntN;
            } else if (ch == 'S') {
                ++cntS;
            } else if (ch == 'W') {
                ++cntW;
            } else {
                ++cntE;
            }
            int cand = abs(cntN - cntS) + abs(cntE - cntW) + 2 * min(k, min(cntN, cntS) + min(cntE, cntW));
            ans = max(ans, cand);
        }
        return ans;
    }
};
```

## 3444. Minimum Increments for Target Multiples in an Array

### Solution 1:  bitmask dp, lcm, math

```cpp
using int64 = long long;
const int INF = 1e9;
class Solution {
private:
    bool isSet(int mask, int i) {
        return (mask >> i) & 1;
    }
    int64 ceil(int64 x, int64 y) {
        return (x + y - 1) / y;
    }
public:
    int minimumIncrements(vector<int>& nums, vector<int>& target) {
        int N = nums.size(), M = target.size();
        int endMask = (1 << M) - 1;
        vector<int64> dp(1 << M, INF), ndp(1 << M, INF);
        dp[0] = 0;
        for (int x : nums) {
            ndp.assign(1 << M, INF);
            for (int mask = 0; mask <= endMask; mask++) {
                if (dp[mask] == INF) continue;
                for (int nmask = 0; nmask <= endMask; nmask++) {
                    if ((nmask & mask) != mask) continue;
                    if (nmask == mask) {
                        ndp[nmask] = min(ndp[nmask], dp[mask]);
                        continue;
                    }
                    int64 l = 0;
                    for (int i = 0; i < M; i++) {
                        if (isSet(mask, i) || !isSet(nmask, i)) continue;
                        l = l ? lcm(l, static_cast<int64>(target[i])) : target[i];
                    }
                    int64 cost = static_cast<int64>(ceil(x, l)) * l - x;
                    ndp[nmask] = min(ndp[nmask], dp[mask] + cost);
                }
            }
            swap(dp, ndp);
        }
        return dp[endMask];
    }
};
```

## 3445. Maximum Difference Between Even and Odd Frequency II

### Solution 1:  prefix sums, parity, sliding window

```cpp
const int INF = 1e9;
class Solution {
public:
    int maxDifference(string s, int k) {
        int N = s.size();
        string digits = "01234";
        int ans = -INF;
        for (char a : digits) {
            for (char b : digits) {
                if (a == b) continue;
                vector<int> psum(N + 1, 0);
                vector<int> pa(N + 1, 0);
                vector<int> pb(N + 1, 0);
                for (int i = 0; i < N; ++i) {
                    psum[i + 1] = s[i] == a ? 1 : s[i] == b ? -1 : 0;
                    pa[i + 1] = s[i] == a;
                    pb[i + 1] = s[i] == b;
                    psum[i + 1] += psum[i];
                    pa[i + 1] += pa[i];
                    pb[i + 1] += pb[i];
                }
                vector<vector<int>> dp(2, vector<int>(2, INF));
                for (int i = 0, j = 0; i <= N; ++i) {
                    while (i - j >= k && pa[i] - pa[j] > 0 && pb[i] - pb[j] > 0) {
                        dp[pa[j] % 2][pb[j] % 2] = min(dp[pa[j] % 2][pb[j] % 2], psum[j]);
                        ++j;
                    }
                    int cand = psum[i] - dp[(pa[i] % 2) ^ 1][pb[i] % 2];
                    ans = max(ans, cand);
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 436

## 3447. Assign Elements to Groups with Constraints

### Solution 1: sieve inspired algorithm, harmonic sum pattern, map

1. If you use sieve you can find all the possible numbers that can be divisible by an element[i].

```cpp
class Solution {
public:
    vector<int> assignElements(vector<int>& groups, vector<int>& elements) {
        int N = groups.size(), M = elements.size();
        int maxVal = *max_element(groups.begin(), groups.end());
        unordered_map<int, int> sieve;
        for (int i = 0; i < M; i++) {
            if (sieve.count(elements[i])) continue;
            for (int v = elements[i]; v <= maxVal; v += elements[i]) {
                if (!sieve.count(v)) sieve[v] = i;
            }
        }
        vector<int> ans(N, -1);
        for (int i = 0; i < N; i++) {
            if (sieve.count(groups[i])) ans[i] = sieve[groups[i]];
        }
        return ans;
    }
};
```

## 3448. Count Substrings Divisible By Last Digit

### Solution 1: dynamic programming, digit dp, modular arithmetic, remainder, counting

1. Requires to know that you can count the number of numbers divisible by a dig just by taking (rem * 10 + dig) % mod, so that is you can calculate the remainder of a number with many digits like 123456, by taking the remainder under the mod at each part and adding, that way the number never has to exceed mod.  And this reduces the space required for the dp table. 

```cpp
using int64 = long long;
class Solution {
private:
    int decode(char ch) {
        return ch - '0';
    }
public:
    int64 countSubstrings(string s) {
        int N = s.size();
        vector<vector<vector<int64>>> dp(N + 1, vector<vector<int64>>(10, vector<int64>(10, 0)));
        int64 ans = 0;
        for (int i = 0; i < N; i++) {
            int dig = decode(s[i]);
            for (int mod = 1; mod < 10; mod++) {
                for (int rem = 0; rem < mod; rem++) {
                    int nrem = (rem * 10 + dig) % mod;
                    dp[i + 1][mod][nrem] += dp[i][mod][rem];
                }
                dp[i + 1][mod][dig % mod]++;
            }
            ans += dp[i + 1][dig][0];
        }
        return ans;
    }
};
```

## 3449. Maximize the Minimum Game Score

### Solution 1: greedy, binary search, 

1. think of the greedy aspect, as you move through, it needs to oscillate between two elements in array until it reaches the required score.  And always do in a way to give some to the next one,  and there is a pattern of how many moves were used for the next.

```cpp
using int64 = long long;
const int64 MAXN = 1e18;
class Solution {
private:
    int N, M;
    vector<int> A;
    int64 ceil(int64 x, int64 y) {
        return (x + y - 1) / y;
    }
    bool possible(int64 target) {
        int64 moves = 0, prior = 0;
        for (int i = 0, last = -1; i < N && moves <= M; i++) {
            int64 rem = max(0LL, target - prior * A[i]);
            int64 take = ceil(rem, A[i]);
            if (take > 0) {
                moves += i - last - 1;
                last = i;
            }
            moves += max(0LL, 2LL * take - 1);
            prior = max(0LL, take - 1);
        }
        return moves <= M;
    }
public:
    int64 maxScore(vector<int>& points, int m) {
        N = points.size();
        M = m;
        A = points;
        int64 lo = 0, hi = MAXN;
        while (lo < hi) {
            int64 mi = lo + (hi - lo + 1) / 2;
            if (possible(mi)) lo = mi;
            else hi = mi - 1;
        }
        return lo;
    }
};
```

# Leetcode Weekly Contest 437

## 3457. Eat Pizzas!

### Solution 1: greedy, sorting

```cpp
using int64 = long long;

int ceil(int x, int y) {
    return (x + y - 1) / y;
}

class Solution {
public:
    int64 maxWeight(vector<int>& pizzas) {
        int N = pizzas.size();
        int64 ans = 0;
        sort(pizzas.begin(), pizzas.end());
        for (int i = 0; i < ceil(N / 4, 2); i++) {
            int64 x = pizzas.back();
            pizzas.pop_back();
            ans += x;
        }
        for (int i = 0; i < N / 8; i++) {
            pizzas.pop_back();
            int64 x = pizzas.back();
            pizzas.pop_back();
            ans += x;
        }
        return ans;
    }
};
```

## 3458. Select K Disjoint Special Substrings

### Solution 1:  dynamic programming, interval dp, intervals

```cpp
class Solution {
private:
    int decode(char ch) {
        return ch - 'a';
    }
public:
    bool maxSubstringLength(string s, int k) {
        if (!k) return true;
        int N = s.size();
        vector<int> left(26, -1), right(26, -1);
        for (int i = 0; i < N; i++) {
            int v = decode(s[i]);
            right[v] = i + 1;
        }
        for (int i = N - 1; i >= 0; i--) {
            int v = decode(s[i]);
            left[v] = i + 1;
        }
        vector<pair<int, int>> events;
        for (int i = 0; i < 26; i++) {
            if (left[i] == -1) continue;
            bool isGood = true;
            for (int j = left[i]; j < right[i]; j++) {
                int v = decode(s[j]);
                if (left[v] < left[i]) {
                    isGood = false;
                    break;
                }
                right[i] = max(right[i], right[v]);
            }
            if (!isGood) continue;
            if (right[i] - left[i] + 1 == N) continue;
            events.emplace_back(left[i], right[i]);
        }
        sort(events.begin(), events.end());
        vector<int> dp(N + 1, 0);
        for (int i = 0, j = 1; i < events.size(); i++) {
            auto [l, r] = events[i];
            while (j < l) {
                dp[j] = max(dp[j], dp[j - 1]);
                j++;
            }
            dp[r] = max(dp[r], dp[l - 1] + 1);
            if (dp[r] >= k) return true;
        }
        return false;
    }
};
```

## 3459. Length of Longest V-Shaped Diagonal Segment

### Solution 1: dynamic programming, memoization, dfs

```cpp
class Solution {
private:
    int R, C;
    int dirs[4][2] = {{1, 1}, {1, -1}, {-1, -1}, {-1, 1}};
    vector<vector<vector<vector<int>>>> dp;
    vector<vector<int>> grid;
    bool inBounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    int dfs(int r, int c, int d, int t, int target) {
        int nr = r + dirs[d][0], nc = c + dirs[d][1];
        if (!inBounds(nr, nc) || grid[nr][nc] != target) return 0;
        if (dp[r][c][d][t] != -1) return dp[r][c][d][t];
        int ans = dfs(nr, nc, d, t, 2 - target) + 1;
        if (!t) ans = max(ans, dfs(nr, nc, (d + 1) % 4, t ^ 1, 2 - target) + 1);
        return dp[r][c][d][t] = ans;
    }
public:
    int lenOfVDiagonal(vector<vector<int>>& A) {
        grid = A;
        R = grid.size(), C = grid[0].size();
        dp.assign(R, vector<vector<vector<int>>>(C, vector<vector<int>>(4, vector<int>(2, -1))));
        int ans = 0;
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                if (grid[r][c] != 1) continue;
                for (int d = 0; d < 4; ++d) {
                    ans = max(ans, dfs(r, c, d, 0, 2) + 1);
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 438

## 3462. Maximum Sum With at Most K Elements

### Solution 1: sorting, greedy

```cpp
using int64 = long long;
class Solution {
public:
    int64 maxSum(vector<vector<int>>& grid, vector<int>& limits, int k) {
        int R = grid.size(), C = grid[0].size();
        vector<pair<int, int>> arr;
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                arr.emplace_back(grid[i][j], i);
            }
        }
        sort(arr.rbegin(), arr.rend());
        int64 ans = 0;
        for (int i = 0; i < R * C && k > 0; i++) {
            auto [val, r] = arr[i];
            if (!limits[r]) continue;
            limits[r]--;
            k--;
            ans += val;
        }
        return ans;
    }
};
```

## 3463. Check If Digits Are Equal in String After Operations II

### Solution 1: Lucas theorem, chinese remainder theorem, number theory, modular arithmetic, combinatorics

Need to upsolve looks interesting

```cpp

```

## 3464. Maximize the Distance Between Points on a Square

### Solution 1: greedy binary search, sorting, circular distance, counterclockwise

1. move counterclockwise around the square, and you can convert the manhattan distance between each point into an array.
1. Just need to make sure to handle the circularDistance, that is the distance from the current point to the starting point of the chosen. 

```cpp
using int64 = long long;
class Solution {
private:
    int N, K, S;
    vector<int64> arr;
    bool possible(int target) {
        for (int i = 0; i < N; i++) {
            int cnt = 0, curIdx = i;
            while (cnt < K) {
                cnt++;
                curIdx = lower_bound(arr.begin(), arr.end(), arr[curIdx] + target) - arr.begin();
                if (curIdx == N) break;
                int64 circularDistance = 4LL * S - arr[curIdx] + arr[i];
                if (circularDistance < target) break;
            }
            if (cnt == K) return true;
        }
        return false;
    }
public:
    int maxDistance(int side, vector<vector<int>>& points, int k) {
        K = k;
        N = points.size();
        S = side;
        for (const auto &vec : points) {
            int x = vec[0], y = vec[1];
            if (y == 0) {
                arr.emplace_back(x + y);
            } else if (x == side) {
                arr.emplace_back(x + y);
            } else if (y == side) {
                arr.emplace_back(2LL * side + (side - x));
            } else {
                arr.emplace_back(3LL * side + (side - y));
            }
        }
        sort(arr.begin(), arr.end());
        int lo = 0, hi = side;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (possible(mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
};
```

# Leetcode Weekly Contest 439

## 3472. Longest Palindromic Subsequence After at Most K Operations

### Solution 1: dynamic programming, 3d dp, palindrome

```py
class Solution:
    def longestPalindromicSubsequence(self, s: str, k: int) -> int:
        N = len(s)
        dp = [[[-1] * (k + 1) for _ in range(N)] for _ in range(N)]
        def dfs(i, j, cost):
            if i < 0 or j >= N: return 0
            if dp[i][j][cost] != -1: return dp[i][j][cost]
            ans = max(dfs(i - 1, j + 1, cost), dfs(i - 1, j, cost), dfs(i, j + 1, cost))
            if i == j:
                ans = max(ans, dfs(i - 1, j + 1, cost) + 1)
                dp[i][j][cost] = ans
                return ans
            delta = min(abs(ord(s[i]) - ord(s[j])), 26 - abs(ord(s[i]) - ord(s[j])))
            if cost + delta <= k:
                ans = max(ans, dfs(i - 1, j + 1, cost + delta) + 2)
            dp[i][j][cost] = ans
            return ans
        ans = 0
        for i in range(N):
            ans = max(ans, dfs(i, i, 0))
        return ans
```

## 3473. Sum of K Subarrays With Length at Least M

### Solution 1: dynamic programming, 2d dp, prefix sum, sliding window

```py
class Solution:
    def maxSum(self, nums: List[int], k: int, m: int) -> int:
        N = len(nums)
        pref = [0] * (N + 1)
        for i in range(N):
            pref[i + 1] = pref[i] + nums[i]
        dp = [[-math.inf] * (k + 1) for _ in range(N + 1)]
        dp[N][0] = 0
        for i in range(k + 1):
            row = [-math.inf] * (N + 2)
            for j in range(N, -1, -1):
                row[j] = max(row[j + 1], pref[j] + dp[j][i - 1])
            for j in range(N - 1, -1, -1):
                dp[j][i] = dp[j + 1][i]
                if j + m <= N:
                    dp[j][i] = max(dp[j][i], row[j + m] - pref[j])
        return dp[0][k]
```

## 3474. Lexicographically Smallest Generated String

### Solution 1: mismatch count, greedy

1. Greedily place correct characters for all the "T"
1. Then replace every other character with "a"
1. Then track mismatch count, and try to fix the ones that start with "F" that have no mismatch, to fix it you can do it greedily, find the first "a" and switch it to a "b", and then increment the mismatch count for the rest of the characters that are not "T".

```py
class Solution:
    def generateString(self, str1: str, str2: str) -> str:
        N = len(str1)
        M = len(str2)
        text = ["$"] * (N + M - 1)
        mismatch_count = [0] * N
        for i in range(N):
            if str1[i] == "T":
                for j in range(M):
                    text[i + j] = str2[j]
        for i in range(N + M - 1):
            if text[i] == "$":
                text[i] = "a"
        for i in range(N):
            for j in range(M):
                if text[i + j] != str2[j]: mismatch_count[i] += 1
        for i in range(N):
            if str1[i] == "T" and mismatch_count[i] != 0:
                return ""
            if str1[i] == "F" and mismatch_count[i] == 0:
                is_match = True
                leftmost_T = i + M
                for j in range(min(i + M - 1, N - 1), i - 1, -1):
                    if str1[j] == "T": leftmost_T = j
                for j in range(leftmost_T - 1, i - 1, -1):
                    if is_match and text[j] == "a":
                        text[j] = "b"
                        is_match = False
                    if j < N and not is_match: mismatch_count[j] += 1
                if is_match: return ""
        ans = "".join(text)
        return ans
```

# Leetcode Weekly Contest 440

## 3478. Choose K Elements With Maximum Sum

### Solution 1: min heap, map, greedy

```cpp
using int64 = long long;
class Solution {
public:
    vector<int64> findMaxSum(vector<int>& nums1, vector<int>& nums2, int k) {
        int N = nums1.size();
        map<int, vector<int>> valueMap;
        for (int i = 0; i < N; i++) {
            valueMap[nums1[i]].emplace_back(i);
        }
        priority_queue<int64, vector<int64>, greater<int64>> minheap;
        int64 curSum = 0;
        vector<int64> ans(N, 0);
        for (const auto &[_, indices] : valueMap) {
            for (int i : indices) {
                ans[i] = curSum;
            }
            for (int i : indices) {
                int64 cand = nums2[i];
                curSum += cand;
                minheap.emplace(cand);
                if (minheap.size() > k) {
                    curSum -= minheap.top();
                    minheap.pop();
                }
            }
        }
        return ans;
    }
};
```

## 3479. Fruits Into Baskets III

### Solution 1: max segment tree, binary search, greedy

```cpp
struct SegmentTree {
    int size;
    int neutral = 0;
    vector<int> nodes;

    void init(int num_nodes) {
        size = 1;
        while (size < num_nodes) size *= 2;
        nodes.assign(size * 2, 0);
    }

    int func(int x, int y) {
        return max(x, y);
    }

    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            nodes[segment_idx] = func(nodes[left_segment_idx], nodes[right_segment_idx]);
            segment_idx >>= 1;
        }
    }

    void update(int segment_idx, int val) {
        segment_idx += size;
        nodes[segment_idx] = val;
        segment_idx >>= 1;
        ascend(segment_idx);
    }

    int query(int left, int right) {
        left += size, right += size;
        int res = neutral;
        while (left <= right) {
            if (left & 1) {
                res = func(res, nodes[left]);
                left++;
            }
            if (~right & 1) {
                res = func(res, nodes[right]);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        return res;
    }
};

class Solution {
public:
    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
        int N = fruits.size();
        SegmentTree seg;
        seg.init(N);
        for (int i = 0; i < N; i++) {
            seg.update(i, baskets[i]);
        }
        int ans = 0;
        for (int x : fruits) {
            int lo = 0, hi = N;
            while (lo < hi) {
                int mid = lo + (hi - lo) / 2;
                if (seg.query(0, mid) < x) lo = mid + 1;
                else hi = mid;
            }
            if (lo == N) ans++;
            else seg.update(lo, 0);
        }
        return ans;
    }
};
```

## 3480. Maximize Subarrays After Removing One Conflicting Pair

### Solution 1: max heap, greedy, queries, sort queries by end

1. Maximize what you can save by removing exactly one conflicting pair, best each index i. 

```cpp
using int64 = long long;
class Solution {
public:
    int64 maxSubarrays(int n, vector<vector<int>>& conflictingPairs) {
        int M = conflictingPairs.size();
        for (vector<int>& pair : conflictingPairs) {
            if (pair[0] > pair[1]) swap(pair[0], pair[1]);
        }
        int64 base = 0;
        vector<vector<pair<int, int>>> queries(n + 1, vector<pair<int, int>>());
        for (int i = 0; i < M; i++) {
            int l = conflictingPairs[i][0], r = conflictingPairs[i][1];
            queries[r].emplace_back(l, i);
        }
        vector<int64> save(M, 0);
        priority_queue<pair<int, int>> maxheap;
        for (int i = 1; i <= n; i++) {
            for (auto [l, idx] : queries[i]) {
                maxheap.emplace(l, idx);
            }
            base += i;
            if (!maxheap.empty()) base -= maxheap.top().first;
            if (maxheap.size() == 1) {
                save[maxheap.top().second] += maxheap.top().first;
            } else if (maxheap.size() > 1) {
                auto [x, y] = maxheap.top();
                maxheap.pop();
                save[y] += x - maxheap.top().first;
                maxheap.emplace(x, y);
            }
        }
        return base + *max_element(save.begin(), save.end());
    }
};
```

# Leetcode Weekly Contest 441

## 3488. Closest Equal Element Queries

### Solution 1: map, binary search, modular arithmetic, left and right neighors

```cpp
const int INF = (1 << 30) - 1;
class Solution {
public:
    vector<int> solveQueries(vector<int>& nums, vector<int>& queries) {
        int N = nums.size(), M = queries.size();
        map<int, vector<int>> mp;
        for (int i = 0; i < N; i++) {
            mp[nums[i]].emplace_back(i);
        }
        vector<int> ans(M, INF);
        for (int i = 0; i < M; i++) {
            vector<int> &vec = mp[nums[queries[i]]];
            int len = vec.size();
            int j = lower_bound(vec.begin(), vec.end(), queries[i]) - vec.begin();
            int l = vec[(j - 1 + len) % len], r = vec[(j + 1) % len];
            if (l != queries[i]) {
                int cand = (queries[i] - l + N) % N;
                ans[i] = min(ans[i], cand);
            }
            if (r != queries[i]) {
                int cand = (r - queries[i] + N) % N;
                ans[i] = min(ans[i], cand);
            }
            if (ans[i] == INF) ans[i] = -1;
        }
        return ans;
    }
};
```

## 3489. Zero Array Transformation IV

### Solution 1: dynamic programming with set, process one by one, find how many queries required

```cpp
class Solution {
public:
    int minZeroArray(vector<int>& nums, vector<vector<int>>& queries) {
        int N = nums.size(), M = queries.size();
        int k = 0;
        unordered_set<int> values, nvalues;
        for (int i = 0; i < N; i++) {
            if (!nums[i]) continue;
            values.clear();
            values.insert(0);
            for (int j = 0; j < M; j++) {
                int l = queries[j][0], r = queries[j][1], val = queries[j][2];
                if (l <= i && i <= r) {
                    nvalues.clear();
                    for (int x : values) {
                        nvalues.insert(x + val);
                    }
                    values.insert(nvalues.begin(), nvalues.end());
                }
                if (values.contains(nums[i])) {
                    k = max(k, j + 1);
                    break;
                }
                if (j == M - 1) return -1;
            }
        }
        return k;
    }
};
```

## 3490. Count Beautiful Numbers

### Solution 1: digit dp, 5d dp

```cpp
class Solution {
private:
    int dp[10][82][82][2][2];
    int K;
    int dfs(int i, int rem, int sod, bool tight, bool zero, string& s) {
        if (sod > K) return 0;
        if (i == s.size()) {
            if (sod == K && rem == 0) return 1;
            return 0;
        }
        if (dp[i][rem][sod][tight][zero] != -1) return dp[i][rem][sod][tight][zero];
        int ans = 0;
        int curDig = s[i] - '0';
        for (int d = 0; d < 10; d++) {
            if (tight && d > curDig) break;
            int nrem = zero ? d % K : rem * d % K;
            ans += dfs(i + 1, nrem, sod + d, curDig == d && tight, d == 0 && zero, s);
        }
        return dp[i][rem][sod][tight][zero] = ans;
    }
public:
    int beautifulNumbers(int l, int r) {
        string rstr = to_string(r), lstr = to_string(l - 1);
        int ans = 0;
        for (int i = 1; i < 82; i++) {
            K = i;
            memset(dp, -1, sizeof(dp));
            ans += dfs(0, 0, 0, true, true, rstr);
            memset(dp, -1, sizeof(dp));
            ans -= dfs(0, 0, 0, true, true, lstr);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 442

## 3493. Properties Graph

### Solution 1: undirected graph, dfs, connected components, two pointers, intersection between two arrays, sorting

```cpp
class Solution {
private:
    vector<bool> vis;
    vector<vector<int>> adj;
    int N, M;
    void dfs(int u) {
        if (vis[u]) return;
        vis[u] = true;
        for (int v : adj[u]) {
            dfs(v);
        }
    }
    int match(const vector<int>& A, const vector<int>& B) {
        int res = 0;
        for (int i = 0, j = 0; i < M && j < M;) {
            if (A[i] < B[j]) {
                i++;
            } else if (B[j] < A[i]) {
                j++;
            } else if (A[i] == B[j]) {
                res++;
                int v = A[i];
                while (i < M && A[i] == v) i++;
                while (j < M && B[j] == v) j++;
            }
        }
        return res;
    }
public:
    int numberOfComponents(vector<vector<int>>& properties, int k) {
        N = properties.size();
        M = properties[0].size();
        for (vector<int>& arr : properties) {
            sort(arr.begin(), arr.end());
        }
        adj.assign(N, vector<int>());
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                int cnt = match(properties[i], properties[j]);
                if (cnt >= k) {
                    adj[i].emplace_back(j);
                    adj[j].emplace_back(i);
                }
            }
        }
        int ans = 0;
        vis.assign(N, false);
        for (int i = 0; i < N; i++) {
            if (vis[i]) continue;
            dfs(i);
            ans++;
        }
        return ans;
    }
};
```

## 3494. Find the Minimum Amount of Time to Brew Potions

### Solution 1: math

1. Calculate time to brew each potion.

```cpp
using int64 = long long;
class Solution {
public:
    int64 minTime(vector<int>& skill, vector<int>& mana) {
        int N = skill.size(), M = mana.size();
        vector<int64> ans(N + 1, 0);
        vector<int64> row(N + 1, 0);
        for (int i = 0; i < M; i++) {
            row.assign(N + 1, 0);
            for (int j = 0; j < N; j++) {
                row[j + 1] = skill[j] * mana[i];
            }
            for (int j = 0; j < N; j++) {
                ans[j + 1] = max(ans[j] + row[j + 1], ans[j + 1] + row[j + 1]);
            }
            for (int j = N - 1; j >= 0; j--) {
                ans[j] = max(ans[j], ans[j + 1] - row[j + 1]);
            }
        }
        return ans.back();
    }
};
```

## 3495. Minimum Operations to Make Array Elements Zero

### Solution 1: power of 4, range sums

```cpp
using int64 = long long;
class Solution {
private:
    int64 length(int64 l, int64 r) {
        if (l > r) return 0;
        return r - l + 1;
    }
    int64 ceil(int64 x, int64 y) {
        return (x + y - 1) / y;
    }
public:
    int64 minOperations(vector<vector<int>>& queries) {
        int64 ans = 0;
        for (const vector<int>& q : queries) {
            int64 l = q[0], r = q[1], sum = 0;
            for (int64 i = 1, m = 1; i <= r; i *= 4, m++) {
                int64 curl = max(l, i), curr = min(r, i * 4 - 1);
                sum += m * length(curl, curr);
            }
            ans += ceil(sum, 2);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 443

## 3504. Longest Palindrome After Substring Concatenation II

### Solution 1: dynamic programming, palindrome, 2d dp

```cpp
class Solution {
private:
    int length(int l, int r) {
        return r - l + 1;
    }
public:
    int longestPalindrome(string s, string t) {
        int N = s.size(), M = t.size(), ans = 0;
        vector<vector<bool>> dpS(N, vector<bool>(N, false));
        vector<int> rightS(N, 0);
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i; j < N; j++) {
                if (s[i] == s[j] && (length(i, j) <= 2 || dpS[i + 1][j - 1])) {
                    dpS[i][j] = true;
                    rightS[i] = max(rightS[i], length(i, j));
                    ans = max(ans, rightS[i]);
                }
            }
        }
        vector<vector<bool>> dpT(M, vector<bool>(M, false));
        vector<int> leftT(M, 0);
        for (int i = M - 1; i >= 0; i--) {
            for (int j = i; j < M; j++) {
                if (t[i] == t[j] && (length(i, j) <= 2 || dpT[i + 1][j - 1])) {
                    dpT[i][j] = true;
                    leftT[j] = max(leftT[j], length(i, j));
                    ans = max(ans, leftT[j]);
                }
            }
        }
        vector<vector<int>> dp(N, vector<int>(M, 0));
        for (int i = 0; i < N; i++) {
            for (int j = M - 1; j >= 0; j--) {
                if (s[i] == t[j]) {
                    dp[i][j] = 1;
                    if (i > 0 && j + 1 < M) dp[i][j] += dp[i - 1][j + 1];
                }
                if (dp[i][j]) {
                    int lenPal = 0;
                    if (i + 1 < N) lenPal = max(lenPal, rightS[i + 1]);
                    if (j > 0) lenPal = max(lenPal, leftT[j - 1]);
                    ans = max(ans, 2 * dp[i][j] + lenPal);
                }
            }
        }
        return ans;
    }
};
```

## 3505. Minimum Operations to Make Elements Within K Subarrays Equal

### Solution 1: dynamic programming, rolling median minimum cost, multiset

```cpp
using int64 = long long;
const int64 INF = (1LL << 63) - 1;
struct RMD {
    vector<int64> result;
    multiset<int64> left, right;
    int64 leftSum, rightSum;
    void init(const vector<int>& arr, int k) {
        int N = arr.size();
        leftSum = rightSum = 0;
        result.assign(N + 1, 0);
        for (int i = 0; i < N; i++) {
            add(arr[i]);
            int64 median = *prev(left.end());
            int64 cost = median * left.size() - leftSum + rightSum - median * right.size();
            result[i + 1] = cost;
            if (i >= k - 1) {
                remove(arr[i - k + 1]);
            }
        }
    }
    void balance() {
        while (left.size() > right.size() + 1) {
            auto it = prev(left.end());
            int val = *it;
            leftSum -= val;
            left.erase(it);
            rightSum += val;
            right.insert(val);
        }
        while (left.size() < right.size()) {
            auto it = right.begin();
            int val = *it;
            rightSum -= val;
            right.erase(it);
            leftSum += val;
            left.insert(val);
        }
    }
    void add(int num) {
        if (left.empty() || num <= *prev(left.end())) {
            left.insert(num);
            leftSum += num;
        } else {
            right.insert(num);
            rightSum += num;
        }
        balance();
    }
    void remove(int num) {
        if (left.find(num) != left.end()) {
            auto it = left.find(num);
            int64 val = *it;
            leftSum -= val;
            left.erase(it);
        } else {
            auto it = right.find(num);
            int64 val = *it;
            rightSum -= val;
            right.erase(it);
        }
        balance();
    }
};
class Solution {
public:
    int64 minOperations(vector<int>& nums, int x, int k) {
        int N = nums.size();
        vector<vector<int64>> dp(N + 1, vector<int64>(k + 1, INF));
        for (int i = 0; i <= N; i++) {
            dp[i][0] = 0;
        }
        RMD rmd;
        rmd.init(nums, x);
        for (int j = 1; j <= k; j++) {
            for (int i = j * x; i <= N; i++) {
                if (dp[i - x][j - 1] == INF) continue;
                dp[i][j] = min(dp[i - 1][j], dp[i - x][j - 1] + rmd.result[i]);
            }
        }
        return dp[N][k];
    }
};
```

# Leetcode Weekly Contest 444

## 3508. Implement Router

### Solution 1: set, deque, hash map, ordered timestamps

```cpp
struct Packet {
    int source, destination, timestamp;
    Packet() {}
    Packet(int source, int destination, int timestamp) : source(source), destination(destination), timestamp(timestamp) {}
    bool operator<(const Packet &other) const {
        if (source != other.source) return source < other.source;
        if (destination != other.destination) return destination < other.destination;
        return timestamp < other.timestamp;
    }
};
class Router {
private:
    int memoryLimit;
    set<Packet> pool;
    deque<pair<int, int>> dq;
    unordered_map<int, deque<int>> packets;
public:
    Router(int memoryLimit) {
        this -> memoryLimit = memoryLimit;
    }
    
    bool addPacket(int source, int destination, int timestamp) {
        if (pool.count(Packet(source, destination, timestamp))) return false;
        pool.insert(Packet(source, destination, timestamp));
        packets[destination].emplace_back(timestamp);
        dq.emplace_back(source, destination);
        if (dq.size() > memoryLimit) {
            auto [src, dest] = dq.front();
            dq.pop_front();
            int ts = packets[dest].front();
            packets[dest].pop_front();
            pool.erase(Packet(src, dest, ts));
        }
        return true;
    }
    
    vector<int> forwardPacket() {
        if (!dq.empty()) {
            auto [src, dest] = dq.front();
            dq.pop_front();
            int ts = packets[dest].front();
            packets[dest].pop_front();
            pool.erase(Packet(src, dest, ts));
            return {src, dest, ts};
        }
        return {};
    }
    
    int getCount(int destination, int startTime, int endTime) {
        auto startIt = lower_bound(packets[destination].begin(), packets[destination].end(), startTime);
        auto endIt = upper_bound(packets[destination].begin(), packets[destination].end(), endTime);
        int ans = distance(startIt, endIt);
        return ans;
    }
};
```

## 3509. Maximum Product of Subsequences With an Alternating Sum Equal to K

### Solution 1: dynamic programming with memoization, map for states, recursion, bottom up dp

1. The main trick is really to observe patterns and how things won't explode. 
1. the step where it check is k is greater than sum is very important for it to finish fast enough. 

```cpp
class Solution {
private:
    int N, K, lim;
    vector<int> A;
    map<tuple<int, int, int, int, int>, int> dp;
    int dfs(int idx, int sign, int altSum, int prod, int nonEmpty) {
        if (idx == N) {
            return altSum == K && nonEmpty && prod <= lim ? prod : -1;
        }
        auto key = make_tuple(idx, sign, altSum, prod, nonEmpty);
        if (dp.count(key)) return dp[key];
        int ans = max(
            dfs(idx + 1, sign, altSum, prod, nonEmpty),
            dfs(idx + 1, -1 * sign, altSum + sign * A[idx], min(lim + 1, prod * A[idx]), 1)
        );
        return dp[key] = ans;
    }
public:
    int maxProduct(vector<int>& nums, int k, int limit) {
        N = nums.size(), K = k, lim = limit, A = nums;
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (k > sum || k < -sum) return -1;
        return dfs(0, 1, 0, 1, 0);
    }
};

```

## 3510. Minimum Pair Removal to Sort Array II

### Solution 1: doubly linked list, min heap, set, prev and next pointers

```cpp
using int64 = long long;
class Solution {
private:
    int START, END, N;
    vector<int> nxt, prv;
    void erase(int x) {
        prv[nxt[x]] = prv[x];
        nxt[prv[x]] = nxt[x];
        prv[x] = START;
        nxt[x] = END;
    }
public:
    int minimumPairRemoval(vector<int>& nums) {
        vector<int64> arr(nums.begin(), nums.end());
        N = arr.size();
        arr.emplace(arr.begin(), -1); // pad left side
        START = 0;
        END = N + 1;
        nxt.assign(N + 2, 0);
        prv.assign(N + 2, 0);
        for (int i = 1; i <= N; i++) {
            nxt[i] = i + 1;
            prv[i] = i - 1;
        }
        nxt[0] = 1;
        prv[END] = N;
        priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> minheap;
        set<int> unsorted;
        for (int i = 1; i < N; i++) {
            minheap.emplace(arr[i] + arr[i + 1], i);
            if (arr[i] > arr[i + 1]) unsorted.insert(i);
        }
        int ans = 0;
        while (!unsorted.empty()) {
            ans++;
            int64 cursum;
            int idx;
            while (!minheap.empty()) {
                tie(cursum, idx) = minheap.top();
                minheap.pop();
                if (nxt[idx] == END) continue; // last element in array
                int64 sum = arr[idx] + arr[nxt[idx]];
                if (sum == cursum) break;
            }
            int jdx = nxt[idx];
            arr[idx] = cursum;
            unsorted.erase(idx);
            minheap.emplace(cursum, idx);
            // update elements
            if (prv[idx] != START) {
                unsorted.erase(prv[idx]);
            }
            // removal
            erase(jdx);
            unsorted.erase(jdx);
            // check unsorted
            if (nxt[idx] != END ) {
                minheap.emplace(arr[idx] + arr[nxt[idx]], idx);
                if (arr[idx] > arr[nxt[idx]]) unsorted.insert(idx);
            }
            if (prv[idx] != START) {
                minheap.emplace(arr[prv[idx]] + arr[idx], prv[idx]);
                if (arr[prv[idx]] > arr[idx]) unsorted.insert(prv[idx]);
            }

        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 445

## 

### Solution 1: 

```cpp

```

## 3518. Smallest Palindromic Rearrangement II

### Solution 1: 

```cpp

```

## 3519. Count Numbers with Non-Decreasing Digits 

### Solution 1: long divison, base conversion, digit dp, 4d dp

```cpp
const int MOD = 1e9 + 7;
class Solution {
private:
    int base;
    vector<int> dp[10][2][2];
    int dfs(const vector<int>& arr, int i, int d, int tight, int zero) {
        if (i == arr.size()) return 1;
        if (dp[d][tight][zero][i] != -1) return dp[d][tight][zero][i];
        int ans = 0;
        for (int dig = d; dig < base; ++dig) {
            if (tight && dig > arr[i]) break;
            int term = dfs(arr, i + 1, dig, tight & (arr[i] == dig), zero & (dig == 0));
            ans = (ans + term) % MOD;
        }
        return dp[d][tight][zero][i] = ans;
    }
    vector<int> convertBase(const string &num, int b) {
        vector<int> ans;
        string quotient = num, prevQuotient;
        while (quotient != "0") {
            int rem = 0;
            swap(quotient, prevQuotient);
            quotient = "0";
            for (char ch : prevQuotient) {
                rem = rem * 10 + (ch - '0');
                quotient += (rem / b + '0');
                rem %= b;
            }
            ans.emplace_back(rem);
            int pos = quotient.find_first_not_of('0');
            if (pos == string::npos) break;
            quotient.erase(0, pos);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
public:
    int countNumbers(string l, string r, int b) {
        string lm = l;
        int last = l.size() - 1;
        while (l[last] == '0') {
            lm[last] = '9';
            last--;
        }
        lm[last]--;
        vector<int> lb = convertBase(lm, b), rb = convertBase(r, b);
        base = b;
        fill(&dp[0][0][0], &dp[0][0][0] + 40, vector<int>(rb.size(), -1));
        int ans = dfs(rb, 0, 0, 1, 1);
        fill(&dp[0][0][0], &dp[0][0][0] + 40, vector<int>(rb.size(), -1));
        ans = (ans - dfs(lb, 0, 0, 1, 1) + MOD) % MOD;
        return ans;
    }
};
```

# Leetcode Weekly Contest 446

## 3523. Make Array Non-decreasing

### Solution 1: monotonic stack, reverse iteration, greedy

```cpp
class Solution {
public:
    int maximumPossibleSize(vector<int>& nums) {
        int N = nums.size();
        stack<int> ans;
        for (int i = N - 1; i >= 0; i--) {
            while (!ans.empty() && ans.top() < nums[i]) ans.pop();
            ans.emplace(nums[i]);
        }
        return ans.size();
    }
};
```

## 3524. Find X Value of Array I

### Solution 1: dynamic programming, counting subarrays, product under modulo, O(NK) time complexity

```cpp
using int64 = long long;
class Solution {
public:
    vector<int64> resultArray(vector<int>& nums, int k) {
        int N = nums.size();
        vector<int64> dp(k, 0), ndp(k, 0), ans(k, 0);
        for (int i = 0; i < N; i++) {
            ndp.assign(k, 0);
            int m = nums[i] % k;
            for (int j = 0; j < k; j++) {
                ndp[(j * m) % k] += dp[j];
            }
            ndp[m]++;
            swap(dp, ndp);
            for (int j = 0; j < k; j++) {
                ans[j] += dp[j];
            }
        }
        return ans;
    }
};

```

## 3525. Find X Value of Array II

### Solution 1: segment tree, point updates, range queries, product under modulo, prefix product frequencies

1. draw out what you want to compute on each segment tree node, then it isn't too hard to figure the merge function. 
1. lots of optimization was required to get segment tree to work, the merge condition performing heap allocation was too slow, so everything needs to be done without creating new objects.

```cpp
struct Node {
    vector<int> freq;
    int prod;
    Node(int k) : freq(k, 0), prod(1) {}
    void clear() {
        fill(freq.begin(), freq.end(), 0);
        prod = 1;
    }
};

struct SegmentTree {
    int size;
    int K;
    vector<Node> tree;
    void init(int num_nodes, int k) {
        K = k;
        size = 1;
        while (size < num_nodes) size *= 2;
        tree.assign(2 * size, Node(K));
    }
    void build(const vector<int> &nums) {
        int n = nums.size();
        for (int i = 0; i < size; i++) {
            int p = size + i;
            if (i < n) {
                int r = nums[i] % K;
                tree[p].prod = r;
                tree[p].freq[r] = 1;
            }
        }
        for (int i = size - 1; i >= 1; i--) {
            int l = 2 * i, r = 2 * i + 1;
            merge_(tree[i], tree[l], tree[r]);
        }
    }
    void merge_(Node &res, const Node& left, const Node& right) {
        for (int i = 0; i < K; i++) {
            res.freq[i] = left.freq[i];
        }
        for (int i = 0; i < K; i++) {
            res.freq[(i * left.prod) % K] += right.freq[i];
        }
        res.prod = left.prod * right.prod % K;
    }
    void ascend(int segment_idx) {
        while (segment_idx > 0) {
            int left_segment_idx = 2 * segment_idx, right_segment_idx = 2 * segment_idx + 1;
            merge_(tree[segment_idx], tree[left_segment_idx], tree[right_segment_idx]);
            segment_idx >>= 1;
        }
    }
    void update(int segment_idx, int val) {
        segment_idx += size;
        tree[segment_idx].prod = val % K;
        fill(tree[segment_idx].freq.begin(), tree[segment_idx].freq.end(), 0);
        tree[segment_idx].freq[val % K] = 1;
        segment_idx >>= 1;
        ascend(segment_idx);
    }
    int query(int left, int right, int k) {
        left += size, right += size;
        Node leftRes(K), rightRes(K), result(K);
        while (left <= right) {
            if (left & 1) {
                // res on left
                result.clear();
                merge_(result, leftRes, tree[left]);
                swap(result, leftRes);
                left++;
            }
            if (~right & 1) {
                // res on right
                result.clear();
                merge_(result, tree[right], rightRes);
                swap(result, rightRes);
                right--;
            }
            left >>= 1, right >>= 1;
        }
        result.clear();
        merge_(result, leftRes, rightRes);
        return result.freq[k];
    }
};

class Solution {
public:
    vector<int> resultArray(vector<int>& nums, int k, vector<vector<int>>& queries) {
        int N = nums.size(), M = queries.size();
        SegmentTree seg;
        seg.init(N, k);
        seg.build(nums);
        vector<int> ans(M);
        for (int i = 0; i < M; i++) {
            int idx = queries[i][0], val = queries[i][1], l = queries[i][2], x = queries[i][3];
            seg.update(idx, val);
            ans[i] = seg.query(l, N - 1, x);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 447

## 3531. Count Covered Buildings

### Solution 1:  map, max on each coordinate

1. vertical and horizontal lines with maximum x and y coordinates

```cpp
class Solution {
public:
    int countCoveredBuildings(int n, vector<vector<int>>& buildings) {
        int N = buildings.size();
        unordered_map<int, int> minX, maxX, minY, maxY;
        for (const vector<int> &build : buildings) {
            int x = build[0], y = build[1];
            minX[y] = minX.count(y) ? min(minX[y], x) : x;
            maxX[y] = max(maxX[y], x);
            minY[x] = minY.count(x) ? min(minY[x], y) : y;
            maxY[x] = max(maxY[x], y);
        }
        int ans = 0;
        for (const vector<int> &build : buildings) {
            int x = build[0], y = build[1];
            if (minX[y] < x && x < maxX[y] && minY[x] < y && y < maxY[x]) ans++;
        }
        return ans;
    }
};
```

## 3532. Path Existence Queries in a Graph I

### Solution 1: connected component, linear

```cpp
class Solution {
public:
    vector<bool> pathExistenceQueries(int n, vector<int>& nums, int maxDiff, vector<vector<int>>& queries) {
        vector<int> component(n, 0);
        for (int i = 0, comp = 0; i < n; i++) {
            if (i > 0 && nums[i] - nums[i - 1] > maxDiff) comp++;
            component[i] = comp;
        }
        int M = queries.size();
        vector<bool> ans(M, false);
        for (int i = 0; i < M; i++) {
            int u = queries[i][0], v = queries[i][1];
            ans[i] = component[u] == component[v];
        }
        return ans;
    }
};
```

## 3533. Concatenated Divisibility

### Solution 1:  dp bitmask, bit manipulation

```cpp

```

## 3534. Path Existence Queries in a Graph II

### Solution 1: binary jumping, sparse table, sorting, two pointers

1. Find the farthest you can jump from each position, and then that is your first jump
1. Create a sparse table to find the farthest you can jump from each position if you make 2^k hops
1. You can use the power of two to find any number of hops to just get to target location.

```cpp

```

# Leetcode Weekly Contest 448

## Fill a Special Grid

### Solution 1: recursion, grid, power of two

```cpp
class Solution {
private:
    int val;
    vector<vector<int>> grid;
    void dfs(int n, int r, int c) {
        if (!n) {
            grid[r][c] = val++;
            return;
        }
        dfs(n - 1, r, c + (1 << (n - 1)));
        dfs(n - 1, r + (1 << (n - 1)), c + (1 << (n - 1)));
        dfs(n - 1, r + (1 << (n - 1)), c);
        dfs(n - 1, r, c);
    }
public:
    vector<vector<int>> specialGrid(int n) {
        val = 0;
        grid.assign(1 << n, vector<int>(1 << n , 0));
        dfs(n, 0, 0);
        return grid;
    }
};
```

## 3538. Merge Operations for Minimum Travel Time

### Solution 1: dynamic programming, 4d dp, prefix sums

1.  Really it is tricky to derive all the states and transitions, and just how you update the time and position.  So the key was to use the prevTime, 

```cpp
const int INF = 1e9;
class Solution {
private:
    int N, K;
    vector<int> pos, time, psum;
    vector<vector<vector<vector<int>>>> dp;
    int dfs(int i, int j, int k, int prevTime) {
        if (j > K) return INF;
        if (i == N - 1) {
            return j == K ? 0 : INF;
        }
        if (dp[i][j][k][prevTime] != -1) return dp[i][j][k][prevTime];
        int skip = i > 0 ? dfs(i + 1, j + 1, k + 1, prevTime) + prevTime * (pos[i + 1] - pos[i]) : INF;
        int ntime = psum[i + 1] - psum[i - k];
        int take = dfs(i + 1, j, 0, ntime) + ntime * (pos[i + 1] - pos[i]);
        return dp[i][j][k][prevTime] = min(take, skip);
    }
public:
    int minTravelTime(int l, int n, int k, vector<int>& position, vector<int>& A) {
        N = n; K = k;
        pos = position; time = A;
        psum.assign(N + 1, 0);
        for (int i = 0; i < N; i++) {
            psum[i + 1] = psum[i] + time[i];
        }
        dp.assign(N + 1, vector<vector<vector<int>>>(K + 1, vector<vector<int>>(K + 1, vector<int>(psum[N] + 1, -1))));
        return dfs(0, 0, 0, 0);
    }
};
```

## 3539. Find Sum of Array Product of Magical Sequences

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 449

## 3546. Equal Sum Grid Partition I

### Solution 1: rotate matrix, grid, totals, row sums

```cpp
using int64 = long long;
class Solution {
private:
    int64 total;
    vector<vector<int>> rotate(const vector<vector<int>> &grid) {
        int R = grid.size(), C = grid[0].size();
        vector<vector<int>> ret(C, vector<int>(R));
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                ret[C - c - 1][r] = grid[r][c];
            }
        }
        return ret;
    }
    bool feasible(const vector<vector<int>>& grid) {
        int R = grid.size(), C = grid[0].size();
        int64 cur = 0;
        // cur == total - cur => 2 * cur == total
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                cur += grid[r][c];
            }
            if (2LL * cur == total) return true;
        }
        return false;
    }
public:
    bool canPartitionGrid(vector<vector<int>>& grid) {
        int R = grid.size(), C = grid[0].size();
        total = 0;
        for (int r = 0; r < R; ++r) {
            total += accumulate(grid[r].begin(), grid[r].end(), 0LL);
        }
        vector<vector<int>> rgrid = rotate(grid);
        return feasible(grid) || feasible(rgrid);
    }
};
```

## 3547. Maximum Sum of Edge Values in a Graph

### Solution 1: greedy, undirected graph, cycle, linear tree

```cpp
using int64 = long long;
class Solution {
public:
    int64 maxScore(int N, vector<vector<int>>& edges) {
        int M = edges.size();
        int64 ans = static_cast<int64>(N) * (N - 1);
        for (int64 i = N - 2; i > 0; --i) {
            ans += i * (i + 2);
        }
        if (N == M) ans += 2;
        return ans;
    }
};
```

## 3548. Equal Sum Grid Partition II

### Solution 1: grid, rotate, symmetry

create a cut, gives two sections. 
either the sum is equal between the sections, let's go. or I can discount just one cell from one of the sections, obviously the one that is over counted, so if s1 > s2, and delta = s1 - s2, then I'm looking for cell with value delta in section s1 to discount. 

But there is a constraint, I can only discount a cell if the rest of the section is still connected. 

I think this is fine in any situation, unles there is only one row that makes up that section, then I can't discount unless it is the first or last column. 

Or I have just one column, then I cannot discount unless it is the first or last row. 


solve for this case first say n > 1 and m > 1, then I think it is rather easy, make cuts, and then look for delta.  just handle when it is only one in that section though. keep rotating and only treat top section as where I can discount a cell.  

In first iteration I have to check arefully 

```cpp
using int64 = long long;
class Solution {
private:
    int64 total;
    vector<vector<int>> rotate(const vector<vector<int>> &grid) {
        int R = grid.size(), C = grid[0].size();
        vector<vector<int>> ret(C, vector<int>(R));
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                ret[C - c - 1][r] = grid[r][c];
            }
        }
        return ret;
    }
    bool feasible(const vector<vector<int>>& grid) {
        int R = grid.size(), C = grid[0].size();
        int64 cur = 0;
        set<int64> seen;
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                cur += grid[r][c];
                seen.insert(grid[r][c]);
            }
            int64 delta = 2LL * cur - total;
            if (delta == 0) return true;
            if (grid[r][0] == delta || grid[r][C - 1] == delta || grid[0][0] == delta) return true;
            if (r > 0 && C > 1 && seen.count(delta)) return true;
        }
        return false;
    }
public:
    bool canPartitionGrid(vector<vector<int>>& grid) {
        int R = grid.size(), C = grid[0].size();
        total = 0;
        for (int r = 0; r < R; ++r) {
            for (int c = 0; c < C; ++c) {
                total += grid[r][c];
            }
        }       
        if (feasible(grid)) return true;
        grid = rotate(grid);
        if (feasible(grid)) return true;
        grid = rotate(grid);
        if (feasible(grid)) return true;
        grid = rotate(grid);
        return feasible(grid);
    }
};
```

