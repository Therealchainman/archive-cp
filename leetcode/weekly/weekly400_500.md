# Leetcode Weekly Contest 400 - 500

# Leetcode Weekly Contest 400

## 3171. Find Subarray With Bitwise AND Closest to K

### Solution 1:  bitwise and range queries, static array, sparse table, binary search

```py
class ST_And:
    def __init__(self, nums):
        self.nums = nums
        self.n = len(nums)
        self.LOG = 18 # 10,000
        self.build()

    def op(self, x, y):
        return x & y

    def build(self):
        self.lg = [0] * (self.n + 1)
        for i in range(2, self.n + 1):
            self.lg[i] = self.lg[i // 2] + 1
        self.st = [[0] * self.n for _ in range(self.LOG)]
        for i in range(self.n): 
            self.st[0][i] = self.nums[i]
        # CONSTRUCT SPARSE TABLE
        for i in range(1, self.LOG):
            j = 0
            while (j + (1 << (i - 1))) < self.n:
                self.st[i][j] = self.op(self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))])
                j += 1

    def query(self, l, r):
        length = r - l + 1
        i = self.lg[length]
        return self.op(self.st[i][l], self.st[i][r - (1 << i) + 1])
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = math.inf
        st = ST_And(nums)
        def possible(src, dst):
            v = st.query(src, dst)
            return v >= k
        def bsearch(start):
            lo, hi = start, n - 1
            while lo < hi:
                mid = (lo + hi + 1) >> 1
                if possible(start, mid):
                    lo = mid
                else:
                    hi = mid - 1
            return lo
        for i in range(n):
            j = bsearch(i)
            v = st.query(i, j)
            ans = min(ans, abs(v - k))
            j += 1
            if j < n:
                v = st.query(i, j)
                ans = min(ans, abs(v - k))
        return ans
```

# Leetcode Weekly Contest 401

## 3181. Maximum Total Reward Using Operations II

### Solution 1:  bit manipulation, bitsets, dynamic programming, reachability, sorting

```cpp
class Solution {
public:
    int maxTotalReward(vector<int>& rewards) {
        const int MAXN = 1e5;
        int N = rewards.size();
        sort(rewards.begin(), rewards.end());
        bitset<MAXN> dp, mask;
        dp.set(0);
        int x = 0;
        for (int v : rewards) {
            while (x < v) {
                mask.set(x++);
            }
            dp |= (dp & mask) << v;
        }
        for (int x = MAXN - 1; x >= 0; x--) {
            if (dp.test(x)) return x;
        }
        return 0;
    }
};
```

```py
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        MAXN = int(1e5)
        x = mask = 0
        dp = 1
        for r in sorted(rewardValues):
            while x < r:
                mask |= (1 << x)
                x += 1
            dp |= (dp & mask) << r
        for i in reversed(range(MAXN)):
            if (dp >> i) & 1: return i
```

# Leetcode Weekly Contest 402

## Count Pairs That Form a Complete Day II

### Solution 1:  counter, modulo

```py
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        n = len(hours)
        counts = Counter()
        ans = 0
        for h in map(lambda x: x % 24, hours):
            ans += counts[(24 - h) % 24]
            counts[h] += 1
        return ans
```

## Maximum Total Damage With Spell Casting

### Solution 1:  dp, coordinate compression, frequency array

```py
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        n = len(power)
        freq = Counter(power)
        power = sorted(set(power))
        compressed = set()
        for p in power:
            for i in range(-3, 3):
                compressed.add(p + i)
        compressed = sorted(compressed)
        N = len(compressed)
        dp = [0] * N
        for p in range(3, N):
            dp[p] = max(dp[p - 2], dp[p - 1], dp[p - 3] + compressed[p] * freq[compressed[p]])
        return dp[-1]
```

## 3187. Peaks in Array

### Solution 1: fenwick tree, point updates, range count queries

```py
class FenwickTree:
    def __init__(self, N):
        self.sums = [0 for _ in range(N+1)]

    def update(self, i, delta):
        while i < len(self.sums):
            self.sums[i] += delta
            i += i & (-i)

    def query(self, i):
        res = 0
        while i > 0:
            res += self.sums[i]
            i -= i & (-i)
        return res

    def query_range(self, i, j):
        return self.query(j) - self.query(i - 1) if j >= i else 0

    def __repr__(self):
        return f"array: {self.sums}"
class Solution:
    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n, m = len(nums), len(queries)
        peaks = [0] * n
        for i in range(1, n - 1):
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                peaks[i] = 1
        ans = []
        ft = FenwickTree(n)
        for i in range(n):
            if peaks[i]: ft.update(i + 1, 1)
        for t, l, r in queries:
            if t == 1:
                res = ft.query_range(l + 2, r)
                ans.append(res)
            else:
                nums[l] = r
                # update index peak
                if l > 0 and l + 1 < n:
                    if nums[l] > nums[l - 1] and nums[l] > nums[l + 1]:
                        if not peaks[l]:
                            peaks[l] = 1
                            ft.update(l + 1, 1)
                    else:
                        if peaks[l]:
                            peaks[l] = 0
                            ft.update(l + 1, -1)
                # update index + 1 peak
                if l + 2 < n:
                    if nums[l + 1] > nums[l] and nums[l + 1] > nums[l + 2]:
                        if not peaks[l + 1]:
                            peaks[l + 1] = 1
                            ft.update(l + 2, 1)
                    else:
                        if peaks[l + 1]:
                            peaks[l + 1] = 0
                            ft.update(l + 2, -1)
                # update index - 1 peak
                if l > 1:
                    if nums[l - 1] > nums[l - 2] and nums[l - 1] > nums[l]:
                        if not peaks[l - 1]:
                            peaks[l - 1] = 1
                            ft.update(l, 1)
                    else:
                        if peaks[l - 1]:
                            peaks[l - 1] = 0
                            ft.update(l, -1)
        return ans
```

# Leetcode Weekly Contest 403

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

# Leetcode Weekly Contest 404

## Find the Maximum Length of Valid Subsequence I

### Solution 1:  dynammic programming, binary, base 2

```py
class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        n = len(nums)
        nums = [x % 2 for x in nums]
        dp = [[0] * 2 for _ in range(2)] # (last, rem)
        for i in range(2):
            dp[nums[0]][i] = 1
        for num in nums[1:]:
            ndp = dp[:]
            for rem in range(2): # rem
                ndp[num][rem] = max(ndp[num][rem], dp[rem ^ num][rem] + 1)
            dp = ndp
        return max(max(row) for row in dp)
```

## Find the Maximum Length of Valid Subsequence II

### Solution 1:  dynamic programming

```py
class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)] # dp[n][k]
        ans = 0
        for i in range(1, n):
            for j in range(i):
                val = (nums[i] + nums[j]) % k
                dp[i][val] = max(dp[i][val], dp[j][val] + 1, 2)
                ans = max(ans, dp[i][val])
        return ans
```

## 3203. Find Minimum Diameter After Merging Two Trees

### Solution 1:  tree rerooting dp, dfs, tree diameter

```py
class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        n, m = len(edges1) + 1, len(edges2) + 1
        ans = 0
        def calc(edges):
            nonlocal ans
            n = len(edges) + 1
            adj = [[] for _ in range(n + 1)]
            st1 = [0] * (n + 1)
            st2 = [0] * (n + 1)
            n1 = [-1] * (n + 1)
            n2 = [-1] * (n + 1)
            par = [0] * (n + 1)
            diam = 0
            res = math.inf
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            def dfs1(u, p):
                for v in adj[u]:
                    if v == p: continue
                    dfs1(v, u)
                    # update dp[u]
                    if st1[v] + 1 > st1[u]:
                        n2[u] = n1[u]
                        n1[u] = v
                        st2[u] = st1[u]
                        st1[u] = st1[v] + 1
                    elif st1[v] + 1 > st2[u]:
                        st2[u] = st1[v] + 1
                        n2[u] = v
            def dfs2(u, p):
                nonlocal res, diam
                # get answer based on new subtree and subtree of u
                res = min(res, max(par[u], st1[u]))
                diam = max(diam, par[u] + st1[u])
                for v in adj[u]:
                    if v == p: continue
                    # update par[v] based on par[u] and other children
                    par[v] = par[u] + 1
                    if n1[u] != v: par[v] = max(par[v], st1[u] + 1)
                    if n2[u] != v: par[v] = max(par[v], st2[u] + 1)
                    dfs2(v, u)
            dfs1(0, -1)
            dfs2(0, -1)
            ans = max(ans, diam)
            return res
        merged_tree = calc(edges1) + calc(edges2) + 1
        ans = max(ans, merged_tree)
        return ans
```

# Leetcode Weekly Contest 405

## 3213. Construct String with Minimum Cost

### Solution 1:  Aho-Corasick data structure, dynamic programming, bfs, trie, output links

```cpp
const int INF = 1e9, K = 26;
struct Vertex {
    bool is_leaf = false;
    int cost = INF;
    int output_link = 0;
    int suffix_link = 0;
    int depth = 0;
    int transition[K];
    void init() {
        fill(begin(transition), end(transition), 0);
    }
};
vector<Vertex> trie;
void add_string(const string& s, const int cost) {
    int cur = 0, depth = 0;
    for (char ch : s) {
        int c = ch - 'a';
        depth++;
        if (trie[cur].transition[c] == 0) {
            trie[cur].transition[c] = trie.size();
            Vertex v;
            v.init();
            v.depth = depth;
            trie.push_back(v);
        }
        cur = trie[cur].transition[c];
    }
    trie[cur].is_leaf = true;
    trie[cur].cost = min(trie[cur].cost, cost);
}
void push_links() {
    int queue[trie.size()];
    queue[0] = 0;
    int state = 0, next_state = 1;
    while (state < trie.size()) {
        int v = queue[state++];
        int u = trie[v].suffix_link;
        if (trie[u].is_leaf) trie[v].output_link = u;
        else trie[v].output_link = trie[u].output_link;
        for (int c = 0; c < K; c++) {
            if (trie[v].transition[c] != 0) {
                trie[trie[v].transition[c]].suffix_link = v ? trie[u].transition[c] : 0;
                queue[next_state++] = trie[v].transition[c];
            } else {
                trie[v].transition[c] = trie[u].transition[c];
            }
        }
    }
}
class Solution {
public:
    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        int m = words.size(), n = target.size();
        trie.resize(1);
        trie[0].init();
        for (int i = 0; i < m; i++) {
            add_string(words[i], costs[i]);
        }
        push_links();
        int cur = 0;
        vector<int> dp(n + 1, INF);
        dp[0] = 0;
        cur = 0;
        for (int i = 1; i <= n; i++) {
            cur = trie[cur].transition[target[i - 1] - 'a'];
            if (trie[cur].is_leaf) {
                dp[i] = min(dp[i], dp[i - trie[cur].depth] + trie[cur].cost);
            }
            int output = trie[cur].output_link;
            while (output) {
                dp[i] = min(dp[i], dp[i - trie[output].depth] + trie[output].cost);
                output = trie[output].output_link;
            }
        }
        return dp[n] < INF ? dp[n] : -1;
    }
};
```

# Leetcode Weekly Contest 406

## Minimum Cost for Cutting Cake II

### Solution 1:  greedy, sorting

```cpp
class Solution {
public:
    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        long long vcount = 1, hcount = 1, ans = 0;
        vector<pair<long long, int>> queries;
        for (int x : horizontalCut) {
            queries.emplace_back(x, 0);
        }
        for (int x : verticalCut) {
            queries.emplace_back(x, 1);
        }
        sort(queries.begin(), queries.end());
        reverse(queries.begin(), queries.end());
        for (auto [cost, t] : queries) {
            if (t == 0) {
                ans += vcount * cost;
                hcount++;
            } else {    
                ans += hcount * cost;
                vcount++;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 407

## Minimum Operations to Make Array Equal to Target

### Solution 1:  count increments and decrements, difference array

```cpp
class Solution {
public:
    long long minimumOperations(vector<int>& nums, vector<int>& target) {
        int N = nums.size();
        vector<int> diff(N);
        for (int i = 0; i < N; i++) {
            diff[i] = target[i] - nums[i];
        }
        long long ans = 0;
        int cur = 0;
        for (int d : diff) {
            if (d > 0) {
                cur = max(0, cur);
                int delta = max()
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 408

## 3233. Find the Count of Numbers Which Are Not Special

### Solution 1:  prime sieve, primes, squared integers

```cpp
// nloglog(n)
vector<long long> sieve(int N) {
    int spf[N];
    for (int i = 0; i < N; i++) {
        spf[i] = i;
    }
    vector<long long> primes;
    for (int i = 2; i < N; i++) {
        if (spf[i] != i) continue;
        primes.push_back(i);
        for (int j = i * i; j < N; j += i) {
            if (spf[j] != j) continue;
            spf[j] = i;
        }
    }
    return primes;
}
class Solution {
public:
    int nonSpecialCount(int l, int r) {
        int upper = (int)sqrt(r) + 1;
        vector<long long> primes = sieve(upper);
        int ans = 0;
        for (long long p : primes) {
            if (p * p >= l && p * p <= r) ans++;
        }
        return r - l + 1 - ans;
    }
};
```

## 3234. Count the Number of Substrings With Dominant Ones

### Solution 1:  square root trick, fix the sliding window, deque

```cpp
class Solution {
public:
    int calc(const string& s, int cnt) {
        int ans = 0, N = s.size();
        deque<int> dq;
        for (int i = 0, j = 0; i < N; i++) {
            if (s[i] == '0') dq.push_back(i);
            if (dq.size() > cnt) {
                j = dq.front() + 1;
                dq.pop_front();
            }
            if (dq.size() == cnt) {
                int pcount = dq.empty() ? i - j + 1 : dq.front() - j + 1;
                int count_ones = i - j + 1 - cnt;
                int extra_ones = max(0, count_ones - cnt * cnt + 1);
                ans += min(pcount, extra_ones);
            }
        }
        return ans;
    }
    int numberOfSubstrings(string s) {
        int N = s.size(), ans = 0;
        for (int i = 0; i * i <= N; i++) ans += calc(s, i);
        return ans;
    }
};
```

## 3235. Check if the Rectangle Corner Is Reachable

### Solution 1:  

```cpp
struct UnionFind {
    vector<int> parents, size;
    void init(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};
bool intersection(long long x1, long long y1, long long x2, long long y2, int r1, int r2) {
    double d = sqrt((x1 - x2) * (x1 - x2)+ (y1 - y2) * (y1 - y2));
    if (d <= r1 - r2 || d <= r2 - r1 || d < r1 + r2 || d == r1 + r2) return true;
    return false;
}
class Solution {
public:
    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {
        int N = circles.size();
        UnionFind dsu;
        dsu.init(N + 2);
        for (int i = 0; i < N; i++) {
            int x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];
            if (r1 >= x1 || r1 >= Y - y1) dsu.same(i, N);
            if (r1 >= y1 || r1 >= X - x1) dsu.same(i, N + 1);
            for (int j = 0; j < i; j++) {
                int x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];
                if (intersection(x1, y1, x2, y2, r1, r2)) {
                    dsu.same(i, j);
                }
            }
        }
        return !dsu.same(N, N + 1);
    }
};
```

# Leetcode Weekly Contest 409

## 3244. Shortest Distance After Road Addition Queries II

### Solution 1:  doubly ended linked list, next and previous array, 

```cpp
class Solution {
public:
    vector<int> nxt, prv;
    int START, END;
    void erase(int x) {
        prv[nxt[x]] = prv[x];
        nxt[prv[x]] = nxt[x];
        prv[x] = START;
        nxt[x] = END;
    }
    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        // 0 and 6 will be,  1, 2, 3, 4, 5, 
        // 0,1,2,3,...,n
        nxt.assign(n + 2, n + 1);
        prv.assign(n + 2, 0);
        START = 0;
        END = n + 1;
        for (int i = 1; i <= n; i++) {
            nxt[i] = i + 1;
            prv[i] = i - 1;
        }
        int q = queries.size();
        int dist = n - 1;
        vector<int> ans(q);
        for (int i = 0; i < q; i++) {
            int u = queries[i][0], v = queries[i][1];
            u++; v++;
            u = nxt[u];
            while (u < v) {
                int nxt_u = nxt[u];
                erase(u);
                dist--;
                u = nxt_u;
            }
            ans[i] = dist;
        }
        return ans;
    }
};
```

## Alternating Groups III

### Solution 1:  lazy segment tree, circular, point queries, assignment, frequency array

```cpp
struct LazySegmentTree {
    vector<int> values;
    vector<int> operations;
    int size, noop = -1;
    // assignment of non-negative integers

    void init(int n) {
        size = 1;
        while (size < n) size *= 2;
        values.assign(2 * size, noop);
    }

    bool is_leaf(int segment_right_bound, int segment_left_bound) {
        return segment_right_bound - segment_left_bound == 1;
    }

    void propagate(int segment_idx, int segment_left_bound, int segment_right_bound) {
        if (is_leaf(segment_right_bound, segment_left_bound) || values[segment_idx] == noop) return;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        values[left_segment_idx] = values[segment_idx];
        values[right_segment_idx] = values[segment_idx];
        values[segment_idx] = noop;
    }
    void update(int left, int right, int val) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        vector<int> segments;
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (segment_left_bound >= right || segment_right_bound <= left) continue;
            // COMPLETE OVERLAP
            if (segment_left_bound >= left && segment_right_bound <= right) {
                values[segment_idx] = val;
                continue;
            }
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
    }
    int query(int i) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (i < segment_left_bound || i >= segment_right_bound) continue;
            // COMPLETE OVERLAP
            if (is_leaf(segment_right_bound, segment_left_bound)) return values[segment_idx];
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
        return -1;
    }
};
class Solution {
public:
    map<int, int> freq;
    int N, Q;
    bool flag;
    LazySegmentTree seg;
    int length(int l, int r) {
        if (r > l) return r - l;
        return N - l + r;
    }
    void increment(int v) {
        if (freq.find(v) == freq.end()) freq[v] = 0;
        freq[v]++;
    }
    void decrement(int v) {
        freq[v]--;
        if (freq[v] == 0) freq.erase(v);
    }
    void update(int l, int r, int c) {
        if (r > l) {
            seg.update(l, r, c);
        } else {
            seg.update(0, r, c);
            seg.update(l, N, c);
        }
    }
    vector<pair<int, int>> ranges(int l, int r, int i) {
        vector<pair<int, int>> res;
        if (length(l, r) == N && flag) {
            res.emplace_back((i + 1) % N, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
        } else {
            res.emplace_back(l, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
            res.emplace_back((i + 1) % N, r);
        }
        return res;
    }
    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {
        N = colors.size(), Q = queries.size();
        seg.init(N);
        int comp_id = 0, start = 0;
        flag = false;
        vector<pair<int, int>> comp_ranges; // ranges [L, R)
        for (int i = 1; i < N; i++) {
            if (colors[i] == colors[i - 1]) {
                increment(length(start, i));
                comp_ranges.emplace_back(start, i);
                update(start, i, comp_id++);
                start = i;
            }
        }
        if (colors[0] != colors.back() && comp_id > 0) {
            auto [l, r] = comp_ranges[0];
            decrement(length(l, r));
            comp_ranges[0] = {start, r};
            increment(length(start, r));
            update(start, N, 0);
        } else {
            if (length(start, N) == N && colors[0] != colors.back()) flag = true;
            increment(length(start, N));
            comp_ranges.emplace_back(start, N);
            update(start, N, comp_id++);
        }
        vector<int> ans;
        for (const vector<int> &vec : queries) {
            if (vec[0] == 1) {
                int sz = vec[1];
                int res = 0;
                int cnt = 0;
                for (const auto &[k, v] : freq) {
                    res += max(0, (k - sz + 1) * v);
                    cnt += v;
                }
                if (cnt == 1 && flag) ans.push_back(N);
                else ans.push_back(res);
            } else {
                int i = vec[1], col = vec[2];
                if (colors[i] == col) continue; // no 
                colors[i] = col;
                int cur_comp_id = seg.query(i);
                auto [l, r] = comp_ranges[cur_comp_id];
                if (length(l, r) == 1) { // merging Cr and Cl
                    int Cl = seg.query((l - 1 + N) % N);
                    int Cr = seg.query(r % N);
                    auto [ll, lr] = comp_ranges[Cl];
                    auto [rl, rr] = comp_ranges[Cr];
                    decrement(length(ll, lr));
                    if (Cl != Cr) decrement(length(rl, rr));
                    if (Cl == Cr) rr = rr < N ? rr + 1 : 1;
                    decrement(length(l, r));
                    increment(length(ll, rr));
                    if (length(ll, rr) == N && colors[ll] != colors[rr - 1]) {
                        flag = true;
                    }
                    comp_ranges.emplace_back(ll, rr);
                    update(ll, rr, comp_id++);
                } else if (length(l, r) == N && flag) {
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                } else if (i == l) { // start point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].first = (l + 1) % N;
                        increment(length(comp_ranges[cur_comp_id].first, r));
                    }
                    int left_comp = seg.query((i - 1 + N) % N);
                    auto [nl, nr] = comp_ranges[left_comp];
                    decrement(length(nl, nr));
                    nr = i + 1;
                    increment(length(nl, nr));
                    comp_ranges[left_comp] = {nl, nr};
                    update(nl, nr, left_comp);
                } else if (i == r - 1) { // end point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].second = r != 1 ? r - 1 : N;
                        increment(length(l, comp_ranges[cur_comp_id].second));
                    }
                    int right_comp = seg.query((i + 1) % N);
                    auto [nl, nr] = comp_ranges[right_comp];
                    decrement(length(nl, nr));
                    nl = i;
                    increment(length(nl, nr));
                    comp_ranges[right_comp] = {nl, nr};
                    update(nl, nr, right_comp);
                } else { // intermediate point
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 410

## Find the Count of Monotonic Pairs II

### Solution 1: dynamic programming, counting, prefix sums

```cpp
class Solution {
public:
    const int M = 1e9 + 7, MAXN = 1e3 + 3;
    int countOfPairs(vector<int>& nums) {
        int N = nums.size();
        vector<long long> dp(MAXN, 0), ndp(MAXN, 0);
        for (int i = 0; i <= nums[0]; i++) {
            dp[i] = 1;
        }
        for (int i = 1; i < N; i++) {
            ndp.assign(MAXN, 0);
            int delta = max(nums[i] - nums[i - 1], 0);
            long long psum = 0;
            for (int j = delta; j <= nums[i]; j++) {
                psum = (psum + dp[j - delta]) % M;
                ndp[j] = psum;
            }
            swap(dp, ndp);
        }
        long long ans = 0;
        for (long long x : dp) {
            ans = (ans + x) % M;
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 411

## Find the Largest Palindrome Divisible by K

### Solution 1:  recursive dp, digit dp, tracking digits picked in each dp state

```cpp
class Solution {
public:
    vector<vector<int>> dp;
    vector<vector<int>> track;
    vector<int> powers;
    int N, K, mid;
    int recurse(int i, int rem) {
        if (i > mid) return rem == 0;
        if (dp[i][rem] != -1) return dp[i][rem];
        for (int dig = 9; dig >= 0; dig--) {
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            if (recurse(i + 1, (rem + add) % K)) {
                track[i][rem] = dig;
                return dp[i][rem] = true;
            }
        }
        return dp[i][rem] = false;
    }
    string largestPalindrome(int n, int k) {
        N = n;
        K = k;
        mid = (N - 1) / 2;
        dp.assign(mid + 1, vector<int>(K, -1));
        track.assign(mid + 1, vector<int>(K, -1));
        powers.resize(N);
        powers[0] = 1;
        for (int i = 1; i < N; i++) {
            powers[i] = (powers[i - 1] * 10) % K;
        }
        recurse(0, 0);
        string ans = "";
        for (int i = 0, rem = 0; i <= mid; i++) {
            ans += track[i][rem] + '0';
            int dig = track[i][rem];
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            rem = (rem + add) % K;
        }
        string s = ans.substr(0, N / 2);
        reverse(s.begin(), s.end());
        ans += s;
        return ans;
    }
};
```

## Count Substrings That Satisfy K-Constraint II

### Solution 1:  fenwick tree, prefix sums, precomputation of last index, binary search

```cpp
#include <bits/stdc++.h>
using namespace std;

long long neutral = 0;
struct FenwickTree {
    vector<long long> nodes;
    
    void init(int n) {
        nodes.assign(n + 1, neutral);
    }

    void update(int idx, int val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }

    long long query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : 0;
    }

    long long query(int idx) {
        long long result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }
};

class Solution {
public:
    int binary_search(vector<int>& arr, int lo, int hi, int target) {
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (arr[mid] <= target) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
        int N = s.size();
        vector<int> last_index(N + 1);
        int c0 = 0, c1 = 0, last = 0;
        FenwickTree ft, ft2;
        ft.init(N);
        ft2.init(N);
        for (int i = 0; i < N; i++) {
            if (s[i] == '0') {
                c0++;
            } else {
                c1++;
            }
            while (c0 > k && c1 > k) {
                if (s[last] == '0') {
                    c0--;
                } else {
                    c1--;
                }
                last++;
            }
            last_index[i] = last;
            ft.update(i + 1, i - last + 1);
            ft2.update(i + 1, last);
        }
        vector<long long> ans;
        for (auto &query : queries) {
            int l = query[0], r = query[1];
            int i = binary_search(last_index, l, r, l);  // lower bound
            long long segment_len = i - l + 1;
            long long delta = l * segment_len - ft2.query(l + 1, i + 1);
            long long res = ft.query(l + 1, r + 1) - delta;
            ans.push_back(res);
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 412

## 3266. Final Array State After K Multiplication Operations II

### Solution 1: exponentiation, min heap, greedy, m = 2, it will grow fast to reach max value of only 10^5
it will grow really fast to reach the mx value of 10^9, with m = 2, it can happen in at most 60 operations, so you have 60 * N log(60 * N)
Now you have an array where all the values if multiplied by the multiplier m would exceed the largest value in the array.
You will evenly distribute the remainder operations between each element in the array, why does this work, because every time you multiplied by multiplier
the value will become the next max, if you have it sorted from smallest to largest.  The smallest will take lead, then the second smallest takes lead and so on. 
Then in the next iteration it will be back in original order with same maximum as previously.  So you just need to figure out how many times you will perform operation on entire array given remaining k operations.  Then you will maybe have some remainder where you will perform k + 1 operations on the prefix of the array and k on the rest of the array. 


```cpp
long long exponentiation(long long b, long long p, long long m) {
    long long res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    const int M = 1e9 + 7;
    vector<int> getFinalState(vector<int>& nums, int k, int m) {
        if (m == 1) return nums; // trivial case
        int N = nums.size();
        long long mx = *max_element(nums.begin(), nums.end());
        // minheap
        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> minheap;
        for (int i = 0; i < N; i++) {
            minheap.emplace(nums[i], i);
        }
        vector<pair<long long, int>> res;
        while (!minheap.empty() && k > 0) {
            auto [val, i] = minheap.top();
            minheap.pop();
            // do something
            if (val * m <= mx) {
                minheap.emplace(val * m, i);
                k--;
            } else {
                res.emplace_back(val, i);
            }
        }
        while (!minheap.empty()) {
            auto [val, i] = minheap.top();
            minheap.pop();
            res.emplace_back(val, i);
        }
        sort(res.begin(), res.end());
        vector<int> ans(N);
        if (k == 0) {
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first % M;
            }
        } else {
            int rem = k % N;
            int div = k / N;
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first * exponentiation(m, div, M) % M;
            }
            for (int i = 0; i < rem; i++) {
                ans[res[i].second] = ((long long)ans[res[i].second] * m) % M;
            }                

        }
        return ans;
    }
};

```

## 3267. Count Almost Equal Pairs II

### Solution 1:  frequency map, set, try every single swap, need optimizations
This one is tricky, it only passes if you include the s[i] = s[j] skipping parts.  So you need some optimizations in your code to remove unnecessary looping.

```cpp
class Solution {
public:
    int M;
    unordered_set<int> get(string s) {
        unordered_set<int> res;
        res.insert(stoi(s));
        for (int i = 0; i < M; i++) {
            for (int j = i + 1; j < M; j++) {
                if (s[i] == s[j]) continue;
                swap(s[i], s[j]);
                res.insert(stoi(s));
                for (int k = 0; k < M; k++) {
                    for (int l = 0; l < M; l++) {
                        if (s[k] == s[l]) continue;
                        swap(s[k], s[l]);
                        res.insert(stoi(s));
                        swap(s[k], s[l]);
                    }
                }
                swap(s[i], s[j]);
            }
        }
        return res;
    }
    int countPairs(vector<int>& nums) {
        M = to_string(*max_element(nums.begin(), nums.end())).size();
        unordered_map<int, int> freq;
        int N = nums.size();
        int ans = 0;
        for (int i = 0; i < N; i++) {
            string s = to_string(nums[i]);
            s = string(M - s.size(), '0') + s;
            unordered_set<int> candidates = get(s);
            for (const int &cand : candidates) {
                ans += freq[cand];
            }
            freq[nums[i]]++;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 413

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 414

## 3281. Maximize Score of Numbers in Ranges

### Solution 1:  binary search, greedy, sort

```cpp
class Solution {
public:
    const long long INF = 1e12;
    bool possible(const vector<int>& start, long long d, long long target) {
        long long last = -INF;
        for (int s : start) {
            long long best = last + target;
            last = max(best, (long long)s);
            if (last > s + d) return false;
        }
        return true;
    }
    int maxPossibleScore(vector<int>& start, int d) {
        sort(start.begin(), start.end());
        long long lo = 0, hi = INF;
        while (lo < hi) {
            long long mid = lo + (hi - lo + 1) / 2;
            if (possible(start, d, mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
};
```

## 3282. Reach End of Array With Max Score

### Solution 1:  monotonic stack, dynamic programming, greedy

1. iterate backwards in the array, and you want to add the nearest element that is greater than current element.
2. You can do this maintaining a monotonically decreasing stack, [3,2,1]
3. You compute the value by taking the distance from current index to the index of last element that is greater than it. 

```cpp
class Solution {
public:
    long long findMaximumScore(vector<int>& nums) {
        int N = nums.size();
        stack<long long> stk;
        stk.push(N - 1);
        vector<long long> dp(N, 0);
        for (long long i = N - 2; i >= 0; i--) {
            while (!stk.empty() && nums[stk.top()] <= nums[i]) stk.pop();
            if (stk.empty()) {
                dp[i] = (N - i - 1) * nums[i] + dp.back();
            } else {
                dp[i] = (stk.top() - i) * nums[i] + dp[stk.top()];
            }
            stk.push(i);
        }
        return dp[0];
    }
};
```

## 3283. Maximum Number of Moves to Kill All Pawns

### Solution 1: bitmask dp, minimax algorithm, graph, precompute min knight distances, bfs

1. For it to be fast enough it has to precompute the min distance from each pawn and include the knight as a pawn. 
2. Then it just needs to compute the best option for dp state (idx, mask, ismax)

```cpp
#define x first
#define y second
const int M = 50, INF = 1e9, P = 15;
const vector<pair<int, int>> MOVES = {{-2, 1}, {-2, -1}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {1, 2}, {-1, 2}};
int N, end_mask;
vector<pair<int, int>> pos;
int dist[M][M][M][M], dp[P + 1][1 << P][2];
bool in_bounds(int x, int y) {
    return x >= 0 && x < M && y >= 0 && y < M;
}
void bfs(int kx, int ky) {
    queue<pair<int, int>> q;
    q.emplace(kx, ky);
    dist[kx][ky][kx][ky] = 0;
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        for (auto [dx, dy] : MOVES) {
            int nx = x + dx, ny = y + dy;
            if (in_bounds(nx, ny) && dist[kx][ky][nx][ny] == -1) {
                dist[kx][ky][nx][ny] = dist[kx][ky][x][y] + 1;
                q.emplace(nx, ny);
            }
        }
    }
}
int minimax(int idx, int mask, bool ismax) {
    auto [x, y] = pos[idx];
    if (mask == end_mask) return 0;
    if (dp[idx][mask][ismax] != -1) return dp[idx][mask][ismax];
    int ans = ismax ? 0 : INF;
    for (int i = 0; i < N; i++) {
        if ((mask >> i) & 1) continue;
        if (ismax) {
            ans = max(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        } else {
            ans = min(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        }
    }
    return dp[idx][mask][ismax] = ans;
}
class Solution {
public:
    int maxMoves(int kx, int ky, vector<vector<int>>& poss) {
        N = poss.size();
        pos.resize(N);
        for (int i = 0; i < N; i++) {
            pos[i].x = poss[i][0], pos[i].y = poss[i][1];
        }
        pos.emplace_back(kx, ky);
        memset(dist, -1, sizeof(dist));
        for (const auto &[x, y] : pos) {
            bfs(x, y);
        }
        memset(dp, -1, sizeof(dp));
        end_mask = (1 << N) - 1;
        return minimax(N, 0, true); // (idx, mask, ismax)
    }
};
```

# Leetcode Weekly Contest 415

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 416

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 417

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 418

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 419

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 420

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 421

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 422

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```