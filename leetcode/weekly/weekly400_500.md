# Leetcode Weekly Contest 400 - 500

# Leetcode Weekly Contest 400

## 3171. Find Subarray With Bitwise AND Closest to K

### Solution 1:  bitwise and range queries, static array, sparse table, binary search

```py
class ST_And:
    def __init__(self, nums):
        self.nums = nums
        self.n = len(nums)
        self.LOG = 18 # 10,000
        self.build()

    def op(self, x, y):
        return x & y

    def build(self):
        self.lg = [0] * (self.n + 1)
        for i in range(2, self.n + 1):
            self.lg[i] = self.lg[i // 2] + 1
        self.st = [[0] * self.n for _ in range(self.LOG)]
        for i in range(self.n): 
            self.st[0][i] = self.nums[i]
        # CONSTRUCT SPARSE TABLE
        for i in range(1, self.LOG):
            j = 0
            while (j + (1 << (i - 1))) < self.n:
                self.st[i][j] = self.op(self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))])
                j += 1

    def query(self, l, r):
        length = r - l + 1
        i = self.lg[length]
        return self.op(self.st[i][l], self.st[i][r - (1 << i) + 1])
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        n = len(nums)
        ans = math.inf
        st = ST_And(nums)
        def possible(src, dst):
            v = st.query(src, dst)
            return v >= k
        def bsearch(start):
            lo, hi = start, n - 1
            while lo < hi:
                mid = (lo + hi + 1) >> 1
                if possible(start, mid):
                    lo = mid
                else:
                    hi = mid - 1
            return lo
        for i in range(n):
            j = bsearch(i)
            v = st.query(i, j)
            ans = min(ans, abs(v - k))
            j += 1
            if j < n:
                v = st.query(i, j)
                ans = min(ans, abs(v - k))
        return ans
```

# Leetcode Weekly Contest 401

## 3181. Maximum Total Reward Using Operations II

### Solution 1:  bit manipulation, bitsets, dynamic programming, reachability, sorting

```cpp
class Solution {
public:
    int maxTotalReward(vector<int>& rewards) {
        const int MAXN = 1e5;
        int N = rewards.size();
        sort(rewards.begin(), rewards.end());
        bitset<MAXN> dp, mask;
        dp.set(0);
        int x = 0;
        for (int v : rewards) {
            while (x < v) {
                mask.set(x++);
            }
            dp |= (dp & mask) << v;
        }
        for (int x = MAXN - 1; x >= 0; x--) {
            if (dp.test(x)) return x;
        }
        return 0;
    }
};
```

```py
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        MAXN = int(1e5)
        x = mask = 0
        dp = 1
        for r in sorted(rewardValues):
            while x < r:
                mask |= (1 << x)
                x += 1
            dp |= (dp & mask) << r
        for i in reversed(range(MAXN)):
            if (dp >> i) & 1: return i
```

# Leetcode Weekly Contest 402

## Count Pairs That Form a Complete Day II

### Solution 1:  counter, modulo

```py
class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        n = len(hours)
        counts = Counter()
        ans = 0
        for h in map(lambda x: x % 24, hours):
            ans += counts[(24 - h) % 24]
            counts[h] += 1
        return ans
```

## Maximum Total Damage With Spell Casting

### Solution 1:  dp, coordinate compression, frequency array

```py
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        n = len(power)
        freq = Counter(power)
        power = sorted(set(power))
        compressed = set()
        for p in power:
            for i in range(-3, 3):
                compressed.add(p + i)
        compressed = sorted(compressed)
        N = len(compressed)
        dp = [0] * N
        for p in range(3, N):
            dp[p] = max(dp[p - 2], dp[p - 1], dp[p - 3] + compressed[p] * freq[compressed[p]])
        return dp[-1]
```

## 3187. Peaks in Array

### Solution 1: fenwick tree, point updates, range count queries

```py
class FenwickTree:
    def __init__(self, N):
        self.sums = [0 for _ in range(N+1)]

    def update(self, i, delta):
        while i < len(self.sums):
            self.sums[i] += delta
            i += i & (-i)

    def query(self, i):
        res = 0
        while i > 0:
            res += self.sums[i]
            i -= i & (-i)
        return res

    def query_range(self, i, j):
        return self.query(j) - self.query(i - 1) if j >= i else 0

    def __repr__(self):
        return f"array: {self.sums}"
class Solution:
    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n, m = len(nums), len(queries)
        peaks = [0] * n
        for i in range(1, n - 1):
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                peaks[i] = 1
        ans = []
        ft = FenwickTree(n)
        for i in range(n):
            if peaks[i]: ft.update(i + 1, 1)
        for t, l, r in queries:
            if t == 1:
                res = ft.query_range(l + 2, r)
                ans.append(res)
            else:
                nums[l] = r
                # update index peak
                if l > 0 and l + 1 < n:
                    if nums[l] > nums[l - 1] and nums[l] > nums[l + 1]:
                        if not peaks[l]:
                            peaks[l] = 1
                            ft.update(l + 1, 1)
                    else:
                        if peaks[l]:
                            peaks[l] = 0
                            ft.update(l + 1, -1)
                # update index + 1 peak
                if l + 2 < n:
                    if nums[l + 1] > nums[l] and nums[l + 1] > nums[l + 2]:
                        if not peaks[l + 1]:
                            peaks[l + 1] = 1
                            ft.update(l + 2, 1)
                    else:
                        if peaks[l + 1]:
                            peaks[l + 1] = 0
                            ft.update(l + 2, -1)
                # update index - 1 peak
                if l > 1:
                    if nums[l - 1] > nums[l - 2] and nums[l - 1] > nums[l]:
                        if not peaks[l - 1]:
                            peaks[l - 1] = 1
                            ft.update(l, 1)
                    else:
                        if peaks[l - 1]:
                            peaks[l - 1] = 0
                            ft.update(l, -1)
        return ans
```

# Leetcode Weekly Contest 403

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

## 

### Solution 1: 

```py

```

# Leetcode Weekly Contest 404

## Find the Maximum Length of Valid Subsequence I

### Solution 1:  dynammic programming, binary, base 2

```py
class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        n = len(nums)
        nums = [x % 2 for x in nums]
        dp = [[0] * 2 for _ in range(2)] # (last, rem)
        for i in range(2):
            dp[nums[0]][i] = 1
        for num in nums[1:]:
            ndp = dp[:]
            for rem in range(2): # rem
                ndp[num][rem] = max(ndp[num][rem], dp[rem ^ num][rem] + 1)
            dp = ndp
        return max(max(row) for row in dp)
```

## Find the Maximum Length of Valid Subsequence II

### Solution 1:  dynamic programming

```py
class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)] # dp[n][k]
        ans = 0
        for i in range(1, n):
            for j in range(i):
                val = (nums[i] + nums[j]) % k
                dp[i][val] = max(dp[i][val], dp[j][val] + 1, 2)
                ans = max(ans, dp[i][val])
        return ans
```

## 3203. Find Minimum Diameter After Merging Two Trees

### Solution 1:  tree rerooting dp, dfs, tree diameter

```py
class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        n, m = len(edges1) + 1, len(edges2) + 1
        ans = 0
        def calc(edges):
            nonlocal ans
            n = len(edges) + 1
            adj = [[] for _ in range(n + 1)]
            st1 = [0] * (n + 1)
            st2 = [0] * (n + 1)
            n1 = [-1] * (n + 1)
            n2 = [-1] * (n + 1)
            par = [0] * (n + 1)
            diam = 0
            res = math.inf
            for u, v in edges:
                adj[u].append(v)
                adj[v].append(u)
            def dfs1(u, p):
                for v in adj[u]:
                    if v == p: continue
                    dfs1(v, u)
                    # update dp[u]
                    if st1[v] + 1 > st1[u]:
                        n2[u] = n1[u]
                        n1[u] = v
                        st2[u] = st1[u]
                        st1[u] = st1[v] + 1
                    elif st1[v] + 1 > st2[u]:
                        st2[u] = st1[v] + 1
                        n2[u] = v
            def dfs2(u, p):
                nonlocal res, diam
                # get answer based on new subtree and subtree of u
                res = min(res, max(par[u], st1[u]))
                diam = max(diam, par[u] + st1[u])
                for v in adj[u]:
                    if v == p: continue
                    # update par[v] based on par[u] and other children
                    par[v] = par[u] + 1
                    if n1[u] != v: par[v] = max(par[v], st1[u] + 1)
                    if n2[u] != v: par[v] = max(par[v], st2[u] + 1)
                    dfs2(v, u)
            dfs1(0, -1)
            dfs2(0, -1)
            ans = max(ans, diam)
            return res
        merged_tree = calc(edges1) + calc(edges2) + 1
        ans = max(ans, merged_tree)
        return ans
```

# Leetcode Weekly Contest 405

## 3213. Construct String with Minimum Cost

### Solution 1:  Aho-Corasick data structure, dynamic programming, bfs, trie, output links

```cpp
const int INF = 1e9, K = 26;
struct Vertex {
    bool is_leaf = false;
    int cost = INF;
    int output_link = 0;
    int suffix_link = 0;
    int depth = 0;
    int transition[K];
    void init() {
        fill(begin(transition), end(transition), 0);
    }
};
vector<Vertex> trie;
void add_string(const string& s, const int cost) {
    int cur = 0, depth = 0;
    for (char ch : s) {
        int c = ch - 'a';
        depth++;
        if (trie[cur].transition[c] == 0) {
            trie[cur].transition[c] = trie.size();
            Vertex v;
            v.init();
            v.depth = depth;
            trie.push_back(v);
        }
        cur = trie[cur].transition[c];
    }
    trie[cur].is_leaf = true;
    trie[cur].cost = min(trie[cur].cost, cost);
}
void push_links() {
    int queue[trie.size()];
    queue[0] = 0;
    int state = 0, next_state = 1;
    while (state < trie.size()) {
        int v = queue[state++];
        int u = trie[v].suffix_link;
        if (trie[u].is_leaf) trie[v].output_link = u;
        else trie[v].output_link = trie[u].output_link;
        for (int c = 0; c < K; c++) {
            if (trie[v].transition[c] != 0) {
                trie[trie[v].transition[c]].suffix_link = v ? trie[u].transition[c] : 0;
                queue[next_state++] = trie[v].transition[c];
            } else {
                trie[v].transition[c] = trie[u].transition[c];
            }
        }
    }
}
class Solution {
public:
    int minimumCost(string target, vector<string>& words, vector<int>& costs) {
        int m = words.size(), n = target.size();
        trie.resize(1);
        trie[0].init();
        for (int i = 0; i < m; i++) {
            add_string(words[i], costs[i]);
        }
        push_links();
        int cur = 0;
        vector<int> dp(n + 1, INF);
        dp[0] = 0;
        cur = 0;
        for (int i = 1; i <= n; i++) {
            cur = trie[cur].transition[target[i - 1] - 'a'];
            if (trie[cur].is_leaf) {
                dp[i] = min(dp[i], dp[i - trie[cur].depth] + trie[cur].cost);
            }
            int output = trie[cur].output_link;
            while (output) {
                dp[i] = min(dp[i], dp[i - trie[output].depth] + trie[output].cost);
                output = trie[output].output_link;
            }
        }
        return dp[n] < INF ? dp[n] : -1;
    }
};
```

# Leetcode Weekly Contest 406

## Minimum Cost for Cutting Cake II

### Solution 1:  greedy, sorting

```cpp
class Solution {
public:
    long long minimumCost(int m, int n, vector<int>& horizontalCut, vector<int>& verticalCut) {
        long long vcount = 1, hcount = 1, ans = 0;
        vector<pair<long long, int>> queries;
        for (int x : horizontalCut) {
            queries.emplace_back(x, 0);
        }
        for (int x : verticalCut) {
            queries.emplace_back(x, 1);
        }
        sort(queries.begin(), queries.end());
        reverse(queries.begin(), queries.end());
        for (auto [cost, t] : queries) {
            if (t == 0) {
                ans += vcount * cost;
                hcount++;
            } else {    
                ans += hcount * cost;
                vcount++;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 407

## Minimum Operations to Make Array Equal to Target

### Solution 1:  count increments and decrements, difference array

```cpp
class Solution {
public:
    long long minimumOperations(vector<int>& nums, vector<int>& target) {
        int N = nums.size();
        vector<int> diff(N);
        for (int i = 0; i < N; i++) {
            diff[i] = target[i] - nums[i];
        }
        long long ans = 0;
        int cur = 0;
        for (int d : diff) {
            if (d > 0) {
                cur = max(0, cur);
                int delta = max()
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 408

## 3233. Find the Count of Numbers Which Are Not Special

### Solution 1:  prime sieve, primes, squared integers

```cpp
// nloglog(n)
vector<long long> sieve(int N) {
    int spf[N];
    for (int i = 0; i < N; i++) {
        spf[i] = i;
    }
    vector<long long> primes;
    for (int i = 2; i < N; i++) {
        if (spf[i] != i) continue;
        primes.push_back(i);
        for (int j = i * i; j < N; j += i) {
            if (spf[j] != j) continue;
            spf[j] = i;
        }
    }
    return primes;
}
class Solution {
public:
    int nonSpecialCount(int l, int r) {
        int upper = (int)sqrt(r) + 1;
        vector<long long> primes = sieve(upper);
        int ans = 0;
        for (long long p : primes) {
            if (p * p >= l && p * p <= r) ans++;
        }
        return r - l + 1 - ans;
    }
};
```

## 3234. Count the Number of Substrings With Dominant Ones

### Solution 1:  square root trick, fix the sliding window, deque

```cpp
class Solution {
public:
    int calc(const string& s, int cnt) {
        int ans = 0, N = s.size();
        deque<int> dq;
        for (int i = 0, j = 0; i < N; i++) {
            if (s[i] == '0') dq.push_back(i);
            if (dq.size() > cnt) {
                j = dq.front() + 1;
                dq.pop_front();
            }
            if (dq.size() == cnt) {
                int pcount = dq.empty() ? i - j + 1 : dq.front() - j + 1;
                int count_ones = i - j + 1 - cnt;
                int extra_ones = max(0, count_ones - cnt * cnt + 1);
                ans += min(pcount, extra_ones);
            }
        }
        return ans;
    }
    int numberOfSubstrings(string s) {
        int N = s.size(), ans = 0;
        for (int i = 0; i * i <= N; i++) ans += calc(s, i);
        return ans;
    }
};
```

## 3235. Check if the Rectangle Corner Is Reachable

### Solution 1:  

```cpp
struct UnionFind {
    vector<int> parents, size;
    void init(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    bool same(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            return false;
        }
        return true;
    }
};
bool intersection(long long x1, long long y1, long long x2, long long y2, int r1, int r2) {
    double d = sqrt((x1 - x2) * (x1 - x2)+ (y1 - y2) * (y1 - y2));
    if (d <= r1 - r2 || d <= r2 - r1 || d < r1 + r2 || d == r1 + r2) return true;
    return false;
}
class Solution {
public:
    bool canReachCorner(int X, int Y, vector<vector<int>>& circles) {
        int N = circles.size();
        UnionFind dsu;
        dsu.init(N + 2);
        for (int i = 0; i < N; i++) {
            int x1 = circles[i][0], y1 = circles[i][1], r1 = circles[i][2];
            if (r1 >= x1 || r1 >= Y - y1) dsu.same(i, N);
            if (r1 >= y1 || r1 >= X - x1) dsu.same(i, N + 1);
            for (int j = 0; j < i; j++) {
                int x2 = circles[j][0], y2 = circles[j][1], r2 = circles[j][2];
                if (intersection(x1, y1, x2, y2, r1, r2)) {
                    dsu.same(i, j);
                }
            }
        }
        return !dsu.same(N, N + 1);
    }
};
```

# Leetcode Weekly Contest 409

## 3244. Shortest Distance After Road Addition Queries II

### Solution 1:  doubly ended linked list, next and previous array, 

```cpp
class Solution {
public:
    vector<int> nxt, prv;
    int START, END;
    void erase(int x) {
        prv[nxt[x]] = prv[x];
        nxt[prv[x]] = nxt[x];
        prv[x] = START;
        nxt[x] = END;
    }
    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        // 0 and 6 will be,  1, 2, 3, 4, 5, 
        // 0,1,2,3,...,n
        nxt.assign(n + 2, n + 1);
        prv.assign(n + 2, 0);
        START = 0;
        END = n + 1;
        for (int i = 1; i <= n; i++) {
            nxt[i] = i + 1;
            prv[i] = i - 1;
        }
        int q = queries.size();
        int dist = n - 1;
        vector<int> ans(q);
        for (int i = 0; i < q; i++) {
            int u = queries[i][0], v = queries[i][1];
            u++; v++;
            u = nxt[u];
            while (u < v) {
                int nxt_u = nxt[u];
                erase(u);
                dist--;
                u = nxt_u;
            }
            ans[i] = dist;
        }
        return ans;
    }
};
```

## Alternating Groups III

### Solution 1:  lazy segment tree, circular, point queries, assignment, frequency array

```cpp
struct LazySegmentTree {
    vector<int> values;
    vector<int> operations;
    int size, noop = -1;
    // assignment of non-negative integers

    void init(int n) {
        size = 1;
        while (size < n) size *= 2;
        values.assign(2 * size, noop);
    }

    bool is_leaf(int segment_right_bound, int segment_left_bound) {
        return segment_right_bound - segment_left_bound == 1;
    }

    void propagate(int segment_idx, int segment_left_bound, int segment_right_bound) {
        if (is_leaf(segment_right_bound, segment_left_bound) || values[segment_idx] == noop) return;
        int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
        values[left_segment_idx] = values[segment_idx];
        values[right_segment_idx] = values[segment_idx];
        values[segment_idx] = noop;
    }
    void update(int left, int right, int val) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        vector<int> segments;
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (segment_left_bound >= right || segment_right_bound <= left) continue;
            // COMPLETE OVERLAP
            if (segment_left_bound >= left && segment_right_bound <= right) {
                values[segment_idx] = val;
                continue;
            }
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
    }
    int query(int i) {
        stack<tuple<int, int, int>> stk;
        stk.emplace(0, size, 0);
        int segment_left_bound, segment_right_bound, segment_idx;
        while (!stk.empty()) {
            tie(segment_left_bound, segment_right_bound, segment_idx) = stk.top();
            stk.pop();
            // NO OVERLAP
            if (i < segment_left_bound || i >= segment_right_bound) continue;
            // COMPLETE OVERLAP
            if (is_leaf(segment_right_bound, segment_left_bound)) return values[segment_idx];
            // PARTIAL OVERLAP
            int mid_point = (segment_left_bound + segment_right_bound) >> 1;
            int left_segment_idx = 2 * segment_idx + 1, right_segment_idx = 2 * segment_idx + 2;
            propagate(segment_idx, segment_left_bound, segment_right_bound);
            stk.emplace(mid_point, segment_right_bound, right_segment_idx);
            stk.emplace(segment_left_bound, mid_point, left_segment_idx);
        }
        return -1;
    }
};
class Solution {
public:
    map<int, int> freq;
    int N, Q;
    bool flag;
    LazySegmentTree seg;
    int length(int l, int r) {
        if (r > l) return r - l;
        return N - l + r;
    }
    void increment(int v) {
        if (freq.find(v) == freq.end()) freq[v] = 0;
        freq[v]++;
    }
    void decrement(int v) {
        freq[v]--;
        if (freq[v] == 0) freq.erase(v);
    }
    void update(int l, int r, int c) {
        if (r > l) {
            seg.update(l, r, c);
        } else {
            seg.update(0, r, c);
            seg.update(l, N, c);
        }
    }
    vector<pair<int, int>> ranges(int l, int r, int i) {
        vector<pair<int, int>> res;
        if (length(l, r) == N && flag) {
            res.emplace_back((i + 1) % N, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
        } else {
            res.emplace_back(l, i == 0 ? N : i);
            res.emplace_back(i, i + 1);
            res.emplace_back((i + 1) % N, r);
        }
        return res;
    }
    vector<int> numberOfAlternatingGroups(vector<int>& colors, vector<vector<int>>& queries) {
        N = colors.size(), Q = queries.size();
        seg.init(N);
        int comp_id = 0, start = 0;
        flag = false;
        vector<pair<int, int>> comp_ranges; // ranges [L, R)
        for (int i = 1; i < N; i++) {
            if (colors[i] == colors[i - 1]) {
                increment(length(start, i));
                comp_ranges.emplace_back(start, i);
                update(start, i, comp_id++);
                start = i;
            }
        }
        if (colors[0] != colors.back() && comp_id > 0) {
            auto [l, r] = comp_ranges[0];
            decrement(length(l, r));
            comp_ranges[0] = {start, r};
            increment(length(start, r));
            update(start, N, 0);
        } else {
            if (length(start, N) == N && colors[0] != colors.back()) flag = true;
            increment(length(start, N));
            comp_ranges.emplace_back(start, N);
            update(start, N, comp_id++);
        }
        vector<int> ans;
        for (const vector<int> &vec : queries) {
            if (vec[0] == 1) {
                int sz = vec[1];
                int res = 0;
                int cnt = 0;
                for (const auto &[k, v] : freq) {
                    res += max(0, (k - sz + 1) * v);
                    cnt += v;
                }
                if (cnt == 1 && flag) ans.push_back(N);
                else ans.push_back(res);
            } else {
                int i = vec[1], col = vec[2];
                if (colors[i] == col) continue; // no 
                colors[i] = col;
                int cur_comp_id = seg.query(i);
                auto [l, r] = comp_ranges[cur_comp_id];
                if (length(l, r) == 1) { // merging Cr and Cl
                    int Cl = seg.query((l - 1 + N) % N);
                    int Cr = seg.query(r % N);
                    auto [ll, lr] = comp_ranges[Cl];
                    auto [rl, rr] = comp_ranges[Cr];
                    decrement(length(ll, lr));
                    if (Cl != Cr) decrement(length(rl, rr));
                    if (Cl == Cr) rr = rr < N ? rr + 1 : 1;
                    decrement(length(l, r));
                    increment(length(ll, rr));
                    if (length(ll, rr) == N && colors[ll] != colors[rr - 1]) {
                        flag = true;
                    }
                    comp_ranges.emplace_back(ll, rr);
                    update(ll, rr, comp_id++);
                } else if (length(l, r) == N && flag) {
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                } else if (i == l) { // start point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].first = (l + 1) % N;
                        increment(length(comp_ranges[cur_comp_id].first, r));
                    }
                    int left_comp = seg.query((i - 1 + N) % N);
                    auto [nl, nr] = comp_ranges[left_comp];
                    decrement(length(nl, nr));
                    nr = i + 1;
                    increment(length(nl, nr));
                    comp_ranges[left_comp] = {nl, nr};
                    update(nl, nr, left_comp);
                } else if (i == r - 1) { // end point
                    decrement(length(l, r));
                    if (length(l, r) > 1) {
                        comp_ranges[cur_comp_id].second = r != 1 ? r - 1 : N;
                        increment(length(l, comp_ranges[cur_comp_id].second));
                    }
                    int right_comp = seg.query((i + 1) % N);
                    auto [nl, nr] = comp_ranges[right_comp];
                    decrement(length(nl, nr));
                    nl = i;
                    increment(length(nl, nr));
                    comp_ranges[right_comp] = {nl, nr};
                    update(nl, nr, right_comp);
                } else { // intermediate point
                    vector<pair<int, int>> new_ranges = ranges(l, r, i);
                    decrement(length(l, r));
                    for (const auto &[ll, rr] : new_ranges) {
                        if (!length(ll, rr)) continue;
                        increment(length(ll, rr));
                        comp_ranges.emplace_back(ll, rr);
                        update(ll, rr, comp_id++);
                    }
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 410

## Find the Count of Monotonic Pairs II

### Solution 1: dynamic programming, counting, prefix sums

```cpp
class Solution {
public:
    const int M = 1e9 + 7, MAXN = 1e3 + 3;
    int countOfPairs(vector<int>& nums) {
        int N = nums.size();
        vector<long long> dp(MAXN, 0), ndp(MAXN, 0);
        for (int i = 0; i <= nums[0]; i++) {
            dp[i] = 1;
        }
        for (int i = 1; i < N; i++) {
            ndp.assign(MAXN, 0);
            int delta = max(nums[i] - nums[i - 1], 0);
            long long psum = 0;
            for (int j = delta; j <= nums[i]; j++) {
                psum = (psum + dp[j - delta]) % M;
                ndp[j] = psum;
            }
            swap(dp, ndp);
        }
        long long ans = 0;
        for (long long x : dp) {
            ans = (ans + x) % M;
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 411

## Find the Largest Palindrome Divisible by K

### Solution 1:  recursive dp, digit dp, tracking digits picked in each dp state

```cpp
class Solution {
public:
    vector<vector<int>> dp;
    vector<vector<int>> track;
    vector<int> powers;
    int N, K, mid;
    int recurse(int i, int rem) {
        if (i > mid) return rem == 0;
        if (dp[i][rem] != -1) return dp[i][rem];
        for (int dig = 9; dig >= 0; dig--) {
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            if (recurse(i + 1, (rem + add) % K)) {
                track[i][rem] = dig;
                return dp[i][rem] = true;
            }
        }
        return dp[i][rem] = false;
    }
    string largestPalindrome(int n, int k) {
        N = n;
        K = k;
        mid = (N - 1) / 2;
        dp.assign(mid + 1, vector<int>(K, -1));
        track.assign(mid + 1, vector<int>(K, -1));
        powers.resize(N);
        powers[0] = 1;
        for (int i = 1; i < N; i++) {
            powers[i] = (powers[i - 1] * 10) % K;
        }
        recurse(0, 0);
        string ans = "";
        for (int i = 0, rem = 0; i <= mid; i++) {
            ans += track[i][rem] + '0';
            int dig = track[i][rem];
            int add = (dig * powers[i]) % K;
            if (i < mid || (i == mid && N % 2 == 0)) add = (add + dig * powers[N - i - 1]) % K;
            rem = (rem + add) % K;
        }
        string s = ans.substr(0, N / 2);
        reverse(s.begin(), s.end());
        ans += s;
        return ans;
    }
};
```

## Count Substrings That Satisfy K-Constraint II

### Solution 1:  fenwick tree, prefix sums, precomputation of last index, binary search

```cpp
#include <bits/stdc++.h>
using namespace std;

long long neutral = 0;
struct FenwickTree {
    vector<long long> nodes;
    
    void init(int n) {
        nodes.assign(n + 1, neutral);
    }

    void update(int idx, int val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }

    long long query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : 0;
    }

    long long query(int idx) {
        long long result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }
};

class Solution {
public:
    int binary_search(vector<int>& arr, int lo, int hi, int target) {
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (arr[mid] <= target) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
    vector<long long> countKConstraintSubstrings(string s, int k, vector<vector<int>>& queries) {
        int N = s.size();
        vector<int> last_index(N + 1);
        int c0 = 0, c1 = 0, last = 0;
        FenwickTree ft, ft2;
        ft.init(N);
        ft2.init(N);
        for (int i = 0; i < N; i++) {
            if (s[i] == '0') {
                c0++;
            } else {
                c1++;
            }
            while (c0 > k && c1 > k) {
                if (s[last] == '0') {
                    c0--;
                } else {
                    c1--;
                }
                last++;
            }
            last_index[i] = last;
            ft.update(i + 1, i - last + 1);
            ft2.update(i + 1, last);
        }
        vector<long long> ans;
        for (auto &query : queries) {
            int l = query[0], r = query[1];
            int i = binary_search(last_index, l, r, l);  // lower bound
            long long segment_len = i - l + 1;
            long long delta = l * segment_len - ft2.query(l + 1, i + 1);
            long long res = ft.query(l + 1, r + 1) - delta;
            ans.push_back(res);
        }
        return ans;
    }
};
```


# Leetcode Weekly Contest 412

## 3266. Final Array State After K Multiplication Operations II

### Solution 1: exponentiation, min heap, greedy, m = 2, it will grow fast to reach max value of only 10^5
it will grow really fast to reach the mx value of 10^9, with m = 2, it can happen in at most 60 operations, so you have 60 * N log(60 * N)
Now you have an array where all the values if multiplied by the multiplier m would exceed the largest value in the array.
You will evenly distribute the remainder operations between each element in the array, why does this work, because every time you multiplied by multiplier
the value will become the next max, if you have it sorted from smallest to largest.  The smallest will take lead, then the second smallest takes lead and so on. 
Then in the next iteration it will be back in original order with same maximum as previously.  So you just need to figure out how many times you will perform operation on entire array given remaining k operations.  Then you will maybe have some remainder where you will perform k + 1 operations on the prefix of the array and k on the rest of the array. 


```cpp
long long exponentiation(long long b, long long p, long long m) {
    long long res = 1;
    while (p > 0) {
        if (p & 1) res = (res * b) % m;
        b = (b * b) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    const int M = 1e9 + 7;
    vector<int> getFinalState(vector<int>& nums, int k, int m) {
        if (m == 1) return nums; // trivial case
        int N = nums.size();
        long long mx = *max_element(nums.begin(), nums.end());
        // minheap
        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> minheap;
        for (int i = 0; i < N; i++) {
            minheap.emplace(nums[i], i);
        }
        vector<pair<long long, int>> res;
        while (!minheap.empty() && k > 0) {
            auto [val, i] = minheap.top();
            minheap.pop();
            // do something
            if (val * m <= mx) {
                minheap.emplace(val * m, i);
                k--;
            } else {
                res.emplace_back(val, i);
            }
        }
        while (!minheap.empty()) {
            auto [val, i] = minheap.top();
            minheap.pop();
            res.emplace_back(val, i);
        }
        sort(res.begin(), res.end());
        vector<int> ans(N);
        if (k == 0) {
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first % M;
            }
        } else {
            int rem = k % N;
            int div = k / N;
            for (int i = 0; i < N; i++) {
                ans[res[i].second] = res[i].first * exponentiation(m, div, M) % M;
            }
            for (int i = 0; i < rem; i++) {
                ans[res[i].second] = ((long long)ans[res[i].second] * m) % M;
            }                

        }
        return ans;
    }
};

```

## 3267. Count Almost Equal Pairs II

### Solution 1:  frequency map, set, try every single swap, need optimizations
This one is tricky, it only passes if you include the s[i] = s[j] skipping parts.  So you need some optimizations in your code to remove unnecessary looping.

```cpp
class Solution {
public:
    int M;
    unordered_set<int> get(string s) {
        unordered_set<int> res;
        res.insert(stoi(s));
        for (int i = 0; i < M; i++) {
            for (int j = i + 1; j < M; j++) {
                if (s[i] == s[j]) continue;
                swap(s[i], s[j]);
                res.insert(stoi(s));
                for (int k = 0; k < M; k++) {
                    for (int l = 0; l < M; l++) {
                        if (s[k] == s[l]) continue;
                        swap(s[k], s[l]);
                        res.insert(stoi(s));
                        swap(s[k], s[l]);
                    }
                }
                swap(s[i], s[j]);
            }
        }
        return res;
    }
    int countPairs(vector<int>& nums) {
        M = to_string(*max_element(nums.begin(), nums.end())).size();
        unordered_map<int, int> freq;
        int N = nums.size();
        int ans = 0;
        for (int i = 0; i < N; i++) {
            string s = to_string(nums[i]);
            s = string(M - s.size(), '0') + s;
            unordered_set<int> candidates = get(s);
            for (const int &cand : candidates) {
                ans += freq[cand];
            }
            freq[nums[i]]++;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 413

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 414

## 3281. Maximize Score of Numbers in Ranges

### Solution 1:  binary search, greedy, sort

```cpp
class Solution {
public:
    const long long INF = 1e12;
    bool possible(const vector<int>& start, long long d, long long target) {
        long long last = -INF;
        for (int s : start) {
            long long best = last + target;
            last = max(best, (long long)s);
            if (last > s + d) return false;
        }
        return true;
    }
    int maxPossibleScore(vector<int>& start, int d) {
        sort(start.begin(), start.end());
        long long lo = 0, hi = INF;
        while (lo < hi) {
            long long mid = lo + (hi - lo + 1) / 2;
            if (possible(start, d, mid)) lo = mid;
            else hi = mid - 1;
        }
        return lo;
    }
};
```

## 3282. Reach End of Array With Max Score

### Solution 1:  monotonic stack, dynamic programming, greedy

1. just need to greedily pick the pmax at each step.

```cpp
class Solution {
public:
    long long findMaximumScore(vector<int>& nums) {
        long long ans = 0, pmax = 0;
        for (int x : nums) {
            ans += pmax;
            pmax = max((long long)x, pmax);
        }
        return ans;
    }
};
```

## 3283. Maximum Number of Moves to Kill All Pawns

### Solution 1: bitmask dp, minimax algorithm, graph, precompute min knight distances, bfs

1. For it to be fast enough it has to precompute the min distance from each pawn and include the knight as a pawn. 
2. Then it just needs to compute the best option for dp state (idx, mask, ismax)

```cpp
#define x first
#define y second
const int M = 50, INF = 1e9, P = 15;
const vector<pair<int, int>> MOVES = {{-2, 1}, {-2, -1}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {1, 2}, {-1, 2}};
int N, end_mask;
vector<pair<int, int>> pos;
int dist[M][M][M][M], dp[P + 1][1 << P][2];
bool in_bounds(int x, int y) {
    return x >= 0 && x < M && y >= 0 && y < M;
}
void bfs(int kx, int ky) {
    queue<pair<int, int>> q;
    q.emplace(kx, ky);
    dist[kx][ky][kx][ky] = 0;
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        for (auto [dx, dy] : MOVES) {
            int nx = x + dx, ny = y + dy;
            if (in_bounds(nx, ny) && dist[kx][ky][nx][ny] == -1) {
                dist[kx][ky][nx][ny] = dist[kx][ky][x][y] + 1;
                q.emplace(nx, ny);
            }
        }
    }
}
int minimax(int idx, int mask, bool ismax) {
    auto [x, y] = pos[idx];
    if (mask == end_mask) return 0;
    if (dp[idx][mask][ismax] != -1) return dp[idx][mask][ismax];
    int ans = ismax ? 0 : INF;
    for (int i = 0; i < N; i++) {
        if ((mask >> i) & 1) continue;
        if (ismax) {
            ans = max(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        } else {
            ans = min(ans, dist[x][y][pos[i].x][pos[i].y] + minimax(i, mask | (1 << i), ismax ^ 1));
        }
    }
    return dp[idx][mask][ismax] = ans;
}
class Solution {
public:
    int maxMoves(int kx, int ky, vector<vector<int>>& poss) {
        N = poss.size();
        pos.resize(N);
        for (int i = 0; i < N; i++) {
            pos[i].x = poss[i][0], pos[i].y = poss[i][1];
        }
        pos.emplace_back(kx, ky);
        memset(dist, -1, sizeof(dist));
        for (const auto &[x, y] : pos) {
            bfs(x, y);
        }
        memset(dp, -1, sizeof(dp));
        end_mask = (1 << N) - 1;
        return minimax(N, 0, true); // (idx, mask, ismax)
    }
};
```

# Leetcode Weekly Contest 415

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 416

## Minimum Number of Seconds to Make Mountain Height Zero

### Solution 1:  greedy, binary search, quadratic formula, math

1. Binary search for how many seconds it will take for the workers to reach the target height. 
2. For each fixed t seconds, it will calculate how much height each worker will reduce.
3. So in binary search you will get FFFTTTTT, that is the first T is the minimum time it takes to reduce the height to 0.  So just binary search for that. 
4. In order to compute how much height each worker reduces it is related to a quadratic equation.  So you can determine how much height each reduce the mountain by.


```cpp
class Solution {
public:
    long long calc(long long worker, long long target) {
        if (worker == 0) return 0;
        long long discriminant = 1 + 8LL * target / worker;
        long long sqrt_discriminant = (long long)sqrt(discriminant);
        long long ans = (sqrt_discriminant - 1) / 2;
        return ans;
    }
    vector<long long> workers;
    int H, N;
    bool possible(long long target) {
        long long total = 0;
        for (int i = 0; i < N; i++) {
            total += calc(workers[i], target);
            if (total >= H) return true;
        }
        return false;
    }
    long long minNumberOfSeconds(int height, vector<int>& workerTimes) {
        N = workerTimes.size();
        H = height;
        workers = vector<long long>(workerTimes.begin(), workerTimes.end());
        long long lo = 0, hi = 1e16;
        while (lo < hi) {
            long long mid = lo + (hi - lo) / 2;
            if (possible(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }
};
```

## Count Substrings That Can Be Rearranged to Contain a String II

### Solution 1:  sliding window, frequency, two pointers

```cpp
class Solution {
public:
    long long validSubstringCount(string word1, string word2) {
        int N = word1.size();
        vector<long long> freq(26, 0);
        long long need = 0;
        for (char c : word2) {
            if (freq[c - 'a'] == 0) {
                need++;
            }
            freq[c - 'a']++;
        }
        long long ans = 0;
        for (int l = 0, r = 0; r < N; r++) {
            int v = word1[r] - 'a';
            freq[v]--;
            if (freq[v] == 0) {
                need--;
            }
            while (need == 0) {
                int u = word1[l] - 'a';
                if (freq[u] == 0) break;
                freq[u]++;
                l++;
            }
            if (need == 0) {
                ans += l + 1;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 417

## 3306. Count of Substrings Containing Every Vowel and K Consonants II

### Solution 1:  sliding window, string, frequency array, prefix sum

1. A window is valid whenever the number of consonants is less than or equal to k and all vowels are contained. 
1. You track number of vowels needed with `need` variable, and also track number of consonants with `cnt` variable.
1. If it ever exceeds the count you need to move left pointer until you get it back to being equal.  
1. And you also track how many vowels are needed in this new windows.

```cpp
class Solution {
public:
    const string VOWELS = "aeiou";
    int coefficient(char ch) {
        return ch - 'a';
    }
    bool isVowel(char ch) {
        return VOWELS.find(ch) != string::npos;
    }
    long long countOfSubstrings(string word, int k) {
        int N = word.size();
        vector<long long> freq(26, 0);
        int need = 5, cnt = 0;
        vector<long long> psum(N + 1, 0);
        for (int i = 0; i < N; i++) {
            psum[i + 1] = psum[i];
            if (!isVowel(word[i])) {
                psum[i + 1]++;
            }
        }
        long long ans = 0;
        for (int l = 0, r = 0; r < N; r++) {
            int c = coefficient(word[r]);
            freq[c]++;
            if (!isVowel(word[r])) {
                cnt++;
            } else if (isVowel(word[r]) && freq[c] == 1) {
                need--;
            }
            while (cnt > k) {
                int coef = coefficient(word[l]);
                freq[coef]--;
                if (isVowel(word[l])) {
                    if (freq[coef] == 0) need++;
                } else {
                    cnt--;
                }
                l++;
            }
            if (need > 0) continue;
            while (true) {
                int v = coefficient(word[l]);
                if (!isVowel(word[l])) cnt--;
                if (isVowel(word[l]) && freq[v] == 1) break;
                freq[v]--;
                l++;
            }
            if (psum[r + 1] < k) continue;
            int ub = lower_bound(psum.begin(), psum.end(), psum[r + 1] - k + 1) - psum.begin();
            ub = min(ub, l + 1);
            int lb = lower_bound(psum.begin(), psum.end(), psum[r + 1] - k) - psum.begin();
            ans += ub - lb;
        }
        return ans;
    }
};
```

### Solution 2: sliding window, different, at least k consonants.

create a function that counts the number of substrings where count of consonants is greater than or equal to k.

f(k) - f(k + 1)

```cpp
class Solution {
public:
    const string VOWELS = "aeiou";
    int coefficient(char ch) {
        return ch - 'a';
    }
    bool isVowel(char ch) {
        return VOWELS.find(ch) != string::npos;
    }
    long long countGreaterThanK(string word, int k) {
        int N = word.size();
        vector<long long> freq(26, 0);
        int need = 5, cnt = 0;
        long long ans = 0;
        for (int l = 0, r = 0; l < N; l++) {
            while (r < N && (need > 0 || cnt < k)) {
                int v = coefficient(word[r]);
                freq[v]++;
                if (!isVowel(word[r])) {
                    cnt++;
                } else if (freq[v] == 1) {
                    need--;
                }
                r++;
            }
            if (need == 0 && cnt >= k) ans += N - r + 1;
            int v = coefficient(word[l]);
            freq[v]--;
            if (!isVowel(word[l])) {
                cnt--;
            } else if (freq[v] == 0) {
                need++;
            }
        }
        return ans;
    }
    long long countOfSubstrings(string word, int k) {
        return countGreaterThanK(word, k) - countGreaterThanK(word, k + 1);
    }
};
```

## 3307. Find the K-th Character in String Game II

### Solution 1: bit manipulation, recursive, powers of two

```cpp
class Solution {
public:
    char kthCharacter(long long k, vector<int>& operations) {
        int i = log2(k);
        int cnt = 0;
        while (k > 1) {
            if (k > (1LL << i)) {
                cnt += operations[i];
                k -= (1LL << i);
            }
            i--;
        }
        return 'a' + (cnt % 26);
    }
};
```

# Leetcode Weekly Contest 418

## 3310. Remove Methods From Project

### Solution 1:  dfs, directed graph

```cpp
class Solution {
public:
    vector<bool> sus;
    vector<vector<int>> adj;
    void dfs(int u) {
        if (sus[u]) return;
        sus[u] = true;
        for (int v : adj[u]) {
            dfs(v);
        }
    }
    vector<int> remainingMethods(int n, int k, vector<vector<int>>& invocations) {
        adj.assign(n, vector<int>());
        for (const auto &e : invocations) {
            int u = e[0], v = e[1];
            adj[u].push_back(v);
        }
        sus.assign(n, false);
        dfs(k);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            if (sus[i]) continue;
            for (int j : adj[i]) {
                if (sus[j]) {
                    ans.resize(n);
                    iota(ans.begin(), ans.end(), 0);
                    return ans;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (sus[i]) continue;
            ans.push_back(i);
        }
        return ans;
    }
};
```

## 3311. Construct 2D Grid Matching Graph Layout

### Solution 1:  construction, undirected graph

```cpp
class Solution {
public:
    vector<vector<int>> constructGridLayout(int n, vector<vector<int>>& edges) {
        int N = edges.size();
        vector<int> deg(n, 0);
        vector<unordered_set<int>> adj(n, unordered_set<int>());
        for (const auto &e : edges) {
            int u = e[0], v = e[1];
            deg[u]++;
            deg[v]++;
            adj[u].insert(v);
            adj[v].insert(u);
        }
        int mindeg = *min_element(deg.begin(), deg.end());
        int u;
        for (int i = 0; i < n; i++) {
            if (deg[i] == mindeg) {
                u = i;
                break;
            }
        }
        int r = 0, c = 0, R = 0, C = 0;
        vector<vector<int>> grid;
        while (n--) {
            if (r == grid.size()) grid.push_back({});
            grid[r].push_back(u);
            deg[u] = 0;
            bool corner = false;
            bool stuck = true;
            for (int v : adj[u]) {
                if (deg[v] != mindeg) continue;
                if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                u = v;
                corner = true;
                stuck = false;
                break;
            }
            if (!corner) {
                for (int v : adj[u]) {
                    if (deg[v] != mindeg + 1) continue;
                    if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                    u = v;
                    stuck = false;
                }
            }
            if (stuck) {
                for (int v : adj[u]) {
                    if (!deg[v]) continue;
                    if (r > 0 && c + 1 < C && !adj[grid[r - 1][c + 1]].contains(v)) continue;
                    u = v;
                    stuck = false;
                }
            }
            c++;
            if (r == 0) C = c + 1;
            if (corner || (r > 0 && c + 1 == C)) {
                deg[u] = 0;
                grid[r].push_back(u);
                n--;
                r++;
                c = 0;
                u = grid[r - 1][c];
                for (int v : adj[u]) {
                    if (!deg[v]) continue;
                    u = v;
                    break;
                }
            }
        }
        return grid;
    }
};
```

## 3312. Sorted GCD Pair Queries

### Solution 1:  inclusion-exclusion principle, gcd, counting divisors, prefix sums, binary search

```cpp
const int MAXN = 50'001;
long long divcount[MAXN], gcdcount[MAXN];

long long choose(long long n) {
    return n * (n - 1) / 2;
}
class Solution {
private:
    static vector<int> divisors[MAXN];
    static bool precomputed;
    static void precompute() {
        if (precomputed) return;
        for (int x = 1; x < MAXN; x++) {
            for (int y = x; y < MAXN; y += x) {
                divisors[y].push_back(x);
            }
        }
        precomputed = true;
    }
public:
    vector<int> gcdValues(vector<int>& nums, vector<long long>& queries) {
        precompute();
        int N = nums.size(), M = queries.size();
        int MX = *max_element(nums.begin(), nums.end());
        memset(divcount, 0, sizeof(divcount));
        memset(gcdcount, 0, sizeof(gcdcount));
        unordered_map<int, int> freq;
        for (int x : nums) {
            freq[x]++;
        }
        for (const auto &[k, v] : freq) {
            for (int d : divisors[k]) {
                divcount[d] += v;
            }
        }
        vector<int> gcdvals;
        for (int g = MX; g >= 0; g--) {
            if (divcount[g] <= 1) continue;
            gcdcount[g] = choose(divcount[g]);
            for (int gg = 2 * g; gg <= MX; gg += g) {
                gcdcount[g] -= gcdcount[gg];
            }
            gcdvals.push_back(g);
        }
        reverse(gcdvals.begin(), gcdvals.end());
        vector<long long> psum(gcdvals.size(), 0);
        for (int i = 0; i < gcdvals.size(); i++) {
            psum[i] = gcdcount[gcdvals[i]];
            if (i > 0) psum[i] += psum[i - 1];
        }
        vector<int> ans(M, 0);
        for (int i = 0; i < M; i++) {
            int idx = lower_bound(psum.begin(), psum.end(), queries[i] + 1) - psum.begin();
            ans[i] = gcdvals[idx];
        }
        return ans;
    }
};
vector<int> Solution::divisors[MAXN];
bool Solution::precomputed = false;
```

# Leetcode Weekly Contest 419

## 3319. K-th Largest Perfect Subtree Size in Binary Tree

### Solution 1:  postorder dfs, perfect binary tree, sorting

```cpp
class Solution {
public:
    vector<int> sizes;
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;
        int left = dfs(root -> left), right = dfs(root -> right);
        if (left == -1 || right == -1 || left != right) return -1;
        sizes.push_back(left + right + 1);
        return left + right + 1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sizes.rbegin(), sizes.rend());
        return k <= sizes.size() ? sizes[k - 1] : -1;
    }
};
```

## 3320. Count The Number of Winning Sequences

### Solution 1:  recursive dynamic programming, counting

```cpp
const long long MOD = 1e9 + 7;
const string CHARS = "FWE";
class Solution {
public:
    int N;
    string S;
    vector<vector<long long>> dp[4];
    // score of a compared to b
    bool score(char a, char b) {
        if (a == 'F' && b =='E') return true;
        if (a == 'E' && b == 'W') return true;
        if (a == 'W' && b == 'F') return true;
        return false;
    }
    long long dfs(int idx, int pts, int last) {
        if (idx == N) {
            return pts > N ? 1 : 0;
        }
        if (dp[last][idx][pts] != -1) return dp[last][idx][pts];
        long long ans = 0;
        // pick characters for bob
        for (int i = 0; i < 3; i++) {
            if (i == last) continue;
            if (score(CHARS[i], S[idx])) {
                ans = (ans + dfs(idx + 1, pts + 1, i)) % MOD;
            } else if (score(S[idx], CHARS[i])) {
                ans = (ans + dfs(idx + 1, pts - 1, i)) % MOD;
            } else {
                ans = (ans + dfs(idx + 1, pts, i)) % MOD;
            }
        }
        return dp[last][idx][pts] = ans;
    }
    int countWinningSequences(string s) {
        N = s.size();
        for (int i = 0; i < 4; i++) {
            dp[i].assign(N, vector<long long>(2 * N + 1, -1));
        }
        S = s;
        return dfs(0, N, 3);
    }
};
```

## 3321. Find X-Sum of All K-Long Subarrays II

### Solution 1:  fixed sized window, minheap, maxheap, frequency map, set

```cpp
class Solution {
public:
    priority_queue<pair<long long, long long>> maxheap;
    priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> minheap;
    unordered_set<long long> window;
    unordered_map<long long, long long> freq;
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        long long wsum = 0;
        int N = nums.size();
        vector<long long> ans(N - k + 1);
        for (int i = 0; i < N; i++) {
            long long v = nums[i];
            freq[v]++;
            if (window.size() < x || window.count(nums[i])) {
                wsum += v;
                window.insert(v);
                minheap.emplace(freq[v], v);
            } else {
                while (!minheap.empty() && (freq[minheap.top().second] != minheap.top().first || !window.count(minheap.top().second))) minheap.pop();
                if (!minheap.empty() && (freq[v] > minheap.top().first || (freq[v] == minheap.top().first && v > minheap.top().second))) {
                    auto [f, p] = minheap.top();
                    // removal from window
                    minheap.pop();
                    wsum -= p * f;
                    window.erase(p);
                    maxheap.emplace(f, p);
                    // add the new element into the window
                    wsum += v * freq[v];
                    window.insert(v);
                    minheap.emplace(freq[v], v);
                } else {
                    maxheap.emplace(freq[v], v);
                }
            }
            if (i >= k - 1) {
                ans[i - k + 1] = wsum;
                v = nums[i - k + 1];
                freq[v]--;
                if (window.count(v)) {
                    wsum -= v;
                    while (!maxheap.empty() && (freq[maxheap.top().second] != maxheap.top().first || window.count(maxheap.top().second))) maxheap.pop();
                    if (!maxheap.empty() && (freq[v] < maxheap.top().first || (freq[v] == maxheap.top().first && v < maxheap.top().second))) {
                        // remove value from window
                        window.erase(v);
                        wsum -= freq[v] * v;
                        if (freq[v] > 0) maxheap.emplace(freq[v], v);
                        // add old value into window
                        auto [f, p] = maxheap.top();
                        maxheap.pop();
                        window.insert(p);
                        wsum += f * p;
                        minheap.emplace(f, p);
                    } else if (freq[v] == 0) {
                        window.erase(v);
                    } else {
                        minheap.emplace(freq[v], v);
                    }
                } else {
                    maxheap.emplace(freq[v], v);
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 420

## 3325. Count Substrings With K-Frequency Characters I

### Solution 1:  sliding window, frequency array

```cpp
class Solution {
public:
    int unicode(char ch) {
        return ch - 'a';
    }
    int freq[26];
    int numberOfSubstrings(string s, int k) {
        int N = s.size();
        bool found = false;
        int ans = 0;
        for (int i = 0, j = 0; i < N; i++) {
            int c = unicode(s[i]);
            freq[c]++;
            found |= (freq[c] == k);
            while (freq[c] == k) {
                freq[unicode(s[j])]--;
                j++;
            }
            if (found) ans += j;
        }
        return ans;
    }
};
```

## 3326. Minimum Division Operations to Make Array Non Decreasing

### Solution 1:  static precomputation, prime sieve to get smallest prime factor, greedy

```cpp
class Solution {
private:
    static bool precomputed;
    static const int MAXN = 1e6 + 5;
    static int spf[MAXN];
    // nloglog(n)
    static void sieve(int n) {
        if (precomputed) return;
        for (int i = 0; i < n; i++) {
            spf[i] = i;
        }
        for (int i = 2; i < n; i++) {
            if (spf[i] != i) continue;
            for (long long j = (long long)i * i; j < n; j += i) {
                if (spf[j] != j) continue;
                spf[j] = i;
            }
        }
        precomputed = true;
    }
public:
    int minOperations(vector<int>& nums) {
        sieve(MAXN);
        int thres = MAXN;
        int ans = 0;
        reverse(nums.begin(), nums.end());
        for (int x : nums) {
            if (x > thres && spf[x] > thres) return -1;
            if (x > thres) {
                ans++;
                x = spf[x];
            }
            thres = min(thres, x);
        }
        return ans;
    }
};
int Solution::spf[MAXN];
bool Solution::precomputed = false;
```

## 3327. Check if DFS Strings Are Palindromes

### Solution 1:  post order traversal, tree, dfs, tree counter, manacher's algorithm, palindromic range queries

1. Important to get the string in the post order traversal of the tree.
1. That way you can query the ranges based on the post order traversal of the tree.
1. perform palindromic range queries using precomputation by manacher's algorithm.

```cpp
class Solution {
public:
    vector<vector<int>> adj;
    int counter;
    vector<bool> ans;
    vector<int> marr, remap;
    vector<int> manacher(const string& s) {
        string t = "#";
        for (char ch : s) {
            t += ch;
            t += "#";
        }
        vector<int> parr = manacher_odd(t);
        return parr;
    }
    vector<int> manacher_odd(string& s) {
        int N = s.size();
        s = "$" + s + "^";
        vector<int> P(N + 2, 0);
        int l = 1, r = 1;
        for (int i = 1; i <= N; i++) {
            P[i] = max(0, min(r - i, P[l + (r - i)]));
            while (s[i - P[i]] == s[i + P[i]]) {
                P[i]++;
            }
            if (i + P[i] > r) {
                l = i - P[i];
                r = i + P[i];
            }
        }
        return vector<int>(P.begin() + 1, P.end() - 1);
    }
    // [l, r)
    bool query(int l, int r) {
        return marr[l + r] > r - l;
    }
    void dfs1(int u) {
        for (int v : adj[u]) {
            dfs1(v);
        }
        remap[counter] = u;
        counter++;
    }
    void dfs(int u) {
        int start = counter;
        for (int v : adj[u]) {
            dfs(v);
        }
        counter++;
        ans[u] = query(start, counter);
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int N = s.size();
        adj.assign(N, vector<int>());
        for (int i = 1; i < N; i++) {
            adj[parent[i]].emplace_back(i);
        }
        counter = 0;
        remap.assign(N, 0);
        dfs1(0);
        string t = "";
        for (int i : remap) {
            t += s[i];
        }
        marr = manacher(t);
        counter = 0;
        ans.assign(N, false);
        dfs(0);
        return ans;
    }
};
```

# Leetcode Weekly Contest 421

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 422

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```