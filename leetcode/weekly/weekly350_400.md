# Leetcode Weekly Contest 350 - 399

# Leetcode Weekly Contest 372

## 2939. Maximum Xor Product

### Solution 1:  bit manipulation

```py
class Solution:
    def maximumXorProduct(self, a: int, b: int, n: int) -> int:
        mod = int(1e9) + 7
        for i in range(n):
            a_bit = (a >> i) & 1
            b_bit = (b >> i) & 1
            mask = (1 << i)
            # print("i, mask", i, mask)
            if a_bit == b_bit == 0:
                a ^= mask
                b ^= mask
            elif a_bit == 0 and b_bit == 1 and b >= a + mask:
                a ^= mask
                b ^= mask
            elif a_bit == 1 and b_bit == 0 and a >= b + mask:
                a ^= mask
                b ^= mask
            # print("a, b", a, b)
        res = (a * b) % mod
        return res
```

## 2940. Find Building Where Alice and Bob Can Meet

### Solution 1:  monotonic stack, binary search, offline queries

```cpp
class Solution {
private:
    vector<int> heights;
    int search(const vector<int> &monoStack, int height) {
        int lo = 0, hi = monoStack.size() - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (heights[monoStack[mid]] > height) lo = mid;
            else hi = mid - 1;
        }
        return monoStack[lo];
    }
public:
    vector<int> leftmostBuildingQueries(vector<int>& H, vector<vector<int>>& queries) {
        heights = H;
        int N = heights.size(), M = queries.size();
        vector<vector<pair<int, int>>> preQueries(N, vector<pair<int, int>>());
        vector<int> ans(M, -1);
        for (int i = 0; i < M; i++) {
            int u = queries[i][0], v = queries[i][1];
            if (u > v) swap(u, v);
            if (u == v || heights[v] > heights[u]) ans[i] = v;
            else preQueries[v].emplace_back(i, max(heights[u], heights[v]));
        }
        vector<int> monoStack;
        for (int i = N - 1; i >= 0; i--) {
            while (!monoStack.empty() && heights[i] >= heights[monoStack.back()]) monoStack.pop_back();
            for (const auto &[idx, h]: preQueries[i]) {
                if (monoStack.empty() || h >= heights[monoStack.front()]) continue;
                int j = search(monoStack, h);
                ans[idx] = j;
            }
            monoStack.emplace_back(i);
        }
        return ans;
    }
};
```

### Solution 2:  min heap, greedy, offline queries

```cpp
class Solution {
public:
    vector<int> leftmostBuildingQueries(vector<int>& heights, vector<vector<int>>& queries) {
        int N = heights.size(), M = queries.size();
        vector<vector<pair<int, int>>> preQueries(N, vector<pair<int, int>>());
        vector<int> ans(M, -1);
        for (int i = 0; i < M; i++) {
            int u = queries[i][0], v = queries[i][1];
            if (u > v) swap(u, v);
            if (u == v || heights[v] > heights[u]) ans[i] = v;
            else preQueries[v].emplace_back(i, max(heights[u], heights[v]));
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minheap;
        for (int i = 0; i < N; i++) {
            while (!minheap.empty() && minheap.top().first < heights[i]) {
                ans[minheap.top().second] = i;
                minheap.pop();
            }
            for (const auto &[idx, h]: preQueries[i]) {
                minheap.emplace(h, idx);
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 378

## 2983. Palindrome Rearrangement Queries

### Solution 1: prefix sum, character counting, palindrome, reverse, symmetry, range overlap, range queries

1. Split s into two halves, reverse the right half to align mirror positions, build 26-wide prefix-sum tables for both halves plus a prefix of pairwise mismatches to quickly test if untouched regions already match.
2. For each query [a, b, d, c], mirror (c, d) into the left-half index space, find the overlap [l, r], and first reject if any positions outside the edited segments or in the gap between them still mismatch using the mismatch prefix.
3. Compute character frequencies for [a, b] and [c, d] via prefix sums, then “update” subtracts counts from the non-overlapping subintervals so only the swapped parts remain. Validate counts are nonnegative and equal to confirm a palindrome is achievable. Time is O(N·26) preprocessing and O(26) per query, space is O(N·26).

```cpp
class Solution {
private:
    vector<vector<int>> getPrefixSum(const string& s) {
        // index, character
        int N = s.size();
        vector<vector<int>> ps(N, vector<int>(26, 0));
        for (int i = 0; i < N; ++i) {
            ps[i][s[i] - 'a'] = 1;
            if (i > 0) {
                for (int j = 0; j < 26; ++j) {
                    ps[i][j] += ps[i - 1][j];
                }
            }
        }
        return ps;
    }
    int deltaInRange(const vector<int>& pref, int l, int r) {
        if (l > r) return 0;
        int ans = pref[r];
        if (l > 0) ans -= pref[l - 1];
        return ans;
    }
    vector<int> charFreq(const vector<vector<int>>& pref, int l, int r) {
        vector<int> ans(26, 0);
        for (int i = 0; i < 26; ++i) {
            ans[i] = pref[r][i];
            if (l > 0) ans[i] -= pref[l - 1][i];
        }
        return ans;
    }
    void update(vector<int>& freq, int s, int e, int l, int r, const vector<vector<int>>& pref) {
        vector<pair<int, int>> intervals;
        if (l <= r && s < l) {
            intervals.emplace_back(s, l - 1);
        }
        if (l <= r && e > r) {
            intervals.emplace_back(r + 1, e);
        }
        if (l > r) {
            intervals.emplace_back(s, e);
        }
        for (const auto& [i, j] : intervals) {
            vector<int> f = charFreq(pref, i, j);
            for (int k = 0; k < 26; ++k) {
                freq[k] -= f[k];
            }
        }
    }
    bool isValid(const vector<int>& arr) {
        return all_of(arr.begin(), arr.end(), [](const int x) {
            return x >= 0;
        });
    }
public:
    vector<bool> canMakePalindromeQueries(string s, vector<vector<int>>& queries) {
        string s1 = s.substr(0, s.size() / 2), s2 = s.substr(s.size() / 2);
        reverse(s2.begin(), s2.end());
        int N = s1.size();
        vector<int> prefDiff(N, 0);
        for (int i = 0; i < N; ++i) {
            prefDiff[i] = s1[i] != s2[i];
            if (i > 0) prefDiff[i] += prefDiff[i - 1];
        }
        vector<vector<int>> ps1 = getPrefixSum(s1), ps2 = getPrefixSum(s2);
        int M = queries.size();
        vector<bool> ans(M, false);
        for (int i = 0; i < M; ++i) {
            vector<int>& query = queries[i];
            int a = query[0], b = query[1], d = query[2], c = query[3];
            c = 2 * N - c - 1, d = 2 * N - d - 1;
            int l = max(a, c), r = min(b, d);
            // 1st check
            if (deltaInRange(prefDiff, 0, min(a, c) - 1) || deltaInRange(prefDiff, max(b, d) + 1, N - 1) || deltaInRange(prefDiff, r + 1, l - 1)) {
                continue;
            }
            // 2nd check
            vector<int> f1 = charFreq(ps1, a, b), f2 = charFreq(ps2, c, d);
            update(f1, a, b, l, r, ps2);
            update(f2, c, d, l, r, ps1);
            if (!isValid(f1) || !isValid(f2) || f1 != f2) continue;
            ans[i] = true;
        }
        return ans;
    }
};
```