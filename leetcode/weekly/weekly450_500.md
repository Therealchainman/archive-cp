# Leetcode Weekly Contest 450-499

# Leetcode Weekly Contest 450

## Minimum Swaps to Sort by Digit Sum

### Solution 1:  permutation cycles, swaps, disjoint sets

```cpp
struct Item {
    int dsum, val, idx;
    Item(int dsum, int val, int idx) : dsum(dsum), val(val), idx(idx) {}
    bool operator<(const Item &other) const {
        if (dsum != other.dsum) return dsum < other.dsum;
        return val < other.val;
    }
};
class Solution {
private:
    int digitSum(int x) {
        int ans = 0;
        while (x > 0) {
            ans += x % 10;
            x /= 10;
        }
        return ans;
    }
public:
    int minSwaps(vector<int>& nums) {
        int N = nums.size();
        vector<Item> arr;
        for (int i = 0; i < N; i++) {
            arr.emplace_back(digitSum(nums[i]), nums[i], i);
        }
        sort(arr.begin(), arr.end());
        vector<int> out(N, 0);
        vector<bool> vis(N, false);
        for (int i = 0; i < N; i++) {
            out[i] = arr[i].idx;
        }
        int ans = 0;
        for (int i = 0; i < N; i++) {
            if (vis[i]) continue;
            int sz = 0, u = i;
            while (!vis[u]) {
                vis[u] = true;
                sz++;
                u = out[u];
            }
            ans += sz - 1;
        }
        return ans;
    }
};
```

## Grid Teleportation Traversal

### Solution 1: 0-1 bfs, deque, distances

```cpp
const int INF = 1e9;
class Solution {
private:
    int R, C;
    vector<pair<int, int>> neighborhood(int r, int c) {
        return {{r - 1, c}, {r + 1, c}, {r, c - 1}, {r, c + 1}};
    }
    bool inBounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    int decode(char ch) {
        return ch - 'A';
    }
public:
    int minMoves(vector<string>& grid) {
        R = grid.size(), C = grid[0].size();
        vector<vector<int>> dist(R, vector<int>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dist[0][0] = 0;
        vector<vector<pair<int, int>>> portals(26);
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (grid[r][c] >= 'A' && grid[r][c] <= 'Z') portals[decode(grid[r][c])].emplace_back(r, c);
            }
        }
        deque<pair<int, int>> dq;
        dq.emplace_back(0, 0);
        while (!dq.empty()) {
            auto [r, c] = dq.front();
            dq.pop_front();
            if (r == R - 1 && c == C - 1) return dist[r][c];
            for (auto [nr, nc] : neighborhood(r, c)) {
                if (!inBounds(nr, nc) || grid[nr][nc] == '#' || dist[r][c] + 1 >= dist[nr][nc]) continue;
                dist[nr][nc] = dist[r][c] + 1;
                dq.emplace_back(nr, nc);
            }
            if (grid[r][c] >= 'A' && grid[r][c] <= 'Z') {
                if (vis[r][c]) continue;
                vis[r][c] = true;
                for (auto [nr, nc] : portals[decode(grid[r][c])]) {
                    if (dist[r][c] < dist[nr][nc]) {
                        vis[nr][nc] = true;
                        dist[nr][nc] = dist[r][c];
                        dq.emplace_front(nr, nc);
                    }
                }
            }
        }
        return -1;
    }
};
```

## Minimum Weighted Subgraph With the Required Paths II

### Solution 1: minimum spanning tree of three nodes, three nodes, binary jumping, lca, depth, dfs, root distance


### Step 1: The Minimal Subtree
- In a tree, there's exactly one unique path between any pair of nodes.
- The minimal subtree `S` connecting nodes `{A, B, C}` is the **union** of the three simple paths:
  - `P_AB`: the path from A to B
  - `P_BC`: the path from B to C
  - `P_CA`: the path from C to A

This subtree `S` is connected and contains all nodes and edges needed to reach any of the three nodes from the others.

---

### Step 2: Consider Any Edge in the Subtree

Pick any edge `e` in `S`, with weight `w`.

Removing `e` splits the tree (and thus `S`) into two parts: say `X` and `Y`.

Since `S` contains exactly the nodes `{A, B, C}`, those nodes must be split between `X` and `Y`.

**Observation:**  
- One part must contain **exactly one** of the three nodes, and the other must contain the other two.
- For example, suppose:
  - `A` is in `X`
  - `B` and `C` are in `Y`

---

### Step 3: Count How Often `e` Is Used

In this situation:

- The path `A → B` **must** cross `e` → counted once
- The path `A → C` **must** cross `e` → counted again
- The path `B → C` stays entirely in `Y` → does **not** use `e`

So edge `e` is included in **exactly 2** of the 3 pairwise paths among `{A, B, C}`.

---

### Step 4: Generalize to All Edges

Every edge `e` in the minimal subtree `S` will separate one node from the other two (because the tree is acyclic and connected). So, **every edge in `S` is used in exactly 2 of the 3 distances**:

- `dist(A, B)`
- `dist(B, C)`
- `dist(C, A)`

Thus:

```cpp
struct Tree {
    int N, LOG;
    vector<vector<pair<int,int>>> adj;
    vector<int> depth, parent, dist;
    vector<vector<int>> up;

    Tree(int n) : N(n) {
        LOG = 20;
        adj.assign(N, vector<pair<int, int>>());
        depth.assign(N, 0);
        parent.assign(N, -1);
        dist.assign(N, 0);
        up.assign(LOG, vector<int>(N, -1));
    }
    void addEdge(int u, int v, int w = 1) {
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    void preprocess(int root = 0) {
        dfs(root);
        buildLiftingTable();
    }
    int kthAncestor(int u, int k) const {
        for (int i = 0; i < LOG && u != -1; i++) {
            if ((k >> i) & 1) {
                u = up[i][u];
            }
        }
        return u;
    }
    int lca(int u, int v) const {
        if (depth[u] < depth[v]) swap(u, v);
        // Bring u up to the same depth as v
        u = kthAncestor(u, depth[u] - depth[v]);
        if (u == v) return u;
        // Binary lift both
        for (int i = LOG - 1; i >= 0; i--) {
            if (up[i][u] != up[i][v]) {
                u = up[i][u];
                v = up[i][v];
            }
        }
        // Now parents are equal
        return parent[u];
    }
    int distance(int u, int v) const {
        int a = lca(u, v);
        return dist[u] + dist[v] - 2 * dist[a];
    }
private:
    void dfs(int u, int p = -1) {
        parent[u] = p;
        up[0][u] = p;
        for (auto &[v, w] : adj[u]) {
            if (v == p) continue;
            depth[v] = depth[u] + 1;
            dist[v] = dist[u] + w;
            dfs(v, u);
        }
    }
    void buildLiftingTable() {
        for (int i = 1; i < LOG; i++) {
            for (int j = 0; j < N; j++) {
                if (up[i - 1][j] == -1) continue;
                up[i][j] = up[i - 1][up[i - 1][j]];
            }
        }
    }
};
class Solution {
public:
    vector<int> minimumWeight(vector<vector<int>>& edges, vector<vector<int>>& queries) {
        int N = edges.size() + 1;
        Tree tree(N);
        for (const vector<int> &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            tree.addEdge(u, v, w);
        }
        tree.preprocess();
        vector<int> ans;
        for (const vector<int> &query : queries) {
            int u = query[0], v = query[1], d = query[2];
            int du = tree.distance(u, d), dv = tree.distance(v, d), duv = tree.distance(u, v);
            int res = (du + dv + duv) / 2;
            ans.emplace_back(res);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 451

## 3563. Lexicographically Smallest String After Adjacent Removals

### Solution 1: interval dp, lexicographically smallest

The algorithm uses 2D dynamic programming to mark erasable substrings and 1D DP to construct the optimal string.
The lexicographical optimization is greedy but bounded by valid erase operations.

Interval feasibility DP (canErase)
- Many string-erase or bracket-matching problems reduce to asking “can this substring be fully removed?” That’s a classic interval DP: build up from small intervals (length 2) to larger ones, checking:
- Direct removal (pair of characters),
- Nested removal (peel off outer pair and rely on inner),
- Concatenation (split into two erasable pieces).

Suffix optimization DP (dp)
- Once we know which substrings we’re free to drop, the remaining task reduces to “choose which erasable blocks to remove so that what’s left is lexicographically smallest.” That’s a linear DP over suffixes, where at each position you make the optimal local choice (erase or keep) and rely on already computed optimal answers for the remainder.

```cpp
class Solution {
private:
    int absDistance(char a, char b) {
        return abs(a - b);
    }
public:
    string lexicographicallySmallestString(string s) {
        int N = s.size();
        vector<vector<bool>> canErase(N + 1, vector<bool>(N + 1, false));
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j += 2) {
                int dist = absDistance(s[i], s[j]);
                if (dist == 1 || dist == 25) {
                    if (j - i + 1 == 2) canErase[i][j] = true;
                    else if (canErase[i + 1][j - 1]) canErase[i][j] = true;
                }
                for (int k = i + 1; k < j; k++) {
                    if (canErase[i][k] && canErase[k + 1][j]) canErase[i][j] = true;
                }
            }
        }
        vector<string> dp(N + 1);
        for (int i = N - 1; i >= 0; i--) {
            string ans = s.substr(i, N);
            for (int j = i; j < N; j++) {
                string cand = "";
                if (!canErase[i][j]) cand = s.substr(i, j - i + 1);
                cand += dp[j + 1];
                ans = min(ans, cand);
            }
            dp[i] = ans;
        }
        return dp[0];
    }
};
```

## 3562. Maximum Profit from Trading Stocks with Discounts

### Solution 1: knapsack convolution, tree shaped knapsack, dp on tree, dfs

## Overview

This algorithm addresses a **resource allocation problem** over a **hierarchical tree of projects**. Each node represents a project characterized by:

- **Cost** (current investment)  
- **Gain** (future return)

Given a **global budget constraint**, the goal is to **maximize total profit** by selectively investing in projects. Some projects may be executed at a **discounted cost**, and investments must respect **hierarchical dependencies**

---

## Key Concepts

### Tree Hierarchy  
Projects form a **rooted tree**, where investing in a project is only valid if its parent has already been processed (i.e., considered for investment). This enforces a top-down dependency structure.

### Dynamic Programming (DP)  
The algorithm performs a **bottom-up DP traversal** (via DFS), computing the optimal profit for each subtree for **all possible budget values** up to the given limit. Each node maintains a DP array where:

- `dp[b]` = maximum profit achievable in the subtree using `b` units of budget.

### Max-Plus Convolution  
To combine results from multiple child subtrees, the algorithm uses a **max-plus convolution**—a variation of the knapsack merge. This operation merges two DP arrays (from child subtrees), preserving the **best profit for every feasible budget split**.

### Discounted Investment  
Each project may optionally be undertaken at **half the original cost**, providing an extra decision branch per node. This adds flexibility in budget usage and can increase total returns.

---

## Algorithm Pillars

The approach rests on three main ideas:

1. **DFS on the Dependency Tree**  
   Traverse the project tree in post-order to ensure subproblems (child nodes) are solved before parent nodes.

2. **Knapsack-Style DP Arrays**  
   Each node maintains a DP array of size `B + 1`, where `B` is the total budget. The array stores the **maximum gain** for each budget level within its subtree.

3. **Merging via Max Convolution + Local Decision Step**  
   - Combine children's DP arrays using **max convolution** to explore all ways of splitting budget between subprojects.  
   - Apply a **local decision step**: for the current project, consider investing at full cost, discounted cost, or not at all, and update the DP accordingly.

---

## Max-Plus Convolution: When and Why?

Max convolution is critical when:

- Subtrees (subproblems) are **independent**  
- A **shared global constraint** (budget) applies  
- The objective is to **maximize/minimize** a quantity over all valid resource splits  
- Each subtree provides a DP table mapping `cost → best outcome`

In essence, it answers:

> "Given multiple DP arrays, how can we merge them optimally under a shared budget constraint?"

---

## Time Complexity

**O(N × B²)**, where:

- `N` is the number of nodes (projects)  
- `B` is the total budget

This is acceptable under typical constraints, especially with optimizations like pruning or efficient convolution techniques.

---

## Key Questions for Implementation

- **DFS DP**:  
  Can I perform DFS and compute a DP array at each node based on its children?

- **State Design**:  
  Do I need multiple DP states per node to track whether the parent was chosen?

- **Merging Strategy**:  
  Can child DP arrays be combined using a knapsack-like convolution?

```cpp
class Solution {
private:
    int RESOURCE_LIMIT;
    vector<vector<int>> adj;
    vector<int> costs, gains;
    vector<int> maxPlusConvolve(const vector<int> &A, const vector<int> &B) {
        vector<int> ans(RESOURCE_LIMIT + 1, 0);
        for (int i = 0; i <= RESOURCE_LIMIT; i++) {
            for (int j = 0; i + j <= RESOURCE_LIMIT; j++) {
                ans[i + j] = max(ans[i + j], A[i] + B[j]);
            }
        }
        return ans;
    }
    pair<vector<int>, vector<int>> dfs(int u) {
        vector<int> dp(RESOURCE_LIMIT + 1, 0), dpDiscounted(RESOURCE_LIMIT + 1, 0);
        for (int v : adj[u]) {
            auto [res, resDiscounted] = dfs(v);
            dp = maxPlusConvolve(dp, res);
            dpDiscounted = maxPlusConvolve(dpDiscounted, resDiscounted);
        }
        int cost = costs[u];
        for (int i = cost; i <= RESOURCE_LIMIT; i++) {
            dp[i] = max(dp[i], dpDiscounted[i - cost] + gains[u] - cost);
        }
        vector<int> ret = dp;
        cost >>= 1;
        for (int i = cost; i <= RESOURCE_LIMIT; i++) {
            ret[i] = max(ret[i], dpDiscounted[i - cost] + gains[u] - cost);
        }
        return {dp, ret};
    }
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        RESOURCE_LIMIT = budget;
        costs = present;
        gains = future;
        adj.assign(n, vector<int>());
        for (const auto &edge : hierarchy) {
            int u = edge[0], v = edge[1];
            u--; v--;
            adj[u].emplace_back(v);
        }
        auto [ans, _] = dfs(0);
        return ans[budget];
    }
};
```

# Leetcode Weekly Contest 452

## 3567. Minimum Absolute Difference in Sliding Submatrix

### Solution 1: 2D sliding window, windowed computation, sorted set

sliding window over a matrix with local windowed computation using a sorted set to maintain the minimum absolute difference in a sliding submatrix.
Think about where the local variation between distinct values might be meaningful. 

This is not the most efficient algorithm, it is basically O(R * C * k^2), so for sufficiently large k, it will struggle.

```cpp
const int INF = (1LL << 31) - 1;
class Solution {
public:
    vector<vector<int>> minAbsDiff(vector<vector<int>>& grid, int k) {
        int R = grid.size(), C = grid[0].size();
        vector<vector<int>> ans(R - k + 1, vector<int>(C - k + 1, 0));
        for (int r = k - 1; r < R; r++) {
            for (int c = k - 1; c < C; c++) {
                set<int> pool;
                for (int i = r - k + 1; i <= r; i++) {
                    for (int j = c - k + 1; j <= c; j++) {
                        pool.insert(grid[i][j]);
                    }
                }
                if (pool.size() == 1) continue;
                int i = r - k + 1, j = c - k + 1;
                ans[i][j] = INF;
                for (auto it = pool.begin(), jt = next(pool.begin()); jt != pool.end(); it++, jt++) {
                    ans[i][j] = min(ans[i][j], abs(*jt - *it));
                }
            }
        }
        return ans;
    }
};
```

## 3568. Minimum Moves to Clean the Classroom

### Solution 1: constrained pathfinding, bfs, queue, bitmask, bitset

This is like a resource constrained pathfinding problem, it also shares some similarities with the travelling salesman problem on a grid, and steiner tree variants I suspect.

The main ingredient is really to figure out the states for the bfs to mark which are visited and make it optimal.

```cpp
struct State {
    int r, c, e, mask;
    State() {}
    State(int r, int c, int e, int mask) : r(r), c(c), e(e), mask(mask) {}
};
class Solution {
private:
    bitset<1024> vis[20][20][51];
    int targetIndex[20][20];
    int R, C;
    bool inBounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    vector<pair<int, int>> neighborhood(int r, int c) {
        return {{r + 1, c}, {r - 1, c}, {r, c + 1}, {r, c - 1}};
    }
public:
    int minMoves(vector<string>& grid, int energy) {
        R = grid.size(), C = grid[0].size();
        int cnt = 0;
        fill(&targetIndex[0][0], &targetIndex[0][0] + 400, -1);
        memset(vis, false, sizeof(vis));
        queue<State> q;
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (grid[r][c] == 'S') {
                    q.emplace(r, c, energy, 0);
                    vis[r][c][energy].set(0);
                } else if (grid[r][c] == 'L') {
                    targetIndex[r][c] = cnt++;
                }
            }
        }
        int endMask = (1 << cnt) - 1;
        int ans = 0;
        while (!q.empty()) {
            int sz = q.size(); 
            for (int i = 0; i < sz; i++) {
                State state = q.front();
                q.pop();
                if (state.mask == endMask) return ans;
                if (!state.e) continue;
                for (auto [nr, nc] : neighborhood(state.r, state.c)) {
                    if (!inBounds(nr, nc) || grid[nr][nc] == 'X') continue;
                    int nmask = state.mask, ne = state.e - 1;
                    if (grid[nr][nc] == 'L') {
                        nmask |= (1 << targetIndex[nr][nc]);
                    } else if (grid[nr][nc] == 'R') {
                        ne = energy;
                    }
                    if (vis[nr][nc][ne].test(nmask)) continue;
                    vis[nr][nc][ne].set(nmask);
                    q.emplace(nr, nc, ne, nmask);
                }
            }
            ans++;
        }
        return -1;
    }
};
```

## 3569. Maximize Count of Distinct Primes After Split

### Solution 1: lazy segment tree for range add updates and range max queries, track intervals for the first and last occurrence of each prime, online queries, prime sieve, sets



```cpp
// ----------------------------------------------------------------
//  SegmentTree supporting range‐add and range‐max queries
// ----------------------------------------------------------------
struct SegmentTree {
    int size;                         // internal size (next power of two)
    int neutral;               // neutral element for max (LLONG_MIN)
    vector<int> values;        // values[idx] = current max over idx’s segment, including operations[idx]
    vector<int> operations;    // operations[idx] = pending “add” for idx’s entire segment

    // Build a tree covering indices [0..n-1], initialized to all zeros.
    void init(int n) {
        neutral = 0;
        size = 1;
        while (size < n) size <<= 1;
        values.assign(2 * size, 0LL);
        operations.assign(2 * size, 0LL);
    }

    // Combine two lazy‐tags: here we do range‐addition, so tags combine by +.
    inline int modify_op(int x, int y) {
        return x + y;
    }

    // Combine two children’s values: we want range‐max.
    inline int calc_op(int x, int y) {
        return max(x, y);
    }

    // After changing values[idx] (and/or operations[idx]), climb up to the root
    // and fix every ancestor so that values[parent] = max(children) + operations[parent].
    void ascend(int idx) {
        while (idx > 0) {
            idx = (idx - 1) >> 1;          // move to parent
            int left_child  = 2 * idx + 1;
            int right_child = 2 * idx + 2;
            int combined = calc_op(values[left_child], values[right_child]);
            values[idx] = modify_op(combined, operations[idx]);
        }
    }

    // Add `val` to every element in [l..r] (0‐indexed, inclusive).
    void update(int l, int r, int val) {
        if (l > r) return;
        // We'll do an explicit stack‐based DFS over nodes
        // Each entry is (lx, rx, idx), meaning "node idx covers [lx..rx)"
        struct Node { int lx, rx, idx; };
        vector<Node> stack;
        stack.reserve(64);
        stack.emplace_back(0, size, 0);

        // Keep track of which nodes got a new “lazy” so we can ascend afterward
        vector<int> segments;
        while (!stack.empty()) {
            Node cur = stack.back();
            stack.pop_back();
            int lx = cur.lx, rx = cur.rx, idx = cur.idx;

            // 1) No overlap with [l..r]
            if (lx > r || rx - 1 < l) continue;

            // 2) Total cover: [lx..rx-1] ⊆ [l..r]
            if (lx >= l && rx - 1 <= r) {
                operations[idx] = modify_op(operations[idx], val);
                values[idx]     = modify_op(values[idx], val);
                segments.emplace_back(idx);
                continue;
            }

            // 3) Partial overlap: descend into children
            int mid = (lx + rx) >> 1;
            int left_child  = 2 * idx + 1;
            int right_child = 2 * idx + 2;
            // Left child covers [lx..mid), right covers [mid..rx)
            stack.emplace_back(lx,  mid, left_child);
            stack.emplace_back(mid,  rx,  right_child);
        }
        // Recompute ancestors of every changed node
        for (int idx : segments) {
            ascend(idx);
        }
    }

    // Query the maximum over [l..r] (0‐indexed, inclusive).
    int query(int l, int r) {
        if (l > r) return neutral;
        // We'll carry along a “carried_lazy” value which is the sum of all operations[]
        // from the root down to (but not including) the current node.
        struct QNode { int lx, rx, idx; int carry; };
        vector<QNode> stack;
        stack.reserve(64);
        stack.emplace_back(0, size, 0, 0LL);
        int result = neutral;

        while (!stack.empty()) {
            QNode cur = stack.back();
            stack.pop_back();
            int lx = cur.lx, rx = cur.rx, idx = cur.idx;
            int carried = cur.carry;

            // 1) No overlap
            if (lx > r || rx - 1 < l) continue;

            // 2) Total cover: [lx..rx-1] ⊆ [l..r]
            if (lx >= l && rx - 1 <= r) {
                int actual_val = modify_op(values[idx], carried);
                result = calc_op(result, actual_val);
                continue;
            }

            // 3) Partial overlap: descend into children,
            //    passing down “operations[idx]” plus the carried value.
            int mid = (lx + rx) >> 1;
            int left_child  = 2 * idx + 1;
            int right_child = 2 * idx + 2;
            int new_carry = modify_op(carried, operations[idx]);
            // Right child covers [mid..rx), left child covers [lx..mid)
            stack.emplace_back(mid,  rx,   right_child, new_carry);
            stack.emplace_back(lx,   mid,  left_child,  new_carry);
        }

        return result;
    }
};

const int MAXN = 1e5 + 5;
bool primes[MAXN];
int first[MAXN], last[MAXN];
set<int> sets[MAXN];

void sieve(int n) {
    fill(primes, primes + n, true);
    primes[0] = primes[1] = false;
    int p = 2;
    for (int p = 2; p * p <= n; p++) {
        if (primes[p]) {
            for (int i = p * p; i < n; i += p) {
                primes[i] = false;;
            }
        }
    }
}

class Solution {
private:
    void precompute() {
        sieve(MAXN);
        fill(first, first + MAXN, MAXN);
        fill(last, last + MAXN, -1);
        for (int i = 0; i < MAXN; i++) {
            sets[i].clear();
        }
    }
public:
    vector<int> maximumCount(vector<int>& nums, vector<vector<int>>& queries) {
        int N = nums.size(), M = queries.size();
        unordered_set<int> vis;
        SegmentTree seg;
        seg.init(N);
        precompute();
        for (int i = 0; i < N; i++) {
            if (!primes[nums[i]]) continue;
            sets[nums[i]].insert(i);
            vis.insert(nums[i]);
            first[nums[i]] = min(first[nums[i]], i);
            last[nums[i]] = i;
        }
        for (int p : vis) {
            seg.update(first[p], last[p] - 1, 1);
        }
        vector<int> ans(M, 0);
        for (int i = 0; i < M; i++) {
            int idx = queries[i][0];
            int val = nums[idx];
            // unset p at i
            if (primes[val]) {
                sets[val].erase(idx);
                if (idx == first[val] || idx == last[val]) {
                    seg.update(first[val], last[val] - 1, -1);
                }
                if (sets[val].empty()) {
                    first[val] = MAXN;
                    last[val] = -1;
                    vis.erase(val);
                } else if (idx == first[val]) {
                    auto it = sets[val].begin();
                    first[val] = *it;
                    seg.update(first[val], last[val] - 1, 1);
                } else if (idx == last[val]) {
                    auto it = sets[val].end();
                    last[val] = *prev(it);
                    seg.update(first[val], last[val] - 1, 1);
                }
            }
            // set p at i
            val = queries[i][1];
            nums[idx] = val;
            if (primes[val]) {
                sets[val].insert(idx);
                vis.insert(val);
                // how to handle when prime is not in array
                if (idx < first[val] || idx > last[val]) {
                    seg.update(first[val], last[val] - 1, -1);
                    first[val] = min(first[val], idx);
                    last[val] = max(last[val], idx);
                    seg.update(first[val], last[val] - 1, 1);
                }
            }
            int mx = seg.query(0, N - 2); // max overlap intervals
            ans[i] = vis.size() + mx;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 453

## Count the Number of Computer Unlocking Permutations

### Solution 1: factorial permutations, number of permutations

```cpp
using int64 = int64_t;
const int MOD = 1e9 + 7;
class Solution {
public:
    int countPermutations(vector<int>& complexity) {
        int N = complexity.size(), ans = 1;
        for (int64 i = 1; i < N; i++) {
            ans = (ans * i) % MOD;
            if (complexity[i] <= complexity[0]) return 0;
        }
        return ans;
    }
};
```

## Count Partitions with Max-Min Different at Most K

### Solution 1: sliding window dp, deque, dynamic programming, prefix sum optimization of dp, monotonic queues

A constraint only on the max/min (or sum) of a subarray,
A desire to count or optimize over all subarrays ending at i,
And a need to aggregate DP values over a contiguous range of previous states—

```cpp
const int MOD = 1e9 + 7;
class Solution {
public:
    int countPartitions(vector<int>& nums, int k) {
        int N = nums.size();
        vector<int> dp(N + 1, 0), psum(N + 1, 0);
        dp[0] = psum[0] = 1;
        deque<int> minQ, maxQ;
        for (int i = 1, j = 0; i <= N; i++) {
            while (!minQ.empty() && nums[minQ.back()] >= nums[i - 1]) minQ.pop_back();
            while (!maxQ.empty() && nums[maxQ.back()] <= nums[i - 1]) maxQ.pop_back();
            minQ.emplace_back(i - 1); maxQ.emplace_back(i - 1);
            while (nums[maxQ.front()] - nums[minQ.front()] > k) {
                if (maxQ.front() == j) maxQ.pop_front();
                if (minQ.front() == j) minQ.pop_front();
                j++;
            }
            int cur = (psum[i - 1] - (j > 0 ? psum[j - 1] : 0) + MOD) % MOD;
            psum[i] = (psum[i - 1] + cur) % MOD;
            dp[i] = cur;
        }
        return dp.back();
    }
};
```

## Minimum Steps to Convert String with Operations

### Solution 1: dynamic programming, substring dp, greedy matching, string manipulation

1. Uses dynamic programming over all substrings. For each end index i, it considers every start j, and sets dp[i] to the best split dp[j − 1] plus the minimal cost to convert the block word1[j..i] into word2[j..i].
2. Block cost pairs mismatches. A single operation fixes a complementary pair (x in word1 vs y in word2 and later y vs x) like a swap, while noncomplementary mismatches count individually like replacements. It also tries one full reversal of the block and takes 1 plus that cost if it helps.
3. Time complexity is O(N³) in the worst case from O(N²) blocks times O(block length) cost checks, with O(N) extra space for dp.

```cpp
const int INF = numeric_limits<int>::max();
class Solution {
private:
    int calc(string& w1, string& w2) {
        int N = w1.size(), ans = 0;
        map<pair<int, int>, int> counts;
        for (int i = 0; i < N; ++i) {
            if (w1[i] == w2[i]) continue;
            if (counts[{w1[i], w2[i]}] == 0) {
                ans++;
                counts[{w2[i], w1[i]}]++;
            } else {
                counts[{w1[i], w2[i]}]--;
            }
        }
        return ans;
    }
    int cost(string w1, string w2) {
        int ans = calc(w1, w2);
        reverse(w1.begin(), w1.end());
        ans = min(ans, calc(w1, w2) + 1);
        return ans;
    }
public:
    int minOperations(string word1, string word2) {
        int N = word1.size();
        vector<int> dp(N, INF);
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j <= i; ++j) {
                int prv = j > 0 ? dp[j - 1] : 0;
                dp[i] = min(dp[i], cost(word1.substr(j, i - j + 1), word2.substr(j, i - j + 1)) + prv);
            }
        }
        return dp[N - 1];
    }
};
```

# Leetcode Weekly Contest 454

## Maximum Product of First and Last Element of a Subsequence

### Solution 1: prefix max/min, suffix max/min, fixed sized sliding window

```cpp
using int64 = int64_t;
const int64 INF = numeric_limits<int64>::max();
class Solution {
public:
    int64 maximumProduct(vector<int>& nums, int m) {
        int N = nums.size();
        int64 ans = -INF;
        int64 pmax = -INF, pmin = INF;
        vector<int64> smax(N, -INF), smin(N, INF);
        for (int i = N - 1; i >= 0; i--) {
            smax[i] = smin[i] = nums[i];
            if (i + 1 < N) {
                smax[i] = max(smax[i], smax[i + 1]);
                smin[i] = min(smin[i], smin[i + 1]);
            }
        }
        for (int i = 0; i + m - 1 < N; i++) {
            pmax = max(pmax, static_cast<int64>(nums[i]));
            pmin = min(pmin, static_cast<int64>(nums[i]));
            int64 cand1 = pmax * smax[i + m - 1];
            int64 cand2 = pmin * smin[i + m - 1];
            ans = max({ans, cand1, cand2});
        }
        return ans;
    }
};
```

## Find Weighted Median Node in Tree

### Solution 1: binary lifting, lca, median node, path sum

```cpp
using int64 = int64_t;
struct Tree {
    int N, LOG;
    vector<vector<pair<int,int>>> adj;
    vector<int> depth, parent;
    vector<int64> dist;
    vector<vector<int>> up;

    Tree(int n) : N(n) {
        LOG = 20;
        adj.assign(N, vector<pair<int, int>>());
        depth.assign(N, 0);
        parent.assign(N, -1);
        dist.assign(N, 0);
        up.assign(LOG, vector<int>(N, -1));

    }
    void addEdge(int u, int v, int w = 1) {
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    void preprocess(int root = 0) {
        dfs(root);
        buildLiftingTable();
    }
    int kthAncestor(int u, int k) const {
        for (int i = 0; i < LOG && u != -1; i++) {
            if ((k >> i) & 1) {
                u = up[i][u];
            }
        }
        return u;
    }
    int lca(int u, int v) const {
        if (depth[u] < depth[v]) swap(u, v);
        // Bring u up to the same depth as v
        u = kthAncestor(u, depth[u] - depth[v]);
        if (u == v) return u;
        // Binary lift both
        for (int i = LOG - 1; i >= 0; i--) {
            if (up[i][u] != up[i][v]) {
                u = up[i][u];
                v = up[i][v];
            }
        }
        // Now parents are equal
        return parent[u];
    }
    int query(int u, int v) const {
        int a = lca(u, v);
        int64 totalDist = distance(u, v, a);
        if (2LL * distance(u, a, a) >= totalDist && u != a) { // median node is in u -> a path
            int p = u;
            for (int k = LOG - 1; k >= 0; k--) {
                int cand = up[k][p];
                if (cand == -1) continue;
                if (depth[cand] >= depth[a] && 2LL * distance(u, cand, cand) < totalDist) p = cand;
            }
            return up[0][p];
        } 
        int p = v;
        for (int k = LOG - 1; k >= 0; k--) {
            int cand = up[k][p];
            if (cand == -1) continue;
            if (depth[cand] >= depth[a] && 2LL * distance(v, cand, cand) <= totalDist) p = cand;
        }
        return p;
    }
    int64 distance(int u, int v, int a) const {
        return dist[u] + dist[v] - 2 * dist[a];
    }
private:
    void dfs(int u, int p = -1) {
        parent[u] = p;
        up[0][u] = p;
        for (auto &[v, w] : adj[u]) {
            if (v == p) continue;
            depth[v] = depth[u] + 1;
            dist[v] = dist[u] + w;
            dfs(v, u);
        }
    }
    void buildLiftingTable() {
        for (int i = 1; i < LOG; i++) {
            for (int j = 0; j < N; j++) {
                if (up[i - 1][j] == -1) continue;
                up[i][j] = up[i - 1][up[i - 1][j]];
            }
        }
    }
};
class Solution {
public:
    vector<int> findMedian(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {
        int M = queries.size();
        Tree tree(n);
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            tree.addEdge(u, v, w);
        }
        tree.preprocess();
        vector<int> ans;
        for (const auto &query : queries) {
            int u = query[0], v = query[1];
            ans.emplace_back(tree.query(u, v));
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 455

## Inverse Coin Change

### Solution 1: dynamic programming, combinatorics

```cpp
class Solution {
public:
    vector<int> findCoins(vector<int>& numWays) {
        int N = numWays.size();
        vector<int> ans, dp(N + 1, 0);
        dp[0] = 1;
        for (int d = 1; d <= N; d++) {
            if (dp[d] > numWays[d - 1]) return {};
            if (dp[d] == numWays[d - 1]) continue;
            if (numWays[d - 1] - dp[d] != 1) return {};
            ans.emplace_back(d);
            for (int i = d; i <= N; i++) {
                dp[i] += dp[i - d];
            }
        }
        return ans;
    }
};
```

## Minimum Increments to Equalize Leaf Paths

### Solution 1: undirected tree, dfs, root-to-leaf path sum

```cpp
using int64 = int64_t;
const int64 INF = numeric_limits<int64>::max();
class Solution {
private:
    int64 maxSum = 0;
    int ans = 0;
    vector<int> C;
    vector<vector<int>> adj;
    void dfs1(int u, int p = -1, int64 sum = 0) {
        sum += C[u];
        bool isLeaf = true;
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs1(v, u, sum);
            isLeaf = false;
        }
        maxSum = max(maxSum, sum);
    }
    int64 dfs2(int u, int p = -1, int64 sum = 0) {
        int64 minDelta = INF, minCount = 0;
        sum += C[u];
        bool isLeaf = true;
        for (int v : adj[u]) {
            if (v == p) continue;
            int delta = dfs2(v, u, sum);
            if (delta < minDelta) {
                minDelta = delta;
                minCount = 0;
            }
            if (delta == minDelta) minCount++;
            isLeaf = false;
        }
        if (isLeaf) minDelta = maxSum - sum;
        if (!minDelta) return 0;
        ans = (ans - minCount + 1);
        return minDelta;
    }
public:
    int minIncrease(int n, vector<vector<int>>& edges, vector<int>& cost) {
        adj.assign(n, vector<int>());
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
        C = vector<int>(cost.begin(), cost.end());
        dfs1(0);
        dfs2(0);
        return ans;
    }
};
```

## Minimum Time to Transport All Individuals

### Solution 1:  state graph, dijkstra, minheap, bitmask, enumerate submasks

```cpp
using int64 = int64_t;
const long double INF = numeric_limits<long double>::max();
struct State {
    int mask, stage, side;
    long double t;
    State() {}
    State(int mask, int stage, int side, long double t) : mask(mask), stage(stage), side(side), t(t) {}
    bool operator<(const State& other) const {
        return other.t < t;
    }
};
class Solution {
public:
    double minTime(int n, int k, int m, vector<int>& time, vector<double>& mul) {
        if (n > 1 && k == 1) return -1;
        vector<int> subsetMax(1 << n, 0);
        for (int mask = 0; mask < (1 << n); mask++) {
            int mx = 0;
            for (int i = 0; i < n; i++) {
                if ((mask >> i) & 1) {
                    mx = max(mx, time[i]);
                }
            }
            subsetMax[mask] = mx;
        }
        int endMask = (1 << n) - 1;
        vector<vector<vector<long double>>> dist(1 << n, vector<vector<long double>>(m, vector<long double>(2, INF)));
        priority_queue<State> minheap;
        dist[0][0][0] = 0;
        minheap.emplace(0, 0, 0, 0);
        while (!minheap.empty()) {
            State st = minheap.top();
            minheap.pop();
            if (st.t > dist[st.mask][st.stage][st.side]) continue;
            if (st.mask == endMask && st.side == 1) return st.t;
            if (st.side == 0) { // right side
                int remMask = st.mask ^ endMask;
                for (int submask = remMask; submask > 0; submask = (submask - 1) & remMask) {
                    if (__builtin_popcount(submask) > k) continue;
                    int t = subsetMax[submask];
                    long double ncost = t * mul[st.stage];
                    int nstage = (st.stage + static_cast<int64>(floor(ncost)) % m) % m;
                    int nmask = st.mask | submask;
                    long double nTime = st.t + ncost;
                    if (nTime < dist[nmask][nstage][1]) {
                        dist[nmask][nstage][1] = nTime;
                        minheap.emplace(nmask, nstage, 1, nTime);
                    }
                }
            } else {
                for (int r = 0; r < n; r++) {
                    if (!((st.mask >> r) & 1)) continue;
                    int t = subsetMax[1 << r];
                    long double ncost = t * mul[st.stage];
                    int nstage = (st.stage + static_cast<int64>(floor(ncost)) % m) % m;
                    int nmask = st.mask ^ (1 << r);
                    long double nTime = st.t + ncost;
                    if (nTime < dist[nmask][nstage][0]) {
                        dist[nmask][nstage][0] = nTime;
                        minheap.emplace(nmask, nstage, 0, nTime);
                    }
                }
            }
        }
        return -1;
    }
};
```

# Leetcode Weekly Contest 456

## Longest Common Prefix Between Adjacent Strings After Removals

### Solution 1:  prefix max, suffix max, lcp

```cpp
class Solution {
private:
    int calc(const string &s, const string &t) {
        int N = min(s.size(), t.size());
        for (int i = 0; i < N; ++i) {
            if (s[i] != t[i]) return i;
        }
        return N;
    }
public:
    vector<int> longestCommonPrefix(vector<string>& words) {
        int N = words.size();
        vector<int> sufMax(N + 1, 0), lcp(N, 0);
        for (int i = 0; i + 1 < N; ++i) {
            lcp[i] = calc(words[i], words[i + 1]);
        }
        for (int i = N - 2; i >= 0; --i) {
            sufMax[i] = max(sufMax[i + 1], lcp[i]);
        }
        int pmax = 0;
        vector<int> ans(N, 0);
        for (int i = 0; i < N; ++i) {
            ans[i] = max(pmax, sufMax[i + 1]);
            if (i > 0 && i + 1 < N) ans[i] = max(ans[i], calc(words[i - 1], words[i + 1]));
            if (i > 0) pmax = max(pmax, calc(words[i - 1], words[i]));
        }
        return ans;
    }
};
```

## Partition Array to Minimize XOR

### Solution 1: xor partitioning, interval dp

```cpp
const int INF = numeric_limits<int>::max();
class Solution {
public:
    int minXor(vector<int>& nums, int K) {
        int N = nums.size();
        vector<int> dp(N + 1, INF), ndp(N + 1, INF);
        dp[0] = 0;
        for (int k = 0; k < K; ++k) {
            ndp.assign(N + 1, INF);
            for (int r = k + 1; r <= N; ++r) {
                int xorSum = 0;
                for (int l = r; l > k; --l) {
                    xorSum ^= nums[l - 1];
                    ndp[r] = min(ndp[r], max(dp[l - 1], xorSum));
                }
            }
            swap(ndp, dp);
        }
        return dp.back();
    }
};
```

## Maximize Spanning Tree Stability with Upgrades

### Solution 1: kruskal's algorithm, disjoint set union, binary search, feasibility check, upgrades are edge costs

```cpp
const int INF = 1e6;
struct Edge {
    int u, v, up;
    Edge(int u, int v, int up) : u(u), v(v), up(up) {}
    bool operator<(const Edge &other) const {
        return up < other.up;
    }
};
struct UnionFind {
    vector<int> parents, size;
    UnionFind(int n) {
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    void unite(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
        }
    }

    bool same(int i, int j) {
        return find(i) == find(j);
    }
};
class Solution {
private:
    int N, K;
    vector<vector<int>> edges;
    bool feasible(int target) {
        UnionFind dsu(N);
        vector<Edge> curEdges;
        int minCost = 0, numEdges = 0;
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1], s = edge[2], must = edge[3];
            if (must && s < target) return false;
            if (must && dsu.same(u, v)) return false;
            if (must) {
                dsu.unite(u, v);
                ++numEdges;
                continue;
            } 
            if (s >= target) {
                curEdges.emplace_back(u, v, 0);
            }
            if (2 * s >= target) {
                curEdges.emplace_back(u, v, 1);
            }
        }
        sort(curEdges.begin(), curEdges.end());
        for (const auto [u, v, up] : curEdges) {
            if (!dsu.same(u, v)) {
                dsu.unite(u, v);
                minCost += up;
                ++numEdges;
            }
        }
        return numEdges == N - 1 && minCost <= K;
    }
public:
    int maxStability(int n, vector<vector<int>>& A, int k) {
        N = n, K = k, edges = A;
        int lo = 0, hi = INF;
        cout << feasible(1) << endl;
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            if (feasible(mid)) lo = mid;
            else hi = mid - 1;
        }
        if (!feasible(lo)) return -1;
        return lo;
    }
};
```

# Leetcode Weekly Contest 457

## Coupon Code Validator

### Solution 1: enums, sorting, custom comparator, string manipulation

```cpp
enum class Category : int {
    Electronic = 0,
    Grocery = 1,
    Pharmacy = 2,
    Restaurant = 3,
    Invalid = 4,
};
string categoryArr[4] = {"electronics", "grocery", "pharmacy", "restaurant"};
Category to_category(const string &s) {
    for (int i = 0; i < 4; i++) {
        if (categoryArr[i] == s) {
            return static_cast<Category>(i);
        }
    }
    return static_cast<Category>(4);
}
struct Coupon {
    Category category;
    string code;
    Coupon(Category category, string code) : category(category), code(code) {}
    bool operator<(const Coupon &other) const {
        return tie(category, code) < tie(other.category, other.code);
    }
};
class Solution {
public:
    vector<string> validateCoupons(vector<string>& code, vector<string>& businessLine, vector<bool>& isActive) {
        int N = code.size();
        vector<Coupon> coupons;
        for (int i = 0; i < N; ++i) {
            if (code[i].empty()) continue;
            if (!isActive[i]) continue;
            bool codeIsValid = all_of(code[i].begin(), code[i].end(), [](const char &ch) {
                return isalnum(ch) || ch == '_';
            });
            if (!codeIsValid) continue;
            Category cat = to_category(businessLine[i]);
            if (cat == Category::Invalid) continue;
            coupons.emplace_back(cat, code[i]);
        }
        sort(coupons.begin(), coupons.end());
        vector<string> ans(coupons.size());
        transform(coupons.begin(), coupons.end(), ans.begin(), [](const Coupon &cp) { return cp.code; });
        return ans;
    }
};
```

## Power Grid Maintenance

### Solution 1: dfs, undirected graph, connected components, set

```cpp
class Solution {
private:
    int N, gridNum;
    vector<vector<int>> adj;
    vector<bool> vis;
    vector<set<int>> gridStations;
    vector<int> stationToGrid;
    void dfs(int u) {
        if (vis[u]) return;
        vis[u] = true;
        stationToGrid[u] = gridNum;
        gridStations[gridNum].insert(u);
        for (int v : adj[u]) {
            dfs(v);
        }
    }
public:
    vector<int> processQueries(int c, vector<vector<int>>& connections, vector<vector<int>>& queries) {
        N = c, gridNum = 0;
        adj.assign(N, vector<int>());
        for (const auto &edge : connections) {
            int u = edge[0], v = edge[1];
            --u, --v;
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
        vis.assign(N, false);
        stationToGrid.assign(N, -1);
        for (int i = 0; i < N; ++i) {
            if (vis[i]) continue;
            gridStations.emplace_back(set<int>());
            dfs(i);
            ++gridNum;
        }
        vector<int> ans;
        for (const auto & query : queries) {
            int t = query[0], x = query[1] - 1;
            if (t == 1) {
                int grid = stationToGrid[x];
                if (gridStations[grid].contains(x)) ans.emplace_back(x + 1);
                else if (gridStations[grid].empty()) ans.emplace_back(-1);
                else ans.emplace_back(*gridStations[grid].begin() + 1);
            } else {
                int grid = stationToGrid[x];
                gridStations[grid].erase(x);
            }
        }
        return ans;
    }
};
```

## Minimum Time for K Connected Components

### Solution 1: union find, binary search, feasibility check, 

```cpp
const int INF = numeric_limits<int>::max();
struct UnionFind {
    vector<int> parents, size;
    int cnt;
    UnionFind(int n) {
        cnt = n;
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    void unite(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            --cnt;
        }
    }

    bool same(int i, int j) {
        return find(i) == find(j);
    }

    int count() const {
        return cnt;
    }
};
class Solution {
private:
    int N, K;
    vector<vector<int>> edges;
    bool feasible(int target) {
        UnionFind dsu(N);
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1], t = edge[2];
            if (t <= target) continue;
            dsu.unite(u, v);
        }
        return dsu.count() >= K;
    }
public:
    int minTime(int n, vector<vector<int>>& E, int k) {
        edges = E, K = k, N = n;
        int lo = 0, hi = INF;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (feasible(mid)) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo;
    }
};
```

## Minimum Moves to Reach Target in Grid

### Solution 1: reverse simulation, deterministic, mathematics

1. The key is that forward iteration explodes the state space, and you have to explore a lot. 
1. If you reverse the process starting from tx and ty, it is actually deterministic, the previous state is dependent on current tx and ty relationships. 

Think one step back and what could produce the current tx and ty

Assume tx >= ty, that is tx is dominant in current step, but previous step it was either dominant or not dominant, but there is easy way to figure out, and it determines the previous state.

If it is the case that you would come from this state (tx / 2, ty) will since we are saying tx >= ty, that would indicate that tx > 2 * ty.  That is tx was dominant in the previous step as well, is what this would indicate. 

But if you say that tx was not dominant in previous step then you must have come from this state (tx - ty, ty), cause you would have added ty to tx, this implies that tx <= 2 * ty.

this makes it deterministic, and there is only one valid path which makes this backward iteration work. 

```cpp
class Solution {
public:
    int minMoves(int sx, int sy, int tx, int ty) {
        int ans = 0;
        while (sx != tx || sy != ty) {
            if (sx == 0 && sy == 0) return -1;
            if (tx < sx || ty < sy) return -1;
            ans++;
            if (tx > 2 * ty) {
                if (tx % 2) return -1;
                tx /= 2;
            } else if (tx > ty) {
                tx -= ty;
            } else if (ty > 2 * tx) {
                if (ty % 2) return -1;
                ty /= 2;
            } else if (ty > tx) {
                ty -= tx;
            } else if (sx == 0) {
                tx -= tx;
            } else {
                ty -= ty;
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 458

## Minimize Maximum Component Cost

### Solution 1: undirected graph, sorting, union find, greedy

```cpp
struct UnionFind {
    int numGroups;
    vector<int> parents, size;
    UnionFind(int n) {
        numGroups = n;
        parents.resize(n);
        iota(parents.begin(),parents.end(),0);
        size.assign(n,1);
    }

    int find(int i) {
        if (i==parents[i]) {
            return i;
        }
        return parents[i]=find(parents[i]);
    }

    void unite(int i, int j) {
        i = find(i), j = find(j);
        if (i!=j) {
            if (size[j]>size[i]) {
                swap(i,j);
            }
            size[i]+=size[j];
            parents[j]=i;
            --numGroups;
        }
    }

    bool same(int i, int j) {
        return find(i) == find(j);
    }

};
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges, int k) {
        if (n == k) return 0;
        sort(edges.begin(), edges.end(), [](const vector<int> &a, const vector<int> &b) {
            return a[2] < b[2]; 
        });
        int numComponents = n;
        UnionFind dsu(n);
        for (const vector<int> &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            dsu.unite(u, v);
            if (dsu.numGroups <= k) return w;
        }
        return -1;
    }
};
```

## Process String with Special Operations II

### Solution 1:  reverse mapping, follow position of k

Operations are functions on position and mostly invertible. 
Track where your target indexk would have originated from after all the operations are applied by going backwards. 

```cpp
using int64 = int64_t;
class Solution {
public:
    char processStr(string s, int64 k) {
        int N = s.size();
        vector<int64> len(N + 1, 0);
        for (int i = 1; i <= N; ++i) {
            char ch = s[i - 1];
            if (ch == '*') {
                len[i] = max<int64>(0, len[i - 1] - 1);
            } else if (ch == '#') {
                len[i] = 2 * len[i - 1];
            } else if (ch == '%') {
                len[i] = len[i - 1];
            } else {
                len[i] = len[i - 1] + 1;
            }
        }
        if (len[N] <= k) return '.';
        for (int i = N - 1; i >= 0; --i) {
            int64 lprv = len[i];
            char ch = s[i];
            if (ch == '#') {
                if (k >= lprv) k -= lprv;
            } else if (ch == '%') {
                k = lprv - k - 1;
            } else if (ch != '*') {
                if (k == lprv) return ch;
            }
        }
        return '.';
    }
};
```

## Longest Palindromic Path in Graph©leetcode

### Solution 1: bitmask dp, undirected graph, palindromic path, bfs, queue

```cpp
class Solution {
public:
    int maxLen(int n, vector<vector<int>>& edges, string labels) {
        vector<vector<vector<bool>>> dp(1 << n, vector<vector<bool>>(n, vector<bool>(n, false)));
        vector<vector<int>> adj(n, vector<int>());
        queue<tuple<int, int, int>> q;
        for (int i = 0; i < n; ++i) {
            q.emplace(1 << i, i, i);
            dp[1 << i][i][i] = true;
        }
        for (const vector<int> &edge : edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
            if (labels[u] != labels[v]) continue;
            int mask = (1 << u) | (1 << v);
            dp[mask][u][v] = true;
            dp[mask][v][u] = true;
            q.emplace(mask, u, v);
        }
        while (!q.empty()) {
            auto [mask, u, v] = q.front();
            q.pop();
            for (int nu : adj[u]) {
                for (int nv : adj[v]) {
                    if (labels[nu] != labels[nv]) continue;
                    if (nu == nv) continue;
                    if ((mask >> nu) & 1) continue;
                    if ((mask >> nv) & 1) continue;
                    int nmask = mask | (1 << nu) | (1 << nv);
                    if (dp[nmask][nu][nv]) continue;
                    dp[nmask][nu][nv] = true;
                    dp[nmask][nv][nu] = true;
                    q.emplace(nmask, nu, nv);
                }
            }
        }
        int ans = 0;
        for (int m = 0; m < (1 << n); ++m) {
            for (int u = 0; u < n; ++u) {
                for (int v = 0; v < n; ++v) {
                    if (!dp[m][u][v]) continue;
                    ans = max(ans, __builtin_popcount(m));
                }
            }
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 459

## 3623. Count Number of Trapezoids I

### Solution 1: map, counting, combinatorics, prefix sum

```cpp
using int64 = int64_t;
const int MOD = 1e9 + 7;
class Solution {
private:
    int64 calc(int64 n) {
        return n * (n - 1) / 2;
    }
public:
    int countTrapezoids(vector<vector<int>>& points) {
        map<int, int> freq;
        for (const vector<int> &point : points) {
            int x = point[0], y = point[1];
            ++freq[y];
        }
        int64 psum = 0, ans = 0;
        for (auto [k, v] : freq) {
            int64 ways = calc(v) % MOD;
            int64 cand = psum * ways % MOD;
            ans = (ans + cand) % MOD;
            psum = (psum + ways) % MOD;
        }
        return ans;
    }
};
```

## 3624. Number of Integers With Popcount-Depth Equal to K II

### Solution 1: fenwick trees, count number of elements in segment, dynamic

```cpp
using int64 = int64_t;
template <typename T>
struct FenwickTree {
    vector<T> nodes;
    T neutral;

    FenwickTree() : neutral(T(0)) {}

    void init(int n, T neutral_val = T(0)) {
        neutral = neutral_val;
        nodes.assign(n + 1, neutral);
    }

    void update(int idx, T val) {
        while (idx < (int)nodes.size()) {
            nodes[idx] += val;
            idx += (idx & -idx);
        }
    }

    T query(int idx) {
        T result = neutral;
        while (idx > 0) {
            result += nodes[idx];
            idx -= (idx & -idx);
        }
        return result;
    }

    T query(int left, int right) {
        return right >= left ? query(right) - query(left - 1) : T(0);
    }
};
class Solution {
private:
    int getPopcountDepth(int64 x) {
        int d = 0;
        while (x > 1) {
            x = __builtin_popcountll(x);
            ++d;
        }
        return d;
    }
public:
    vector<int> popcountDepth(vector<long long>& nums, vector<vector<long long>>& queries) {
        int N = nums.size();
        vector<FenwickTree<int>> trees(6);
        for (auto &ft : trees) {
            ft.init(N);
        }
        vector<int> depth(N, 0);
        for (int i = 0; i < N; ++i) {
            int d = getPopcountDepth(nums[i]);
            depth[i] = d;
            trees[d].update(i + 1, 1);
        }
        vector<int> ans;
        for (const auto &query : queries) {
            int t = query[0];
            if (t == 1) {
                int l = query[1] + 1, r = query[2] + 1, k = query[3];
                int res = trees[k].query(l, r);
                ans.emplace_back(res);
            } else {
                int idx = query[1];
                int64 val = query[2];
                trees[depth[idx]].update(idx + 1, -1); // remove
                int d = getPopcountDepth(val);
                depth[idx] = d;
                trees[d].update(idx + 1, 1); // add
            }
        }
        return ans;
    }
};
```

## 3625. Count Number of Trapezoids II

### Solution 1: geometry, line segments, slope, midpoint, combinatorics

Trapezoid has at least one pair of sides that are parallel (equal slope)
If it has two pair of sides that are parallel it is a parallelogram

These are the important geometric objects to count
Need to count number of trapezoids
count number of parallelograms
and count number of collinear line segments

Also it is important to represent the slope in normalized slope form or reduced form.


```cpp
#define x first
#define y second
using int64 = int64_t;
class Solution {
private:
    pair<int, int> slope(int dx, int dy) {
        if (dx == 0) return {0, 1};
        if (dy == 0) return {1, 0};
        int g = gcd(abs(dx), abs(dy));
        dx /= g;
        dy /= g;
        if (dy < 0) {
            dx = -dx;
            dy = -dy;
        }
        return {dx, dy};
    }
    int64 calc(int64 n) {
        return n * (n - 1) / 2;
    }
public:
    int countTrapezoids(vector<vector<int>>& points) {
        int N = points.size();
        map<pair<int, int>, int> slopeFreq, midFreq;
        map<tuple<int, int, int>, int> freq;
        map<pair<int, int>, map<pair<int, int>, int>> midSlopeFreq;
        for (int i = 0; i < N; ++i) {
            int x1 = points[i][0], y1 = points[i][1];
            for (int j = 0;j < i; ++j) {
                int x2 = points[j][0], y2 = points[j][1];
                pair<int, int> m = slope(x2 - x1, y2 - y1);
                int b = y1 * m.x - x1 * m.y;
                pair<int, int> mid = {x1 + x2, y1 + y2}; // 2 * midpoint
                ++midFreq[mid];
                ++slopeFreq[m];
                ++freq[{m.x, m.y, b}];
                ++midSlopeFreq[mid][m]; // count of midpoints with same slope (collinear)
            }
        }
        int ans = 0;
        for (auto [k, v] : slopeFreq) {
            ans += calc(v);
        }
        for (auto [k, v] : freq) {
            ans -= calc(v);
        }
        for (auto [mid, cnt] : midFreq) {
            int total = calc(cnt);
            for (auto [m, c] : midSlopeFreq[mid]) {
                total -= calc(c);
            }
            ans -= total;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 460

## 3628. Maximum Number of Subsequences After One Inserting

### Solution 1: dynamic programming, prefix and suffix count

```cpp
using int64 = int64_t;
class Solution {
private:
    string S;
    int64 calc(int64 s1, int64 s2, int64 s3, bool cond = false) {
        for (char c : S) {
            if (c == 'L') {
                ++s1;
            } else if (c == 'C') {
                s2 += s1;
            } else if (c == 'T') {
                s3 += s2;
            }
        }
        if (cond) s3 += s2;
        return s3;
    }
public:
    int64 numOfSubsequences(string s) {
        int N = s.size();
        S = s;
        int64 ans = 0;
        ans = max(ans, calc(0, 0, 0, true)); // add 'T' at end
        ans = max(ans, calc(1, 0, 0)); // add 'L' at start
        int64 pref = 0, suf = 0, cand = calc(0, 0, 0);
        for (char c : S) {
            if (c == 'T') ++suf;
        }
        for (char c : S) {
            if (c == 'L') ++pref;
            else if (c == 'T') --suf;
            ans = max(ans, cand + pref * suf);
        }
        return ans;
    }
};
```

## 3629. Minimum Jumps to Reach End via Prime Teleportation

### Solution 1: bfs, prime sieve, set

```cpp
using int64 = int64_t;
const int MAXN = 1e6 + 5;
class Solution {
private:
    static bool isPrime[MAXN];
    static bool precomputed;
    void precompute() {
        if (precomputed) return;
        fill(isPrime, isPrime + MAXN, true);
        isPrime[0] = isPrime[1] = false;
        for (int p = 2; p < MAXN; ++p) {
            if (!isPrime[p]) continue;
            for (int64 i = static_cast<int64>(p) * p; i < MAXN; i += p) {
                isPrime[i] = false;
            }
        }
        precomputed = true;
    }
public:
    int minJumps(vector<int>& nums) {
        precompute();
        int N = nums.size(), maxVal = 0;
        map<int, vector<int>> mapValues;
        for (int i = 0; i < N; ++i) {
            mapValues[nums[i]].emplace_back(i);
            maxVal = max(maxVal, nums[i]);
        }
        set<int> seenPrimes;
        queue<int> q;
        int ans = 0;
        vector<bool> vis(N, false);
        vis[0] = true;
        q.emplace(0);
        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; ++i) {
                int idx = q.front();
                q.pop();
                if (idx == N - 1) return ans;
                if (idx + 1 < N && !vis[idx + 1]) {
                    vis[idx + 1] = true;
                    q.emplace(idx + 1);
                }
                if (idx - 1 >= 0 && !vis[idx - 1]) {
                    vis[idx - 1] = true;
                    q.emplace(idx - 1);
                }
                if (!isPrime[nums[idx]]) continue;
                if (seenPrimes.count(nums[idx])) continue;
                seenPrimes.insert(nums[idx]);
                for (int j = nums[idx]; j <= maxVal; j += nums[idx]) {
                    for (int x : mapValues[j]) {
                        if (vis[x]) continue;
                        vis[x] = true;
                        q.emplace(x);
                    }
                }
            }
            ++ans;
        }
        return -1;
    }
};
bool Solution::precomputed = false;
bool Solution::isPrime[MAXN];
```

## 3630. Partition Array for Maximum XOR and AND

### Solution 1:  linear xor basis, maximum xor subset, bit manipulation trick, bit by bit analysis

The way to figure this is a bit by bit analysis, that is how you can derive the relationship after you know that you want to maximize x + (s ^ x).

This is a good problem actually, it involves breaking it down into smaller component.  If you reformulate the problem correctly you can solve it with a linear xor basis, where you look for the subset of elements to produce with the maximum xor value.  Or rather performing xor operation over all elements of the subset, you want to maximize that reduce operation. 

I'll write down some more of the key observations later. 

Let s = xor of all elements not in B. 
Choose x to maximize x + (s ^ x)
observe that x + (s ^ x) = s + 2 * (x & ~s)

Now choose x to maximize (x & ~s)

It is actually with this change of basis, a maximum xor subset problem now. 

```cpp
using int64 = int64_t;
class Solution {
private:
    vector<int> xorBasis(const vector<int>& A) {
        vector<int> basis;
        for (int a : A) {
            for (int b : basis) {
                a = min(a, a ^ b);
            }
            if (!a) continue;
            for (int &b : basis) {
                b = min(b, b ^ a);
            }
            basis.emplace_back(a);
        }
        sort(basis.rbegin(), basis.rend());
        return basis;
    }
public:
    int64 maximizeXorAndXor(vector<int>& nums) {
        int N = nums.size();
        int64 ans = 0;
        int endMask = 1 << N;
        vector<int> A;
        for (int mask = 0; mask < endMask; ++mask) {
            int64 andSum = 0, s = 0;
            bool firstAnd = true;
            A.clear();
            for (int i = 0; i < N; ++i) {
                if ((mask >> i) & 1) {
                    andSum = firstAnd ? nums[i] : andSum & nums[i];
                    firstAnd = false;
                }
                else s ^= nums[i];
            }
            for (int i = 0; i < N; ++i) {
                if ((mask >> i) & 1) continue;
                A.emplace_back(nums[i] & ~s);
            }
            vector<int> basis = xorBasis(A);
            int64 res = 0;
            for (int b : basis) {
                if ((res ^ b) > res) res ^= b;
            }
            int64 cand = andSum + s + 2 * res;
            ans = max(ans, cand);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 461

## 3638. Maximum Balanced Shipments

### Solution 1: greedy

```cpp
class Solution {
public:
    int maxBalancedShipments(vector<int>& weight) {
        int ans = 0, mx = 0;
        for (int x : weight) {
            mx = max(mx, x);
            if (x < mx) {
                mx = 0;
                ++ans;
            }
        }
        return ans;
    }
};
```

## 3639. Minimum Time to Activate String

### Solution 1:  sum of natural numbers, counting, set of segments

```cpp
using int64 = int64_t;
const int INF = numeric_limits<int>::max();
class Solution {
private:
    int64 calc(int l, int r) {
        int n = r - l + 1;
        return n > 0 ? f(n) : 0;
    }
    int64 f(int64 n) {
        return n * (n + 1) / 2;
    }
public:
    int minTime(string s, vector<int>& order, int k) {
        int N = s.size();
        int64 total = f(N), cur = f(N);
        set<pair<int, int>> segments;
        segments.emplace(0, N - 1);
        for (int i = 0; i < N; ++i) {
            int idx = order[i];
            auto it = segments.upper_bound({idx, INF});
            --it;
            int l = it->first, r = it->second;
            segments.erase(it);
            cur -= calc(l, r);
            if (idx > l) {
                segments.emplace(l, idx - 1);
                cur += calc(l, idx - 1);
            }
            if (idx < r) {
                segments.emplace(idx + 1, r);
                cur += calc(idx + 1, r);
            }
            if (total - cur >= k) return i;
        }
        return -1;
    }
};
```

## 3640. Trionic Array II

### Solution 1: dynamic programming, finite state machine, transitions

```cpp
using int64 = int64_t;
const int64 INF = numeric_limits<int64>::max();
class Solution {
public:
    int64 maxSumTrionic(vector<int>& A) {
        int64 inc1 = -INF, dec = -INF, inc2 = -INF, ans = -INF;
        int N = A.size();
        for (int i = 1; i < N; ++i) {
            int64 ninc1 = -INF, ndec = -INF, ninc2 = -INF;
            if (A[i] > A[i - 1]) {
                ninc1 = A[i - 1] + A[i];
                if (inc1 != -INF) ninc1 = max(ninc1, inc1 + A[i]);
                if (dec != -INF) ninc2 = max(ninc2, dec + A[i]);
                if (inc2 != -INF) ninc2 = max(ninc2, inc2 + A[i]);
            } else if (A[i] < A[i - 1]) {
                if (inc1 != -INF) ndec = max(ndec, inc1 + A[i]);
                if (dec != -INF) ndec = max(ndec, dec + A[i]);
            }
            swap(ninc1, inc1);
            swap(ndec, dec);
            swap(ninc2, inc2);
            ans = max(ans, inc2);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 462

## 3644. Maximum K to Sort a Permutation

### Solution 1: bit manipulation

1. only those out of place will have to be swapped, basically all of those will have to be swapped with each other at some point. 

```cpp
const int INF = numeric_limits<int>::max();
class Solution {
public:
    int sortPermutation(vector<int>& nums) {
        int N = nums.size();
        vector<int> arr = vector<int>(nums.begin(), nums.end());
        sort(arr.begin(), arr.end());
        int ans = INF;
        for (int i = 0; i < N; ++i) {
            if (nums[i] != arr[i]) {
                if (ans == INF) ans = nums[i];
                else ans &= nums[i];
            }
        }
        return ans < INF ? ans : 0;
    }
};
```

## 3645. Maximum Total from Optimal Activation Order

### Solution 1: sorting, greedy

```cpp
using int64 = int64_t;
class Solution {
public:
    int64 maxTotal(vector<int>& value, vector<int>& limit) {
        int N = value.size();
        vector<vector<int>> blocks(N + 1, vector<int>());
        for (int i = 0; i < N; ++i) {
            blocks[limit[i]].emplace_back(value[i]);
        }
        int64 ans = 0;
        for (int i = 0; i <= N; ++i) {
            vector<int> &arr = blocks[i];
            sort(arr.rbegin(), arr.rend());
            int n = arr.size();
            for (int j = 0; j < min(i, n); ++j) {
                ans += arr[j];
            }
        }
        return ans;
    }
};
```

## 3646. Next Special Palindrome Number

### Solution 1:  brute force, string, permutations, reduce space

1. Kind of a brute force with pruning type of problem
2. permutations can be slow, but since the size is only 8 you are good
3. Break down palindromes into components, of side + mid + reverse(side), three parts, where really just 2 parts, and the third part is reverse of first part. 

```cpp
class Solution {
public:
    long long specialPalindrome(long long n) {
        string ans = string(20, 'z'), s = to_string(n);
        for (int mask = 0; mask < (1 << 9); ++mask) {
            string side, mid;
            for (int i = 0; i < 9; ++i) {
                if (!((mask >> i) & 1)) continue;
                int dig = i + 1;
                if (dig & 1) mid += dig + '0';
                side += string(dig / 2, dig + '0');
            }
            int len = mid.size() + 2 * side.size();
            if (side.size() >= 9 || len < s.size() || mid.size() > 1) continue;
            if (len > s.size()) {
                string cand = side + mid + string(side.rbegin(), side.rend());
                if (cand.size() < ans.size()) ans = cand;
                else if (cand.size() == ans.size()) ans = min(ans, cand);
                continue;
            }
            do {
                string cand = side + mid + string(side.rbegin(), side.rend());
                if (cand <= s) continue;
                if (cand.size() < ans.size()) ans = cand;
                else if (cand.size() == ans.size()) ans = min(ans, cand);
            } while (next_permutation(side.begin(), side.end()));
        }
        cout << ans << endl;
        return stoll(ans);
    }
};
```

# Leetcode Weekly Contest 463

## 3652. Best Time to Buy and Sell Stock using Strategy

### Solution 1: prefix sum, suffix sum

```cpp
using int64 = int64_t;
class Solution {
public:
    int64 maxProfit(vector<int>& prices, vector<int>& strategy, int k) {
        int N = prices.size();
        int64 psum = 0, ssum = 0, wsum = 0;
        for (int i = 0; i < N; ++i) {
            ssum += prices[i] * strategy[i];
        }
        int64 ans = ssum;
        for (int i = 0; i < k; ++i) {
            ssum -= prices[i] * strategy[i];
            if (i >= k / 2) wsum += prices[i];
        }
        ans = max(ans, wsum + ssum);
        for (int i = k; i < N; ++i) {
            ssum -= prices[i] * strategy[i];
            wsum += prices[i];
            wsum -= prices[i - k / 2];
            psum += prices[i - k] * strategy[i - k];
            ans = max(ans, psum + wsum + ssum);
        }
        return ans;
    }
};
```

## 3654. Minimum Sum After Divisible Sum Deletions

### Solution 1: prefix max, dynamic programming

```cpp
using int64 = int64_t;
const int64 INF = numeric_limits<int64>::max();
class Solution {
public:
    int64 minArraySum(vector<int>& nums, int k) {
        int N = nums.size();
        vector<int64> pmax(k, -INF), dp(N + 1, -INF);
        dp[0] = pmax[0] = 0;
        int64 psum = 0;
        for (int i = 1; i <= N; ++i) {
            psum += nums[i - 1];
            int r = psum % k;
            dp[i] = dp[i - 1];
            if (pmax[r] != -INF) dp[i] = max(dp[i], psum + pmax[r]);
            pmax[r] = max(pmax[r], dp[i] - psum);          
        }
        return psum - dp[N];
    }
};
```

## 3655. XOR After Range Multiplication Queries II

### Solution 1: square root decomposition, small k/large k trick, residue, modular arithmetic

some more

```cpp
using int64 = int64_t;
const int64 MOD = 1e9 + 7;
struct Query {
    int l, r, k, v;
};
int64 inv(int i, int64 m) {
    return i <= 1 ? i : m - (m / i) * inv(m % i, m) % m;
}
class Solution {
public:
    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& baseQueries) {
        vector<int64> arr = vector<int64>(nums.begin(), nums.end());
        int N = nums.size(), Q = baseQueries.size();
        int BLOCK = sqrt(N);
        vector<vector<Query>> small(BLOCK, vector<Query>());
        vector<Query> large;
        for (const vector<int> &q : baseQueries) {
            int l = q[0], r = q[1], k = q[2], v = q[3];
            if (k < BLOCK) {
                small[k].emplace_back(l, r, k, v);
            } else {
                large.emplace_back(l, r, k, v);
            }
        }
        // large
        for (auto [l, r, k, v] : large) {
            for (int i = l; i <= r; i += k) {
                arr[i] = arr[i] * v % MOD;
            }
        }
        // small
        for (int k = 1; k < BLOCK; ++k) {
            vector<vector<int64>> diff(k, vector<int64>());
            for (int i = 0; i < k; ++i) {
                int S = (N - 1 - i) / k + 1;
                diff[i].assign(S + 1, 1LL);
            }
            for (auto [l, r, _, v] : small[k]) {
                int residue = l % k;
                vector<int64> &curDiff = diff[residue];
                int left = l / k;
                int right = (r - l) / k + left;
                curDiff[left] = curDiff[left] * v % MOD;
                curDiff[right + 1] = curDiff[right + 1] * inv(v, MOD) % MOD;
            }
            for (int i = 0; i < k; ++i) {
                int64 pref = 1;
                for (int j = 0; j < diff[i].size(); ++j) {
                    pref = pref * diff[i][j] % MOD;
                    if (i + j * k < N) arr[i + j * k] = arr[i + j * k] * pref % MOD;
                }
            }
        }
        int ans = accumulate(arr.begin(), arr.end(), 0, [](const int accum, const int x) {
            return accum ^ x;
        });
        return ans;
    }
};
```

# Leetcode Weekly Contest 464

## 3659. Partition Array Into K-Distinct Groups

### Solution 1: map, frequency

```cpp
class Solution {
public:
    bool partitionArray(vector<int>& nums, int k) {
        int N = nums.size();
        if (N % k != 0) return false;
        // find the highest frequency
        int mxFreq = 0;
        map<int, int> freq;
        for (int x : nums) mxFreq = max(mxFreq, ++freq[x]);
        return mxFreq <= N / k;
    }
};
```

## 3660. Jump Game IX

### Solution 1: prefix max, max heap, forward and backward iteration

```cpp
class Solution {
public:
    vector<int> maxValue(vector<int>& nums) {
        int N = nums.size();
        int pmax = 0;
        vector<int> ans(N, -1);
        priority_queue<pair<int, int>> maxheap;
        vector<bool> vis(N, false);
        for (int i = 0; i < N; ++i) {
            pmax = max(pmax, nums[i]);
            maxheap.emplace(pmax, i);
            ans[i] = pmax;
        }
        for (int i = N - 1; i >= 0; --i) {
            vis[i] = true;
            while (!maxheap.empty() && maxheap.top().first > nums[i]) {
                auto [v, j] = maxheap.top();
                maxheap.pop();
                if (vis[j]) continue;
                vis[j] = true;
                ans[j] = ans[i];
            }
        }
        return ans;
    }
};
```

## 3661. Maximum Walls Destroyed by Robots

### Solution 1: sorting, dynamic programming, binary search

```cpp
const int INF = 1e9 + 5;
class Solution {
public:
    int maxWalls(vector<int>& robots, vector<int>& distance, vector<int>& A) {
        robots.emplace_back(-INF);
        distance.emplace_back(0);
        robots.emplace_back(INF);
        distance.emplace_back(0);
        int N = robots.size();
        vector<pair<int, int>> robDist;
        for (int i = 0; i < N; ++i) {
            robDist.emplace_back(robots[i], distance[i]);
        }
        sort(robDist.begin(), robDist.end());
        sort(A.begin(), A.end());
        int ans = 0;
        for (int i = 0; i < N; ++i) {
            robots[i] = robDist[i].first;
            distance[i] = robDist[i].second;
        }
        vector<int> walls;
        for (int i = 0, j = 0; i < A.size(); ++i) {
            while (j < N && robots[j] < A[i]) ++j;
            if (A[i] == robots[j]) {
                ++ans;
                continue;
            }
            walls.emplace_back(A[i]);
        }
        vector<int> L(N, 0), R(N, 0);
        for (int i = 1; i + 1 < N; ++i) {
            int leftPoint = max(robots[i] - distance[i], robots[i - 1]);
            int rightPoint = min(robots[i] + distance[i], robots[i + 1]);
            int m = upper_bound(walls.begin(), walls.end(), robots[i]) - walls.begin();
            int l = lower_bound(walls.begin(), walls.end(), leftPoint) - walls.begin();
            int r = upper_bound(walls.begin(), walls.end(), rightPoint) - walls.begin();
            L[i] = m - l, R[i] = r - m;
        }
        int dpL = 0, dpR = 0;
        for (int i = 1; i < N; ++i) {
            int ndpL = dpL + L[i];
            int l = lower_bound(walls.begin(), walls.end(), robots[i - 1]) - walls.begin();
            int r = upper_bound(walls.begin(), walls.end(), robots[i]) - walls.begin();
            int delta = max(0, R[i - 1] + L[i] - (r - l));
            ndpL = max(ndpL, dpR + L[i] - delta);
            int ndpR = max(dpL, dpR) + R[i];
            swap(ndpL, dpL); swap(ndpR, dpR);
        }
        return max(dpL, dpR) + ans;
    }
};
```

# Leetcode Weekly Contest 465

## 3669. Balanced K-Factor Decomposition

### Solution 1: recursion, dfs, backtracking, divisors

```cpp
const int INF = numeric_limits<int>::max();
class Solution {
private:
    int best;
    vector<int> cur, ans, div;
    void dfs(int val, int k, int lastVal) {
        if (k == 1) {
            if (val >= lastVal) {
                cur.emplace_back(val);
                int cand = cur.back() - cur.front();
                if (cand < best) {
                    best = cand;
                    ans = cur;
                }
                cur.pop_back();
            }
            return;
        }
        for (int d : div) {
            if (d < lastVal) continue;
            if (d > val) break;
            if (val % d != 0) continue;
            cur.emplace_back(d);
            dfs(val / d, k - 1, d);
            cur.pop_back();
        }
    }
public:
    vector<int> minDifference(int n, int k) {
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                div.emplace_back(i);
                if (i * i < n) div.emplace_back(n / i);
            }
        }
        best = INF;
        sort(div.begin(), div.end());
        dfs(n, k, 1);
        return ans;
    }
};
```

## 3670. Maximum Product of Two Integers With No Common Bits

### Solution 1:  sos dp, bit dp

```cpp
using int64 = int64_t;
class Solution {
public:
    int64 maxProduct(vector<int>& nums) {
        int maxVal = *max_element(nums.begin(), nums.end());
        int LOG = 0;
        while ((1 << LOG) <= maxVal) ++LOG;
        int endMask = (1 << LOG) - 1;
        vector<int> dp(1 << LOG, -1);
        for (int x : nums) dp[x] = x;
        // sos dp for maxima
        for (int i = 0; i < LOG; ++i) { // iterate over bits
            for (int mask = 0; mask <= endMask; ++mask) { // iterate over all masks
                if ((mask >> i) & 1) dp[mask] = max(dp[mask], dp[mask ^ (1 << i)]); // subset
            }
        }
        int64 ans = 0;
        for (int x : nums) {
            int64 y = dp[endMask ^ x];
            ans = max(ans, y * x);
        }
        return ans;
    }
};
```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 466

## 3675. Minimum Operations to Transform String

### Solution 1: greedy

```cpp
class Solution {
public:
    int minOperations(string s) {
        vector<bool> exists(26, false);
        for (char ch : s) {
            if (ch == 'a') continue;
            exists[ch - 'a'] = true;
        }
        for (int i = 1; i < 26; ++i) {
            if (exists[i]) return 26 - i;
        }
        return 0;
    }
};
```

## 3676. Count Bowl Subarrays

### Solution 1: monotonically decreasing stack

```cpp
using int64 = int64_t;
class Solution {
public:
    int64 bowlSubarrays(vector<int>& nums) {
        int N = nums.size();
        int64 ans = 0;
        stack<int> stk;
        for (int i = 0; i < N; ++i) {
            while (!stk.empty() && nums[i] > nums[stk.top()]) {
                if (stk.size() > 1) ans++;
                stk.pop();
            }
            stk.emplace(i);
        }
        return ans;
    }
};
```

## 3677. Count Binary Palindromic Numbers

### Solution 1: math, palindrome

1. find all palindromes with length < bitWidth
2. find all palindromes of same length, can count by taking the minPrefix and current prefix
3. Determine if n itself is a palindrome

```cpp
class Solution {
public:
    int countBinaryPalindromes(long long n) {
        if (!n) return 1;
        int msb = static_cast<int>(log2(n));
        int bitWidth = msb + 1;
        int ans = 2;
        for (int i = 1; i <= msb / 2; ++i) {
            // length 2 * i
            ans += (1 << (i - 1));
            // length 2 * i + 1
            if (2 * i + 1 < bitWidth) {
                ans += 2 * (1 << (i - 1));
            }
        }
        bool isPalindrome = true;
        for (int i = 0; i < bitWidth / 2; ++i) {
            int j = msb - i;
            int b1 = (n >> i) & 1;
            int b2 = (n >> j) & 1;
            if (b1 != b2) isPalindrome = false;
        }
        ans += isPalindrome;
        return ans;
    }
};
```

# Leetcode Weekly Contest 467

## 3684. Maximize Sum of At Most K Distinct Elements

### Solution 1: distinct, sorting, greedy

```cpp
class Solution {
public:
    vector<int> maxKDistinct(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        sort(nums.rbegin(), nums.rend());
        vector<int> ans;
        int N = nums.size();
        for (int i = 0; i < k && i < N; ++i) {
            ans.emplace_back(nums[i]);
        }
        return ans;
    }
};
```

## 3685. Subsequence Sum After Capping Elements

### Solution 1: subset sum, bitset, bit shift, rolling dp

```cpp
const int MAXK = 4005;
class Solution {
public:
    vector<bool> subsequenceSumAfterCapping(vector<int>& nums, int k) {
        int N = nums.size();
        vector<bool> ans(N, false);
        bitset<MAXK> sum;
        sum.set(0);
        vector<int> freq(N + 1, 0);
        for (int x : nums) freq[x]++;
        int suf = N;
        for (int x = 1; x <= N; ++x) {
            for (int i = 0; i <= suf && i * x <= k; ++i) {
                int need = k - i * x;
                if (sum.test(need)) ans[x - 1] = true;
            }
            for (int i = 0; i < freq[x]; ++i) {
                suf--;
                sum |= (sum << x);
            }
        }
        return ans;
    }
};
```

## 3686. Number of Stable Subsequences

### Solution 1: dynamic programming, counting

```cpp
const int MOD = 1e9 + 7;
class Solution {
public:
    int countStableSubsequences(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(4, 0); // 0, 00, 1, 11
        for (int x : nums) {
            if (x % 2 == 0) {
                dp[1] = (dp[1] + dp[0]) % MOD;
                dp[0] = (dp[0] + dp[2]) % MOD;
                dp[0] = (dp[0] + dp[3]) % MOD;
                dp[0] = (dp[0] + 1) % MOD;
            } else {
                dp[3] = (dp[3] + dp[2]) % MOD;
                dp[2] = (dp[2] + dp[0]) % MOD;
                dp[2] = (dp[2] + dp[1]) % MOD;
                dp[2] = (dp[2] + 1) % MOD;
            }
        }
        int ans = 0;
        for (int x : dp) {
            ans = (ans + x) % MOD;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 468

## 3689. Maximum Total Subarray Value I

### Solution 1: min, max

```cpp
using int64 = long long;
class Solution {
public:
    int64 maxTotalValue(vector<int>& nums, int k) {
        int64 minVal = *min_element(nums.begin(), nums.end());
        int64 maxVal = *max_element(nums.begin(), nums.end());
        int64 delta = maxVal - minVal;
        return delta * k;
    }
};
```

## 3690. Split and Merge Array Transformation

### Solution 1: queue, bfs, set, memoized

```cpp
class Solution {
public:
    int minSplitMerge(vector<int>& nums1, vector<int>& nums2) {
        int N = nums1.size();
        set<vector<int>> seen;
        queue<vector<int>> q;
        q.emplace(nums1);
        seen.insert(nums1);
        int ans = 0;
        while (!q.empty()) {
            int sz = q.size();
            while (sz--) {
                vector<int> arr = q.front();
                q.pop();
                if (ranges::equal(arr, nums2)) return ans;
                for (int l = 0; l < N; ++l) {
                    for (int r = l; r < N; ++r) {
                        vector<int> subarr(arr.begin() + l, arr.begin() + r + 1);
                        vector<int> rest;
                        rest.reserve(arr.size() - (r - l + 1));
                        rest.insert(rest.end(), arr.begin(), arr.begin() + l);
                        rest.insert(rest.end(), arr.begin() + r + 1, arr.end());
                        int n = rest.size();
                        for (int i = 0; i <= n; ++i) {
                            if (i == l) continue;
                            vector<int> narr;
                            narr.reserve(N);
                            narr.insert(narr.end(), rest.begin(), rest.begin() + i);
                            narr.insert(narr.end(), subarr.begin(), subarr.end());
                            narr.insert(narr.end(), rest.begin() + i, rest.end());
                            if (!seen.count(narr)) {
                                seen.insert(narr);
                                q.emplace(narr);
                            }
                        }
                    }
                }
            }
           ans++;
        }
        return -1;
    }
};
```

## 

### Solution 1: 

```cpp

```

# Leetcode Weekly Contest 469

## 3698. Split Array With Minimum Difference

### Solution 1: gready, peak finding

```cpp
using int64 = long long;
class Solution {
public:
    int64 splitArray(vector<int>& nums) {
        int N = nums.size();
        // find peak, should only be one
        int peak = N - 1;
        for (int i = 1; i < N; ++i) {
            if (nums[i - 1] == nums[i]) {
                peak = i;
                break;
            }
            if (nums[i - 1] > nums[i]) {
                peak = i - 1;
                break;
            }
        }
        int64 left = 0, right = 0;
        for (int i = 1; i < N; ++i) {
            if (i > peak && nums[i] >= nums[i - 1]) return -1;
        }
        for (int i = 0; i < N; ++i) {
            if (i < peak) left += nums[i];
            else right += nums[i];
        }
        int64 ans = abs(right - left);
        if (peak < N) {
            left += nums[peak];
            right -= nums[peak];
            ans = min(ans, abs(right - left));
        }
        return ans;
    }
};
```

## 3699. Number of ZigZag Arrays I

### Solution 1: dynamic programming, transitions, linear recurrence, prefix sum optimization, suffix sum optimization

```cpp
using int64 = long long;
const int MOD = 1e9 + 7;
class Solution {
public:
    int zigZagArrays(int n, int l, int r) {
        int M = r - l + 1;
        vector<int64> dpU(M, 0), dpD(M, 0), newU(M, 0), newD(M, 0);
        for (int i = 0; i < M; ++i) {
            dpU[i] = i;
            dpD[i] = M - i - 1;
        }
        for (int i = 3; i <= n; ++i) {
            newU.assign(M, 0);
            newD.assign(M, 0);
            vector<int64> sufU(M, 0), prefD(M, 0);
            for (int j = 0; j < M; ++j) {
                prefD[j] = dpD[j];
                if (j > 0) {
                    prefD[j] += prefD[j - 1];
                    prefD[j] %= MOD;
                }
            }
            for (int j = M - 1; j >= 0; --j) {
                sufU[j] = dpU[j];
                if (j + 1 < M) {
                    sufU[j] += sufU[j + 1];
                    sufU[j] %= MOD;
                }
            }
            for (int j = 0; j < M; ++j) {
                if (j > 0) newU[j] = prefD[j - 1];
                if (j + 1 < M) newD[j] = sufU[j + 1];
            }
            swap(dpU, newU);
            swap(dpD, newD);
        }
        int ans = 0;
        for (int i = 0; i < M; ++i) {
            ans = (ans + dpU[i]) % MOD;
            ans = (ans + dpD[i]) % MOD;
        }
        return ans;
    }
};
```

## 3700. Number of ZigZag Arrays II

### Solution 1: matrix exponentiation, linear recurrence, transitions, dynamic programming

1. suffix and prefix sum similar to problem above can be utilized with specific all ones upper and lower triangular matrices. 
1. Combine the increasing and decreasing states into a 2M column vector

```cpp
using int64 = long long;
const int MOD = 1e9 + 7;
vector<vector<int64>> transitionMatrix, baseMatrix;

vector<vector<int64>> matMul(const vector<vector<int64>>& mat1, const vector<vector<int64>>& mat2) {
    int rows1 = mat1.size(), cols1 = mat1[0].size();
    int rows2 = mat2.size(), cols2 = mat2[0].size();
    vector<vector<int64>> resultMatrix(rows1, vector<int64>(cols2, 0));
    for (int i = 0; i < rows1; i++) {
        for (int j = 0; j < cols2; j++) {
            for (int k = 0; k < cols1; k++) {
                resultMatrix[i][j] = (resultMatrix[i][j] + mat1[i][k] * mat2[k][j]) % MOD;
            }
        }
    }
    return resultMatrix;
}

vector<vector<int64>> matPow(const vector<vector<int64>>& matrix, int power) {
    if (power <= 0) {
        cout << "n must be non-negative integer" << endl;
        return {};
    }
    if (power == 1) return matrix;
    if (power == 2) return matMul(matrix, matrix);

    vector<vector<int64>> t1 = matPow(matrix, power / 2);
    if (power % 2 == 0) {
        return matMul(t1, t1);
    }
    return matMul(t1, matMul(matrix, t1));
}

class Solution {
public:
    int zigZagArrays(int n, int l, int r) {
        int M = r - l + 1;
        baseMatrix.assign(2 * M, vector<int64>(1, 0));
        for (int i = 0; i < M; i++) {
            baseMatrix[i][0] = i; // increasing
            baseMatrix[i + M][0] = M - i - 1; // decreasing
        }
        transitionMatrix.assign(2 * M, vector<int64>(2 * M, 0));
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < M; ++j) {
                if (j < i) transitionMatrix[i][j + M] = 1;
                if (j > i) transitionMatrix[i + M][j] = 1;
            }
        }
        vector<vector<int64>> exponentiatedMatrix = matPow(transitionMatrix, n - 2);
        vector<vector<int64>> solutionMatrix = matMul(exponentiatedMatrix, baseMatrix);
        int64 ans = 0;
        for (int i = 0; i < 2 * M; i++) {
            ans = (ans + solutionMatrix[i][0]) % MOD;
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 470

## 3702. Longest Subsequence With Non-Zero Bitwise XOR

### Solution 1: 

```cpp
class Solution {
public:
    int longestSubsequence(vector<int>& nums) {
        int N = nums.size();
        int ans = accumulate(nums.begin(), nums.end(), 0, [](int total, int x) {
            return total ^ x;
        });
        if (ans > 0) return N;
        if (any_of(nums.begin(), nums.end(), [](const int x) {
            return x > 0;
        })) return N - 1;
        return 0;
    }
};
```

## 3703. Remove K-Balanced Substrings

### Solution 1: 

```cpp
class Solution {
public:
    string removeSubstring(string s, int k) {
        // track count of ( and )
        // track number of times I can remove
        vector<int> stk, counts;
        for (const char ch : s) {
            if (ch == '(') {
                if (!stk.empty() && stk.back() == '(') {
                    counts.emplace_back(counts.back() + 1);
                } else {
                    counts.emplace_back(1);
                }
            } else {
                if (!stk.empty() && stk.back() == ')') {
                    counts.emplace_back(counts.back() + 1);
                } else {
                    counts.emplace_back(1);
                }
            }
            stk.emplace_back(ch);
            if (ch == ')' && counts.back() == k && counts.size() > k && counts.end()[-k - 1] >= k) {
                for (int i = 0; i < 2 * k; ++i) {
                    stk.pop_back();
                    counts.pop_back();
                }
            }
        }
        string ans(stk.begin(), stk.end());
        return ans;
    }
};
```

## 3704. Count No-Zero Pairs That Sum to N

### Solution 1: digit dp, lsb to msb, memoized recursion, arithmetic and carry

This is digit dp from opposite direction of normal where you go from msb to lsb and you have the zero and tight parameter, where the zero parameter allows you to create numbers that are fewer digits, here I do that with the za and zb, where I note where the rest of the digits are going to be zero. 

1. Direction and target
It runs digit DP from least significant to most significant, matching each computed sum digit to the fixed digit of n at that position. There is no usual tight flag because the target at each position is already determined by n and the carry.
2. Variable length via zero-absorbing flags
za and zb act as on or off switches for A and B. While za is 1 you must pick da in 1..9. You can flip za to 0 at any step to say that all higher digits of A are zero from here on. Same for zb. This neatly models numbers of different lengths and enforces no zero digits without separate leading-zero handling.
3. State and transitions
The DP state is (pos, carry, za, zb) with pos up to 16. For each state you try digits da and db that respect za and zb, require (da + db + carry) % 10 to equal the target digit, and recurse with the new carry. You also branch on optionally turning off za and or zb. Total states are tiny and each explores at most 9 by 9 choices, so it is fast and simple to memoize.

```cpp
using int64 = long long;
class Solution {
private:
    vector<int> digits, values = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int N;
    int64 dp[16][2][2][2];
    int64 dfs(int pos, int carry, int za, int zb) {
        if (pos == N) {
            return !carry && !za && !zb ? 1 : 0;
        }
        if (dp[pos][carry][za][zb] != -1) return dp[pos][carry][za][zb];
        int64 ans = 0;
        for (int da = 0; da < 10; ++da) {
            if (za && da == 0) continue;
            if (!za && da != 0) continue;
            for (int db = 0; db < 10; ++db) {
                if (zb && db == 0) continue;
                if (!zb && db != 0) continue;
                int curSum = da + db + carry;
                int dig = curSum % 10;
                if (dig != digits[pos]) continue;
                ans += dfs(pos + 1, curSum / 10, za, zb);
                if (za) ans += dfs(pos + 1, curSum / 10, 0, zb);
                if (zb) ans += dfs(pos + 1, curSum / 10, za, 0);
                if (za && zb) ans += dfs(pos + 1, curSum / 10, 0, 0);
            }
        }
        return dp[pos][carry][za][zb] = ans;
    }
public:
    int64 countNoZeroPairs(int64 n) {
        while (n > 0) {
            digits.emplace_back(n % 10);
            n /= 10;
        }
        N = digits.size();
        fill(&dp[0][0][0][0], &dp[0][0][0][0] + 16 * 2 * 2 * 2, -1);
        return dfs(0, 0, 1, 1);
    }
};
```

# Leetcode Weekly Contest 471

## 3713. Longest Balanced Substring I

### Solution 1: prefix sum, frequency counting

```cpp
class Solution {
private:
    int rangeSum(const vector<int> &ps, int l, int r) {
        int ans = ps[r];
        if (l > 0) ans -= ps[l - 1];
        return ans;
    }
    vector<int> query(const vector<vector<int>> &ps, int l, int r) {
        vector<int> ans(26, 0);
        for (int i = 0; i < 26; ++i) {
            ans[i] = rangeSum(ps[i], l, r);
        }
        return ans;
    }
public:
    int longestBalanced(string s) {
        int N = s.size();
        vector<vector<int>> psum(26, vector<int>(N, 0));
        for (int i = 0; i < N; ++i) {
            psum[s[i] - 'a'][i] = 1;
            if (i == 0) continue;
            for (int j = 0; j < 26; ++j) {
                psum[j][i] += psum[j][i - 1];
            }
        }
        int ans = 1;
        for (int l = 0; l < N; ++l) {
            for (int r = l + 1; r < N; ++r) {
                if (r - l + 1 <= ans) continue;
                vector<int> freq = query(psum, l, r);
                bool flag = true;
                int cnt = 0;
                for (int x : freq) {
                    if (x == 0) continue;
                    if (cnt == 0) {
                        cnt = x;
                        continue;
                    }
                    if (cnt != x) {
                        flag = false;
                        break;
                    }
                }
                if (!flag) continue;
                ans = r - l + 1;
            }
        }
        return ans;
    }
};
```

## 3714. Longest Balanced Substring II

### Solution 1: prefix difference, hash map, counting, case by case analysis

1. use concept of prefix difference to find substrings with equal counts of characters

```cpp
class Solution {
private:
    int N;
    vector<int> A;
    int case1() {
        int N = A.size(), cnt = 0, val = 0, ans = 0;
        for (int i = 0; i < N; ++i) {
            if (A[i] != val) {
                cnt = 0;
            }
            cnt++;
            val = A[i];
            ans = max(ans, cnt);
        }
        return ans;
    }
    int case2(int a, int b) {
        int N = A.size(), da = 0, db = 0, ans = 0;
        unordered_map<int, int> seen;
        seen[0] = -1;
        for (int i = 0; i < N; ++i) {
            if (A[i] != a && A[i] != b) {
                seen.clear();
                da = 0, db = 0;
                seen[0] = i;
                continue;
            }
            if (A[i] == a) da++;
            else db++;
            if (seen.count(da - db)) {
                ans = max(ans, i - seen[da - db]);
                continue;
            };
            seen[da - db] = i;
        }
        return ans;
    }
    int case3() {
        int N = A.size(), f[3] = {}, ans = 0;
        map<pair<int, int>, int> seen;
        seen[{0, 0}] = -1;
        for (int i = 0; i < N; ++i) {
            f[A[i]]++;
            int p1 = f[1] - f[0], p2 = f[2] - f[0];
            if (seen.count({p1, p2})) {
                ans = max(ans, i - seen[{p1, p2}]);
                continue;
            }
            seen[{p1, p2}] = i;
        }
        return ans;
    }
public:
    int longestBalanced(string s) {
        int N = s.size();
        for (char ch : s) {
            A.emplace_back(ch - 'a');
        }
        int ans = max({ case1(), case2(0, 1), case2(0, 2), case2(1, 2), case3() });
        return ans;
    }
};
```

## 3715. Sum of Perfect Square Ancestors

### Solution 1: tree, backtracking dfs, sieve, number theory, square free sieve, map counting

```cpp
using int64 = long long;
const int MAXN = 1e5 + 5;
class Solution {
private:
    vector<int> A;
    int dp[MAXN];
    int64 ans;
    vector<vector<int>> adj;
    map<int64, int> cnt;
    void dfs(int u, int p = -1) {
        int64 val = dp[A[u]];
        ans += cnt[val];
        cnt[val]++;
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs(v, u);
        }
        cnt[val]--;
    }
public:
    int64 sumOfAncestors(int n, vector<vector<int>>& edges, vector<int>& nums) {
        A = nums;
        adj.assign(n, vector<int>());
        for (const auto &edge : edges) {
            int u = edge[0], v = edge[1];
            adj[u].emplace_back(v);
            adj[v].emplace_back(u);
        }
        // sieve
        for (int i = 0; i < MAXN; ++i) dp[i] = i;
        for (int i = 2; 1LL * i * i < MAXN; ++i) {
            int sq = 1LL * i * i;
            for (int j = sq; j < MAXN; j += sq) {
                while (dp[j] % sq == 0) dp[j] /= sq;
            }
        }
        ans = 0;
        dfs(0);
        return ans;
    }
};
```

# Leetcode Weekly Contest 472

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```