# Leetcode Weekly Contest 450-499

# Leetcode Weekly Contest 450

## Minimum Swaps to Sort by Digit Sum

### Solution 1:  permutation cycles, swaps, disjoint sets

```cpp
struct Item {
    int dsum, val, idx;
    Item(int dsum, int val, int idx) : dsum(dsum), val(val), idx(idx) {}
    bool operator<(const Item &other) const {
        if (dsum != other.dsum) return dsum < other.dsum;
        return val < other.val;
    }
};
class Solution {
private:
    int digitSum(int x) {
        int ans = 0;
        while (x > 0) {
            ans += x % 10;
            x /= 10;
        }
        return ans;
    }
public:
    int minSwaps(vector<int>& nums) {
        int N = nums.size();
        vector<Item> arr;
        for (int i = 0; i < N; i++) {
            arr.emplace_back(digitSum(nums[i]), nums[i], i);
        }
        sort(arr.begin(), arr.end());
        vector<int> out(N, 0);
        vector<bool> vis(N, false);
        for (int i = 0; i < N; i++) {
            out[i] = arr[i].idx;
        }
        int ans = 0;
        for (int i = 0; i < N; i++) {
            if (vis[i]) continue;
            int sz = 0, u = i;
            while (!vis[u]) {
                vis[u] = true;
                sz++;
                u = out[u];
            }
            ans += sz - 1;
        }
        return ans;
    }
};
```

## Grid Teleportation Traversal

### Solution 1: 0-1 bfs, deque, distances

```cpp
const int INF = 1e9;
class Solution {
private:
    int R, C;
    vector<pair<int, int>> neighborhood(int r, int c) {
        return {{r - 1, c}, {r + 1, c}, {r, c - 1}, {r, c + 1}};
    }
    bool inBounds(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    int decode(char ch) {
        return ch - 'A';
    }
public:
    int minMoves(vector<string>& grid) {
        R = grid.size(), C = grid[0].size();
        vector<vector<int>> dist(R, vector<int>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dist[0][0] = 0;
        vector<vector<pair<int, int>>> portals(26);
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (grid[r][c] >= 'A' && grid[r][c] <= 'Z') portals[decode(grid[r][c])].emplace_back(r, c);
            }
        }
        deque<pair<int, int>> dq;
        dq.emplace_back(0, 0);
        while (!dq.empty()) {
            auto [r, c] = dq.front();
            dq.pop_front();
            if (r == R - 1 && c == C - 1) return dist[r][c];
            for (auto [nr, nc] : neighborhood(r, c)) {
                if (!inBounds(nr, nc) || grid[nr][nc] == '#' || dist[r][c] + 1 >= dist[nr][nc]) continue;
                dist[nr][nc] = dist[r][c] + 1;
                dq.emplace_back(nr, nc);
            }
            if (grid[r][c] >= 'A' && grid[r][c] <= 'Z') {
                if (vis[r][c]) continue;
                vis[r][c] = true;
                for (auto [nr, nc] : portals[decode(grid[r][c])]) {
                    if (dist[r][c] < dist[nr][nc]) {
                        vis[nr][nc] = true;
                        dist[nr][nc] = dist[r][c];
                        dq.emplace_front(nr, nc);
                    }
                }
            }
        }
        return -1;
    }
};
```

## Minimum Weighted Subgraph With the Required Paths II

### Solution 1: minimum spanning tree of three nodes, three nodes, binary jumping, lca, depth, dfs, root distance


### Step 1: The Minimal Subtree
- In a tree, there's exactly one unique path between any pair of nodes.
- The minimal subtree `S` connecting nodes `{A, B, C}` is the **union** of the three simple paths:
  - `P_AB`: the path from A to B
  - `P_BC`: the path from B to C
  - `P_CA`: the path from C to A

This subtree `S` is connected and contains all nodes and edges needed to reach any of the three nodes from the others.

---

### Step 2: Consider Any Edge in the Subtree

Pick any edge `e` in `S`, with weight `w`.

Removing `e` splits the tree (and thus `S`) into two parts: say `X` and `Y`.

Since `S` contains exactly the nodes `{A, B, C}`, those nodes must be split between `X` and `Y`.

**Observation:**  
- One part must contain **exactly one** of the three nodes, and the other must contain the other two.
- For example, suppose:
  - `A` is in `X`
  - `B` and `C` are in `Y`

---

### Step 3: Count How Often `e` Is Used

In this situation:

- The path `A → B` **must** cross `e` → counted once
- The path `A → C` **must** cross `e` → counted again
- The path `B → C` stays entirely in `Y` → does **not** use `e`

So edge `e` is included in **exactly 2** of the 3 pairwise paths among `{A, B, C}`.

---

### Step 4: Generalize to All Edges

Every edge `e` in the minimal subtree `S` will separate one node from the other two (because the tree is acyclic and connected). So, **every edge in `S` is used in exactly 2 of the 3 distances**:

- `dist(A, B)`
- `dist(B, C)`
- `dist(C, A)`

Thus:

```cpp
struct Tree {
    int N, LOG;
    vector<vector<pair<int,int>>> adj;
    vector<int> depth, parent, dist;
    vector<vector<int>> up;

    Tree(int n) : N(n) {
        LOG = 20;
        adj.assign(N, vector<pair<int, int>>());
        depth.assign(N, 0);
        parent.assign(N, -1);
        dist.assign(N, 0);
        up.assign(LOG, vector<int>(N, -1));
    }
    void addEdge(int u, int v, int w = 1) {
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    void preprocess(int root = 0) {
        dfs(root);
        buildLiftingTable();
    }
    int kthAncestor(int u, int k) const {
        for (int i = 0; i < LOG && u != -1; i++) {
            if ((k >> i) & 1) {
                u = up[i][u];
            }
        }
        return u;
    }
    int lca(int u, int v) const {
        if (depth[u] < depth[v]) swap(u, v);
        // Bring u up to the same depth as v
        u = kthAncestor(u, depth[u] - depth[v]);
        if (u == v) return u;
        // Binary lift both
        for (int i = LOG - 1; i >= 0; i--) {
            if (up[i][u] != up[i][v]) {
                u = up[i][u];
                v = up[i][v];
            }
        }
        // Now parents are equal
        return parent[u];
    }
    int distance(int u, int v) const {
        int a = lca(u, v);
        return dist[u] + dist[v] - 2 * dist[a];
    }
private:
    void dfs(int u, int p = -1) {
        parent[u] = p;
        up[0][u] = p;
        for (auto &[v, w] : adj[u]) {
            if (v == p) continue;
            depth[v] = depth[u] + 1;
            dist[v] = dist[u] + w;
            dfs(v, u);
        }
    }
    void buildLiftingTable() {
        for (int i = 1; i < LOG; i++) {
            for (int j = 0; j < N; j++) {
                if (up[i - 1][j] == -1) continue;
                up[i][j] = up[i - 1][up[i - 1][j]];
            }
        }
    }
};
class Solution {
public:
    vector<int> minimumWeight(vector<vector<int>>& edges, vector<vector<int>>& queries) {
        int N = edges.size() + 1;
        Tree tree(N);
        for (const vector<int> &edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            tree.addEdge(u, v, w);
        }
        tree.preprocess();
        vector<int> ans;
        for (const vector<int> &query : queries) {
            int u = query[0], v = query[1], d = query[2];
            int du = tree.distance(u, d), dv = tree.distance(v, d), duv = tree.distance(u, v);
            int res = (du + dv + duv) / 2;
            ans.emplace_back(res);
        }
        return ans;
    }
};
```

# Leetcode Weekly Contest 451

## 3563. Lexicographically Smallest String After Adjacent Removals

### Solution 1: interval dp, lexicographically smallest

The algorithm uses 2D dynamic programming to mark erasable substrings and 1D DP to construct the optimal string.
The lexicographical optimization is greedy but bounded by valid erase operations.

Interval feasibility DP (canErase)
- Many string-erase or bracket-matching problems reduce to asking “can this substring be fully removed?” That’s a classic interval DP: build up from small intervals (length 2) to larger ones, checking:
- Direct removal (pair of characters),
- Nested removal (peel off outer pair and rely on inner),
- Concatenation (split into two erasable pieces).

Suffix optimization DP (dp)
- Once we know which substrings we’re free to drop, the remaining task reduces to “choose which erasable blocks to remove so that what’s left is lexicographically smallest.” That’s a linear DP over suffixes, where at each position you make the optimal local choice (erase or keep) and rely on already computed optimal answers for the remainder.

```cpp
class Solution {
private:
    int absDistance(char a, char b) {
        return abs(a - b);
    }
public:
    string lexicographicallySmallestString(string s) {
        int N = s.size();
        vector<vector<bool>> canErase(N + 1, vector<bool>(N + 1, false));
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j += 2) {
                int dist = absDistance(s[i], s[j]);
                if (dist == 1 || dist == 25) {
                    if (j - i + 1 == 2) canErase[i][j] = true;
                    else if (canErase[i + 1][j - 1]) canErase[i][j] = true;
                }
                for (int k = i + 1; k < j; k++) {
                    if (canErase[i][k] && canErase[k + 1][j]) canErase[i][j] = true;
                }
            }
        }
        vector<string> dp(N + 1);
        for (int i = N - 1; i >= 0; i--) {
            string ans = s.substr(i, N);
            for (int j = i; j < N; j++) {
                string cand = "";
                if (!canErase[i][j]) cand = s.substr(i, j - i + 1);
                cand += dp[j + 1];
                ans = min(ans, cand);
            }
            dp[i] = ans;
        }
        return dp[0];
    }
};
```

## 3562. Maximum Profit from Trading Stocks with Discounts

### Solution 1: knapsack convolution, tree shaped knapsack, dp on tree, dfs

## Overview

This algorithm addresses a **resource allocation problem** over a **hierarchical tree of projects**. Each node represents a project characterized by:

- **Cost** (current investment)  
- **Gain** (future return)

Given a **global budget constraint**, the goal is to **maximize total profit** by selectively investing in projects. Some projects may be executed at a **discounted cost**, and investments must respect **hierarchical dependencies**

---

## Key Concepts

### Tree Hierarchy  
Projects form a **rooted tree**, where investing in a project is only valid if its parent has already been processed (i.e., considered for investment). This enforces a top-down dependency structure.

### Dynamic Programming (DP)  
The algorithm performs a **bottom-up DP traversal** (via DFS), computing the optimal profit for each subtree for **all possible budget values** up to the given limit. Each node maintains a DP array where:

- `dp[b]` = maximum profit achievable in the subtree using `b` units of budget.

### Max-Plus Convolution  
To combine results from multiple child subtrees, the algorithm uses a **max-plus convolution**—a variation of the knapsack merge. This operation merges two DP arrays (from child subtrees), preserving the **best profit for every feasible budget split**.

### Discounted Investment  
Each project may optionally be undertaken at **half the original cost**, providing an extra decision branch per node. This adds flexibility in budget usage and can increase total returns.

---

## Algorithm Pillars

The approach rests on three main ideas:

1. **DFS on the Dependency Tree**  
   Traverse the project tree in post-order to ensure subproblems (child nodes) are solved before parent nodes.

2. **Knapsack-Style DP Arrays**  
   Each node maintains a DP array of size `B + 1`, where `B` is the total budget. The array stores the **maximum gain** for each budget level within its subtree.

3. **Merging via Max Convolution + Local Decision Step**  
   - Combine children's DP arrays using **max convolution** to explore all ways of splitting budget between subprojects.  
   - Apply a **local decision step**: for the current project, consider investing at full cost, discounted cost, or not at all, and update the DP accordingly.

---

## Max-Plus Convolution: When and Why?

Max convolution is critical when:

- Subtrees (subproblems) are **independent**  
- A **shared global constraint** (budget) applies  
- The objective is to **maximize/minimize** a quantity over all valid resource splits  
- Each subtree provides a DP table mapping `cost → best outcome`

In essence, it answers:

> "Given multiple DP arrays, how can we merge them optimally under a shared budget constraint?"

---

## Time Complexity

**O(N × B²)**, where:

- `N` is the number of nodes (projects)  
- `B` is the total budget

This is acceptable under typical constraints, especially with optimizations like pruning or efficient convolution techniques.

---

## Key Questions for Implementation

- **DFS DP**:  
  Can I perform DFS and compute a DP array at each node based on its children?

- **State Design**:  
  Do I need multiple DP states per node to track whether the parent was chosen?

- **Merging Strategy**:  
  Can child DP arrays be combined using a knapsack-like convolution?

```cpp
class Solution {
private:
    int RESOURCE_LIMIT;
    vector<vector<int>> adj;
    vector<int> costs, gains;
    vector<int> maxPlusConvolve(const vector<int> &A, const vector<int> &B) {
        vector<int> ans(RESOURCE_LIMIT + 1, 0);
        for (int i = 0; i <= RESOURCE_LIMIT; i++) {
            for (int j = 0; i + j <= RESOURCE_LIMIT; j++) {
                ans[i + j] = max(ans[i + j], A[i] + B[j]);
            }
        }
        return ans;
    }
    pair<vector<int>, vector<int>> dfs(int u) {
        vector<int> dp(RESOURCE_LIMIT + 1, 0), dpDiscounted(RESOURCE_LIMIT + 1, 0);
        for (int v : adj[u]) {
            auto [res, resDiscounted] = dfs(v);
            dp = maxPlusConvolve(dp, res);
            dpDiscounted = maxPlusConvolve(dpDiscounted, resDiscounted);
        }
        int cost = costs[u];
        for (int i = cost; i <= RESOURCE_LIMIT; i++) {
            dp[i] = max(dp[i], dpDiscounted[i - cost] + gains[u] - cost);
        }
        vector<int> ret = dp;
        cost >>= 1;
        for (int i = cost; i <= RESOURCE_LIMIT; i++) {
            ret[i] = max(ret[i], dpDiscounted[i - cost] + gains[u] - cost);
        }
        return {dp, ret};
    }
public:
    int maxProfit(int n, vector<int>& present, vector<int>& future, vector<vector<int>>& hierarchy, int budget) {
        RESOURCE_LIMIT = budget;
        costs = present;
        gains = future;
        adj.assign(n, vector<int>());
        for (const auto &edge : hierarchy) {
            int u = edge[0], v = edge[1];
            u--; v--;
            adj[u].emplace_back(v);
        }
        auto [ans, _] = dfs(0);
        return ans[budget];
    }
};
```

# Leetcode Weekly Contest 452

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```

## 

### Solution 1: 

```cpp

```